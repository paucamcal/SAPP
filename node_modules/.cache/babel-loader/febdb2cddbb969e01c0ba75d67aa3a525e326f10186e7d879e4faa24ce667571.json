{"ast":null,"code":"const {\n  SequenceError\n} = require('../errors/sequence');\n\n/**\r\n * @method sequence\r\n * @description\r\n * Resolves a dynamic sequence of [mixed values]{@tutorial mixed}.\r\n *\r\n * The method acquires [mixed values]{@tutorial mixed} from the `source` function, one at a time, and resolves them,\r\n * till either no more values left in the sequence or an error/reject occurs.\r\n *\r\n * It supports both [linked and detached sequencing]{@tutorial sequencing}.\r\n *\r\n * @param {Function|generator} source\r\n * Expected to return the next [mixed value]{@tutorial mixed} to be resolved. Returning or resolving\r\n * with `undefined` ends the sequence, and the method resolves.\r\n *\r\n * Parameters:\r\n *  - `index` = current request index in the sequence\r\n *  - `data` = resolved data from the previous call (`undefined` when `index=0`)\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * If the function throws an error or returns a rejected promise, the sequence terminates,\r\n * and the method rejects with {@link errors.SequenceError SequenceError}, which will have property `source` set.\r\n *\r\n * Passing in anything other than a function will reject with {@link external:TypeError TypeError} = `Parameter 'source' must be a function.`\r\n *\r\n * @param {Object} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {Function|generator} [options.dest=null]\r\n * Optional destination function (or generator), to receive resolved data for each index,\r\n * process it and respond as required.\r\n *\r\n * Parameters:\r\n *  - `index` = index of the resolved data in the sequence\r\n *  - `data` = the data resolved\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * It can optionally return a promise object, if data processing is done asynchronously.\r\n * If a promise is returned, the method will not request another value from the `source` function,\r\n * until the promise has been resolved (the resolved value is ignored).\r\n *\r\n * If the function throws an error or returns a rejected promise, the sequence terminates,\r\n * and the method rejects with {@link errors.SequenceError SequenceError}, which will have property `dest` set.\r\n *\r\n * @param {Number} [options.limit=0]\r\n * Limits the maximum size of the sequence. If the value is greater than 0, the method will\r\n * successfully resolve once the specified limit has been reached.\r\n *\r\n * When `limit` isn't specified (default), the sequence is unlimited, and it will continue\r\n * till one of the following occurs:\r\n *  - `source` either returns or resolves with `undefined`\r\n *  - either `source` or `dest` functions throw an error or return a rejected promise\r\n *\r\n * @param {Boolean} [options.track=false]\r\n * Changes the type of data to be resolved by this method. By default, it is `false`\r\n * (see the return result). When set to be `true`, the method tracks/collects all resolved data\r\n * into an array internally, and resolves with that array once the method has finished successfully.\r\n *\r\n * It must be used with caution, as to the size of the sequence, because accumulating data for\r\n * a very large sequence can result in consuming too much memory.\r\n *\r\n * @returns {external:Promise}\r\n *\r\n * When successful, the resolved data depends on parameter `track`. When `track` is `false`\r\n * (default), the method resolves with object `{total, duration}`:\r\n *  - `total` = number of values resolved by the sequence\r\n *  - `duration` = number of milliseconds consumed by the method\r\n *\r\n * When `track` is `true`, the method resolves with an array of all the data that has been resolved,\r\n * the same way that the standard $[promise.all] resolves. In addition, the array comes extended with\r\n * a hidden read-only property `duration` - number of milliseconds consumed by the method.\r\n *\r\n * When the method fails, it rejects with {@link errors.SequenceError SequenceError}.\r\n */\nfunction sequence(source, options, config) {\n  const $p = config.promise,\n    utils = config.utils;\n  if (typeof source !== 'function') {\n    return $p.reject(new TypeError('Parameter \\'source\\' must be a function.'));\n  }\n  source = utils.wrap(source);\n  options = options || {};\n  const limit = options.limit > 0 ? parseInt(options.limit) : 0,\n    dest = utils.wrap(options.dest),\n    self = this,\n    start = Date.now();\n  let data,\n    srcTime,\n    destTime,\n    result = [];\n  return $p((resolve, reject) => {\n    function loop(idx) {\n      const srcNow = Date.now(),\n        srcDelay = idx ? srcNow - srcTime : undefined;\n      srcTime = srcNow;\n      utils.resolve.call(self, source, [idx, data, srcDelay], (value, delayed) => {\n        data = value;\n        if (data === undefined) {\n          success();\n        } else {\n          if (options.track) {\n            result.push(data);\n          }\n          if (dest) {\n            const destNow = Date.now(),\n              destDelay = idx ? destNow - destTime : undefined;\n            let destResult;\n            destTime = destNow;\n            try {\n              destResult = dest.call(self, idx, data, destDelay);\n            } catch (e) {\n              fail({\n                error: e,\n                dest: data\n              }, 3, dest.name);\n              return;\n            }\n            if (utils.isPromise(destResult)) {\n              destResult.then(() => {\n                next(true);\n                return null; // this dummy return is just to prevent Bluebird warnings;\n              }).catch(error => {\n                fail({\n                  error: error,\n                  dest: data\n                }, 2, dest.name);\n              });\n            } else {\n              next(delayed);\n            }\n          } else {\n            next(delayed);\n          }\n        }\n      }, (reason, isRej) => {\n        fail({\n          error: reason,\n          source: data\n        }, isRej ? 0 : 1, source.name);\n      });\n      function next(delayed) {\n        if (limit === ++idx) {\n          success();\n        } else {\n          if (delayed) {\n            loop(idx);\n          } else {\n            $p.resolve().then(() => {\n              loop(idx);\n              return null; // this dummy return is just to prevent Bluebird warnings;\n            });\n          }\n        }\n      }\n\n      function success() {\n        const length = Date.now() - start;\n        if (options.track) {\n          utils.extend(result, 'duration', length);\n        } else {\n          result = {\n            total: idx,\n            duration: length\n          };\n        }\n        resolve(result);\n      }\n      function fail(reason, code, cbName) {\n        reason.index = idx;\n        reject(new SequenceError(reason, code, cbName, Date.now() - start));\n      }\n    }\n    loop(0);\n  });\n}\nmodule.exports = function (config) {\n  return function (source, options) {\n    return sequence.call(this, source, options, config);\n  };\n};","map":{"version":3,"names":["SequenceError","require","sequence","source","options","config","$p","promise","utils","reject","TypeError","wrap","limit","parseInt","dest","self","start","Date","now","data","srcTime","destTime","result","resolve","loop","idx","srcNow","srcDelay","undefined","call","value","delayed","success","track","push","destNow","destDelay","destResult","e","fail","error","name","isPromise","then","next","catch","reason","isRej","length","extend","total","duration","code","cbName","index","module","exports"],"sources":["/Users/luna/Library/Mobile Documents/com~apple~CloudDocs/GitHub/paucamcal.github.io/AESP/node_modules/spex/lib/ext/sequence.js"],"sourcesContent":["const {SequenceError} = require('../errors/sequence');\r\n\r\n/**\r\n * @method sequence\r\n * @description\r\n * Resolves a dynamic sequence of [mixed values]{@tutorial mixed}.\r\n *\r\n * The method acquires [mixed values]{@tutorial mixed} from the `source` function, one at a time, and resolves them,\r\n * till either no more values left in the sequence or an error/reject occurs.\r\n *\r\n * It supports both [linked and detached sequencing]{@tutorial sequencing}.\r\n *\r\n * @param {Function|generator} source\r\n * Expected to return the next [mixed value]{@tutorial mixed} to be resolved. Returning or resolving\r\n * with `undefined` ends the sequence, and the method resolves.\r\n *\r\n * Parameters:\r\n *  - `index` = current request index in the sequence\r\n *  - `data` = resolved data from the previous call (`undefined` when `index=0`)\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * If the function throws an error or returns a rejected promise, the sequence terminates,\r\n * and the method rejects with {@link errors.SequenceError SequenceError}, which will have property `source` set.\r\n *\r\n * Passing in anything other than a function will reject with {@link external:TypeError TypeError} = `Parameter 'source' must be a function.`\r\n *\r\n * @param {Object} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {Function|generator} [options.dest=null]\r\n * Optional destination function (or generator), to receive resolved data for each index,\r\n * process it and respond as required.\r\n *\r\n * Parameters:\r\n *  - `index` = index of the resolved data in the sequence\r\n *  - `data` = the data resolved\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * It can optionally return a promise object, if data processing is done asynchronously.\r\n * If a promise is returned, the method will not request another value from the `source` function,\r\n * until the promise has been resolved (the resolved value is ignored).\r\n *\r\n * If the function throws an error or returns a rejected promise, the sequence terminates,\r\n * and the method rejects with {@link errors.SequenceError SequenceError}, which will have property `dest` set.\r\n *\r\n * @param {Number} [options.limit=0]\r\n * Limits the maximum size of the sequence. If the value is greater than 0, the method will\r\n * successfully resolve once the specified limit has been reached.\r\n *\r\n * When `limit` isn't specified (default), the sequence is unlimited, and it will continue\r\n * till one of the following occurs:\r\n *  - `source` either returns or resolves with `undefined`\r\n *  - either `source` or `dest` functions throw an error or return a rejected promise\r\n *\r\n * @param {Boolean} [options.track=false]\r\n * Changes the type of data to be resolved by this method. By default, it is `false`\r\n * (see the return result). When set to be `true`, the method tracks/collects all resolved data\r\n * into an array internally, and resolves with that array once the method has finished successfully.\r\n *\r\n * It must be used with caution, as to the size of the sequence, because accumulating data for\r\n * a very large sequence can result in consuming too much memory.\r\n *\r\n * @returns {external:Promise}\r\n *\r\n * When successful, the resolved data depends on parameter `track`. When `track` is `false`\r\n * (default), the method resolves with object `{total, duration}`:\r\n *  - `total` = number of values resolved by the sequence\r\n *  - `duration` = number of milliseconds consumed by the method\r\n *\r\n * When `track` is `true`, the method resolves with an array of all the data that has been resolved,\r\n * the same way that the standard $[promise.all] resolves. In addition, the array comes extended with\r\n * a hidden read-only property `duration` - number of milliseconds consumed by the method.\r\n *\r\n * When the method fails, it rejects with {@link errors.SequenceError SequenceError}.\r\n */\r\nfunction sequence(source, options, config) {\r\n\r\n    const $p = config.promise, utils = config.utils;\r\n\r\n    if (typeof source !== 'function') {\r\n        return $p.reject(new TypeError('Parameter \\'source\\' must be a function.'));\r\n    }\r\n\r\n    source = utils.wrap(source);\r\n\r\n    options = options || {};\r\n\r\n    const limit = (options.limit > 0) ? parseInt(options.limit) : 0,\r\n        dest = utils.wrap(options.dest),\r\n        self = this, start = Date.now();\r\n    let data, srcTime, destTime, result = [];\r\n\r\n    return $p((resolve, reject) => {\r\n\r\n        function loop(idx) {\r\n            const srcNow = Date.now(),\r\n                srcDelay = idx ? (srcNow - srcTime) : undefined;\r\n            srcTime = srcNow;\r\n            utils.resolve.call(self, source, [idx, data, srcDelay], (value, delayed) => {\r\n                data = value;\r\n                if (data === undefined) {\r\n                    success();\r\n                } else {\r\n                    if (options.track) {\r\n                        result.push(data);\r\n                    }\r\n                    if (dest) {\r\n                        const destNow = Date.now(),\r\n                            destDelay = idx ? (destNow - destTime) : undefined;\r\n                        let destResult;\r\n                        destTime = destNow;\r\n                        try {\r\n                            destResult = dest.call(self, idx, data, destDelay);\r\n                        } catch (e) {\r\n                            fail({\r\n                                error: e,\r\n                                dest: data\r\n                            }, 3, dest.name);\r\n                            return;\r\n                        }\r\n                        if (utils.isPromise(destResult)) {\r\n                            destResult\r\n                                .then(() => {\r\n                                    next(true);\r\n                                    return null; // this dummy return is just to prevent Bluebird warnings;\r\n                                })\r\n                                .catch(error => {\r\n                                    fail({\r\n                                        error: error,\r\n                                        dest: data\r\n                                    }, 2, dest.name);\r\n                                });\r\n                        } else {\r\n                            next(delayed);\r\n                        }\r\n                    } else {\r\n                        next(delayed);\r\n                    }\r\n                }\r\n            }, (reason, isRej) => {\r\n                fail({\r\n                    error: reason,\r\n                    source: data\r\n                }, isRej ? 0 : 1, source.name);\r\n            });\r\n\r\n            function next(delayed) {\r\n                if (limit === ++idx) {\r\n                    success();\r\n                } else {\r\n                    if (delayed) {\r\n                        loop(idx);\r\n                    } else {\r\n                        $p.resolve()\r\n                            .then(() => {\r\n                                loop(idx);\r\n                                return null; // this dummy return is just to prevent Bluebird warnings;\r\n                            });\r\n                    }\r\n                }\r\n            }\r\n\r\n            function success() {\r\n                const length = Date.now() - start;\r\n                if (options.track) {\r\n                    utils.extend(result, 'duration', length);\r\n                } else {\r\n                    result = {\r\n                        total: idx,\r\n                        duration: length\r\n                    };\r\n                }\r\n                resolve(result);\r\n            }\r\n\r\n            function fail(reason, code, cbName) {\r\n                reason.index = idx;\r\n                reject(new SequenceError(reason, code, cbName, Date.now() - start));\r\n            }\r\n        }\r\n\r\n        loop(0);\r\n    });\r\n}\r\n\r\nmodule.exports = function (config) {\r\n    return function (source, options) {\r\n        return sequence.call(this, source, options, config);\r\n    };\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}