{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\n\nconst {\n  InnerState\n} = require('../inner-state');\nconst {\n  assert\n} = require('../assert');\nconst npm = {\n  os: require('os'),\n  utils: require('../utils'),\n  formatting: require('../formatting'),\n  patterns: require('../patterns')\n};\n\n/**\r\n *\r\n * @class helpers.Column\r\n * @description\r\n *\r\n * Read-only structure with details for a single column. Used primarily by {@link helpers.ColumnSet ColumnSet}.\r\n *\r\n * The class parses details into a template, to be used for query generation.\r\n *\r\n * @param {string|helpers.ColumnConfig} col\r\n * Column details, depending on the type.\r\n *\r\n * When it is a string, it is expected to contain a name for both the column and the source property, assuming that the two are the same.\r\n * The name must adhere to JavaScript syntax for variable names. The name can be appended with any format modifier as supported by\r\n * {@link formatting.format as.format} (`^`, `~`, `#`, `:csv`, `:list`, `:json`, `:alias`, `:name`, `:raw`, `:value`), which is then removed from the name and put\r\n * into property `mod`. If the name starts with `?`, it is removed, while setting flag `cnd` = `true`.\r\n *\r\n * If the string doesn't adhere to the above requirements, the method will throw {@link external:TypeError TypeError} = `Invalid column syntax`.\r\n *\r\n * When `col` is a simple {@link helpers.ColumnConfig ColumnConfig}-like object, it is used as an input configurator to set all the properties\r\n * of the class.\r\n *\r\n * @property {string} name\r\n * Destination column name + source property name (if `prop` is skipped). The name must adhere to JavaScript syntax for variables,\r\n * unless `prop` is specified, in which case `name` represents only the column name, and therefore can be any non-empty string.\r\n *\r\n * @property {string} [prop]\r\n * Source property name, if different from the column's name. It must adhere to JavaScript syntax for variables.\r\n *\r\n * It is ignored when it is the same as `name`.\r\n *\r\n * @property {string} [mod]\r\n * Formatting modifier, as supported by method {@link formatting.format as.format}: `^`, `~`, `#`, `:csv`, `:list`, `:json`, `:alias`, `:name`, `:raw`, `:value`.\r\n *\r\n * @property {string} [cast]\r\n * Server-side type casting, without `::` in front.\r\n *\r\n * @property {boolean} [cnd]\r\n * Conditional column flag.\r\n *\r\n * Used by methods {@link helpers.update update} and {@link helpers.sets sets}, ignored by methods {@link helpers.insert insert} and\r\n * {@link helpers.values values}. It indicates that the column is reserved for a `WHERE` condition, not to be set or updated.\r\n *\r\n * It can be set from a string initialization, by adding `?` in front of the name.\r\n *\r\n * @property {*} [def]\r\n * Default value for the property, to be used only when the source object doesn't have the property.\r\n * It is ignored when property `init` is set.\r\n *\r\n * @property {helpers.initCB} [init]\r\n * Override callback for the value.\r\n *\r\n * @property {helpers.skipCB} [skip]\r\n * An override for skipping columns dynamically.\r\n *\r\n * Used by methods {@link helpers.update update} (for a single object) and {@link helpers.sets sets}, ignored by methods\r\n * {@link helpers.insert insert} and {@link helpers.values values}.\r\n *\r\n * It is also ignored when conditional flag `cnd` is set.\r\n *\r\n * @returns {helpers.Column}\r\n *\r\n * @see\r\n * {@link helpers.ColumnConfig ColumnConfig},\r\n * {@link helpers.Column#castText castText},\r\n * {@link helpers.Column#escapedName escapedName},\r\n * {@link helpers.Column#variable variable}\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')({\r\n *     capSQL: true // if you want all generated SQL capitalized\r\n * });\r\n *\r\n * const Column = pgp.helpers.Column;\r\n *\r\n * // creating a column from just a name:\r\n * const col1 = new Column('colName');\r\n * console.log(col1);\r\n * //=>\r\n * // Column {\r\n * //    name: \"colName\"\r\n * // }\r\n *\r\n * // creating a column from a name + modifier:\r\n * const col2 = new Column('colName:csv');\r\n * console.log(col2);\r\n * //=>\r\n * // Column {\r\n * //    name: \"colName\"\r\n * //    mod: \":csv\"\r\n * // }\r\n *\r\n * // creating a column from a configurator:\r\n * const col3 = new Column({\r\n *     name: 'colName', // required\r\n *     prop: 'propName', // optional\r\n *     mod: '^', // optional\r\n *     def: 123 // optional\r\n * });\r\n * console.log(col3);\r\n * //=>\r\n * // Column {\r\n * //    name: \"colName\"\r\n * //    prop: \"propName\"\r\n * //    mod: \"^\"\r\n * //    def: 123\r\n * // }\r\n *\r\n */\nclass Column extends InnerState {\n  constructor(col) {\n    super();\n    if (typeof col === 'string') {\n      const info = parseColumn(col);\n      this.name = info.name;\n      if ('mod' in info) {\n        this.mod = info.mod;\n      }\n      if ('cnd' in info) {\n        this.cnd = info.cnd;\n      }\n    } else {\n      col = assert(col, ['name', 'prop', 'mod', 'cast', 'cnd', 'def', 'init', 'skip']);\n      if ('name' in col) {\n        if (!npm.utils.isText(col.name)) {\n          throw new TypeError(`Invalid 'name' value: ${npm.utils.toJson(col.name)}. A non-empty string was expected.`);\n        }\n        if (npm.utils.isNull(col.prop) && !isValidVariable(col.name)) {\n          throw new TypeError(`Invalid 'name' syntax: ${npm.utils.toJson(col.name)}.`);\n        }\n        this.name = col.name; // column name + property name (if 'prop' isn't specified)\n\n        if (!npm.utils.isNull(col.prop)) {\n          if (!npm.utils.isText(col.prop)) {\n            throw new TypeError(`Invalid 'prop' value: ${npm.utils.toJson(col.prop)}. A non-empty string was expected.`);\n          }\n          if (!isValidVariable(col.prop)) {\n            throw new TypeError(`Invalid 'prop' syntax: ${npm.utils.toJson(col.prop)}.`);\n          }\n          if (col.prop !== col.name) {\n            // optional property name, if different from the column's name;\n            this.prop = col.prop;\n          }\n        }\n        if (!npm.utils.isNull(col.mod)) {\n          if (typeof col.mod !== 'string' || !isValidMod(col.mod)) {\n            throw new TypeError(`Invalid 'mod' value: ${npm.utils.toJson(col.mod)}.`);\n          }\n          this.mod = col.mod; // optional format modifier;\n        }\n\n        if (!npm.utils.isNull(col.cast)) {\n          this.cast = parseCast(col.cast); // optional SQL type casting\n        }\n\n        if ('cnd' in col) {\n          this.cnd = !!col.cnd;\n        }\n        if ('def' in col) {\n          this.def = col.def; // optional default\n        }\n\n        if (typeof col.init === 'function') {\n          this.init = col.init; // optional value override (overrides 'def' also)\n        }\n\n        if (typeof col.skip === 'function') {\n          this.skip = col.skip;\n        }\n      } else {\n        throw new TypeError('Invalid column details.');\n      }\n    }\n    const variable = '${' + (this.prop || this.name) + (this.mod || '') + '}';\n    const castText = this.cast ? '::' + this.cast : '';\n    const escapedName = npm.formatting.as.name(this.name);\n    this.extendState({\n      variable,\n      castText,\n      escapedName\n    });\n    Object.freeze(this);\n  }\n\n  /**\r\n   * @name helpers.Column#variable\r\n   * @type string\r\n   * @readonly\r\n   * @description\r\n   * Full-syntax formatting variable, ready for direct use in query templates.\r\n   *\r\n   * @example\r\n   *\r\n   * const cs = new pgp.helpers.ColumnSet([\r\n   *     'id',\r\n   *     'coordinate:json',\r\n   *     {\r\n   *         name: 'places',\r\n   *         mod: ':csv',\r\n   *         cast: 'int[]'\r\n   *     }\r\n   * ]);\r\n   *\r\n   * // cs.columns[0].variable = ${id}\r\n   * // cs.columns[1].variable = ${coordinate:json}\r\n   * // cs.columns[2].variable = ${places:csv}::int[]\r\n   */\n  get variable() {\n    return this._inner.variable;\n  }\n\n  /**\r\n   * @name helpers.Column#castText\r\n   * @type string\r\n   * @readonly\r\n   * @description\r\n   * Full-syntax sql type casting, if there is any, or else an empty string.\r\n   */\n  get castText() {\n    return this._inner.castText;\n  }\n\n  /**\r\n   * @name helpers.Column#escapedName\r\n   * @type string\r\n   * @readonly\r\n   * @description\r\n   * Escaped name of the column, ready to be injected into queries directly.\r\n   *\r\n   */\n  get escapedName() {\n    return this._inner.escapedName;\n  }\n}\nfunction parseCast(name) {\n  if (typeof name === 'string') {\n    const s = name.replace(/^[:\\s]*|\\s*$/g, '');\n    if (s) {\n      return s;\n    }\n  }\n  throw new TypeError(`Invalid 'cast' value: ${npm.utils.toJson(name)}.`);\n}\nfunction parseColumn(name) {\n  const m = name.match(npm.patterns.validColumn);\n  if (m && m[0] === name) {\n    const res = {};\n    if (name[0] === '?') {\n      res.cnd = true;\n      name = name.substr(1);\n    }\n    const mod = name.match(npm.patterns.hasValidModifier);\n    if (mod) {\n      res.name = name.substr(0, mod.index);\n      res.mod = mod[0];\n    } else {\n      res.name = name;\n    }\n    return res;\n  }\n  throw new TypeError(`Invalid column syntax: ${npm.utils.toJson(name)}.`);\n}\nfunction isValidMod(mod) {\n  return npm.patterns.validModifiers.indexOf(mod) !== -1;\n}\nfunction isValidVariable(name) {\n  const m = name.match(npm.patterns.validVariable);\n  return !!m && m[0] === name;\n}\n\n/**\r\n * @method helpers.Column#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\nColumn.prototype.toString = function (level) {\n  level = level > 0 ? parseInt(level) : 0;\n  const gap0 = npm.utils.messageGap(level),\n    gap1 = npm.utils.messageGap(level + 1),\n    lines = [gap0 + 'Column {', gap1 + 'name: ' + npm.utils.toJson(this.name)];\n  if ('prop' in this) {\n    lines.push(gap1 + 'prop: ' + npm.utils.toJson(this.prop));\n  }\n  if ('mod' in this) {\n    lines.push(gap1 + 'mod: ' + npm.utils.toJson(this.mod));\n  }\n  if ('cast' in this) {\n    lines.push(gap1 + 'cast: ' + npm.utils.toJson(this.cast));\n  }\n  if ('cnd' in this) {\n    lines.push(gap1 + 'cnd: ' + npm.utils.toJson(this.cnd));\n  }\n  if ('def' in this) {\n    lines.push(gap1 + 'def: ' + npm.utils.toJson(this.def));\n  }\n  if ('init' in this) {\n    lines.push(gap1 + 'init: [Function]');\n  }\n  if ('skip' in this) {\n    lines.push(gap1 + 'skip: [Function]');\n  }\n  lines.push(gap0 + '}');\n  return lines.join(npm.os.EOL);\n};\nnpm.utils.addInspection(Column, function () {\n  return this.toString();\n});\n\n/**\r\n * @typedef helpers.ColumnConfig\r\n * @description\r\n * A simple structure with column details, to be passed into the {@link helpers.Column Column} constructor for initialization.\r\n *\r\n * @property {string} name\r\n * Destination column name + source property name (if `prop` is skipped). The name must adhere to JavaScript syntax for variables,\r\n * unless `prop` is specified, in which case `name` represents only the column name, and therefore can be any non-empty string.\r\n *\r\n * @property {string} [prop]\r\n * Source property name, if different from the column's name. It must adhere to JavaScript syntax for variables.\r\n *\r\n * It is ignored when it is the same as `name`.\r\n *\r\n * @property {string} [mod]\r\n * Formatting modifier, as supported by method {@link formatting.format as.format}: `^`, `~`, `#`, `:csv`, `:list`, `:json`, `:alias`, `:name`, `:raw`, `:value`.\r\n *\r\n * @property {string} [cast]\r\n * Server-side type casting. Leading `::` is allowed, but not needed (automatically removed when specified).\r\n *\r\n * @property {boolean} [cnd]\r\n * Conditional column flag.\r\n *\r\n * Used by methods {@link helpers.update update} and {@link helpers.sets sets}, ignored by methods {@link helpers.insert insert} and\r\n * {@link helpers.values values}. It indicates that the column is reserved for a `WHERE` condition, not to be set or updated.\r\n *\r\n * It can be set from a string initialization, by adding `?` in front of the name.\r\n *\r\n * @property {*} [def]\r\n * Default value for the property, to be used only when the source object doesn't have the property.\r\n * It is ignored when property `init` is set.\r\n *\r\n * @property {helpers.initCB} [init]\r\n * Override callback for the value.\r\n *\r\n * @property {helpers.skipCB} [skip]\r\n * An override for skipping columns dynamically.\r\n *\r\n * Used by methods {@link helpers.update update} (for a single object) and {@link helpers.sets sets}, ignored by methods\r\n * {@link helpers.insert insert} and {@link helpers.values values}.\r\n *\r\n * It is also ignored when conditional flag `cnd` is set.\r\n *\r\n */\n\n/**\r\n * @callback helpers.initCB\r\n * @description\r\n * A callback function type used by parameter `init` within {@link helpers.ColumnConfig ColumnConfig}.\r\n *\r\n * It works as an override for the corresponding property value in the `source` object.\r\n *\r\n * The function is called with `this` set to the `source` object.\r\n *\r\n * @param {*} col\r\n * Column-to-property descriptor.\r\n *\r\n * @param {object} col.source\r\n * The source object, equals to `this` that's passed into the function.\r\n *\r\n * @param {string} col.name\r\n * Resolved name of the property within the `source` object, i.e. the value of `name` when `prop` is not used\r\n * for the column, or the value of `prop` when it is specified.\r\n *\r\n * @param {*} col.value\r\n *\r\n * Property value, set to one of the following:\r\n *\r\n * - Value of the property within the `source` object (`value` = `source[name]`), if the property exists\r\n * - If the property doesn't exist and `def` is set in the column, then `value` is set to the value of `def`\r\n * - If the property doesn't exist and `def` is not set in the column, then `value` is set to `undefined`\r\n *\r\n * @param {boolean} col.exists\r\n * Indicates whether the property exists in the `source` object (`exists = name in source`).\r\n *\r\n * @returns {*}\r\n * The new value to be used for the corresponding column.\r\n */\n\n/**\r\n * @callback helpers.skipCB\r\n * @description\r\n * A callback function type used by parameter `skip` within {@link helpers.ColumnConfig ColumnConfig}.\r\n *\r\n * It is to dynamically determine when the property with specified `name` in the `source` object is to be skipped.\r\n *\r\n * The function is called with `this` set to the `source` object.\r\n *\r\n * @param {*} col\r\n * Column-to-property descriptor.\r\n *\r\n * @param {object} col.source\r\n * The source object, equals to `this` that's passed into the function.\r\n *\r\n * @param {string} col.name\r\n * Resolved name of the property within the `source` object, i.e. the value of `name` when `prop` is not used\r\n * for the column, or the value of `prop` when it is specified.\r\n *\r\n * @param {*} col.value\r\n *\r\n * Property value, set to one of the following:\r\n *\r\n * - Value of the property within the `source` object (`value` = `source[name]`), if the property exists\r\n * - If the property doesn't exist and `def` is set in the column, then `value` is set to the value of `def`\r\n * - If the property doesn't exist and `def` is not set in the column, then `value` is set to `undefined`\r\n *\r\n * @param {boolean} col.exists\r\n * Indicates whether the property exists in the `source` object (`exists = name in source`).\r\n *\r\n * @returns {boolean}\r\n * A truthy value that indicates whether the column is to be skipped.\r\n *\r\n */\n\nmodule.exports = {\n  Column\n};","map":{"version":3,"names":["InnerState","require","assert","npm","os","utils","formatting","patterns","Column","constructor","col","info","parseColumn","name","mod","cnd","isText","TypeError","toJson","isNull","prop","isValidVariable","isValidMod","cast","parseCast","def","init","skip","variable","castText","escapedName","as","extendState","Object","freeze","_inner","s","replace","m","match","validColumn","res","substr","hasValidModifier","index","validModifiers","indexOf","validVariable","prototype","toString","level","parseInt","gap0","messageGap","gap1","lines","push","join","EOL","addInspection","module","exports"],"sources":["/Users/luna/Library/Mobile Documents/com~apple~CloudDocs/GitHub/paucamcal.github.io/AESP/node_modules/pg-promise/lib/helpers/column.js"],"sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {InnerState} = require('../inner-state');\r\nconst {assert} = require('../assert');\r\n\r\nconst npm = {\r\n    os: require('os'),\r\n    utils: require('../utils'),\r\n    formatting: require('../formatting'),\r\n    patterns: require('../patterns')\r\n};\r\n\r\n/**\r\n *\r\n * @class helpers.Column\r\n * @description\r\n *\r\n * Read-only structure with details for a single column. Used primarily by {@link helpers.ColumnSet ColumnSet}.\r\n *\r\n * The class parses details into a template, to be used for query generation.\r\n *\r\n * @param {string|helpers.ColumnConfig} col\r\n * Column details, depending on the type.\r\n *\r\n * When it is a string, it is expected to contain a name for both the column and the source property, assuming that the two are the same.\r\n * The name must adhere to JavaScript syntax for variable names. The name can be appended with any format modifier as supported by\r\n * {@link formatting.format as.format} (`^`, `~`, `#`, `:csv`, `:list`, `:json`, `:alias`, `:name`, `:raw`, `:value`), which is then removed from the name and put\r\n * into property `mod`. If the name starts with `?`, it is removed, while setting flag `cnd` = `true`.\r\n *\r\n * If the string doesn't adhere to the above requirements, the method will throw {@link external:TypeError TypeError} = `Invalid column syntax`.\r\n *\r\n * When `col` is a simple {@link helpers.ColumnConfig ColumnConfig}-like object, it is used as an input configurator to set all the properties\r\n * of the class.\r\n *\r\n * @property {string} name\r\n * Destination column name + source property name (if `prop` is skipped). The name must adhere to JavaScript syntax for variables,\r\n * unless `prop` is specified, in which case `name` represents only the column name, and therefore can be any non-empty string.\r\n *\r\n * @property {string} [prop]\r\n * Source property name, if different from the column's name. It must adhere to JavaScript syntax for variables.\r\n *\r\n * It is ignored when it is the same as `name`.\r\n *\r\n * @property {string} [mod]\r\n * Formatting modifier, as supported by method {@link formatting.format as.format}: `^`, `~`, `#`, `:csv`, `:list`, `:json`, `:alias`, `:name`, `:raw`, `:value`.\r\n *\r\n * @property {string} [cast]\r\n * Server-side type casting, without `::` in front.\r\n *\r\n * @property {boolean} [cnd]\r\n * Conditional column flag.\r\n *\r\n * Used by methods {@link helpers.update update} and {@link helpers.sets sets}, ignored by methods {@link helpers.insert insert} and\r\n * {@link helpers.values values}. It indicates that the column is reserved for a `WHERE` condition, not to be set or updated.\r\n *\r\n * It can be set from a string initialization, by adding `?` in front of the name.\r\n *\r\n * @property {*} [def]\r\n * Default value for the property, to be used only when the source object doesn't have the property.\r\n * It is ignored when property `init` is set.\r\n *\r\n * @property {helpers.initCB} [init]\r\n * Override callback for the value.\r\n *\r\n * @property {helpers.skipCB} [skip]\r\n * An override for skipping columns dynamically.\r\n *\r\n * Used by methods {@link helpers.update update} (for a single object) and {@link helpers.sets sets}, ignored by methods\r\n * {@link helpers.insert insert} and {@link helpers.values values}.\r\n *\r\n * It is also ignored when conditional flag `cnd` is set.\r\n *\r\n * @returns {helpers.Column}\r\n *\r\n * @see\r\n * {@link helpers.ColumnConfig ColumnConfig},\r\n * {@link helpers.Column#castText castText},\r\n * {@link helpers.Column#escapedName escapedName},\r\n * {@link helpers.Column#variable variable}\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')({\r\n *     capSQL: true // if you want all generated SQL capitalized\r\n * });\r\n *\r\n * const Column = pgp.helpers.Column;\r\n *\r\n * // creating a column from just a name:\r\n * const col1 = new Column('colName');\r\n * console.log(col1);\r\n * //=>\r\n * // Column {\r\n * //    name: \"colName\"\r\n * // }\r\n *\r\n * // creating a column from a name + modifier:\r\n * const col2 = new Column('colName:csv');\r\n * console.log(col2);\r\n * //=>\r\n * // Column {\r\n * //    name: \"colName\"\r\n * //    mod: \":csv\"\r\n * // }\r\n *\r\n * // creating a column from a configurator:\r\n * const col3 = new Column({\r\n *     name: 'colName', // required\r\n *     prop: 'propName', // optional\r\n *     mod: '^', // optional\r\n *     def: 123 // optional\r\n * });\r\n * console.log(col3);\r\n * //=>\r\n * // Column {\r\n * //    name: \"colName\"\r\n * //    prop: \"propName\"\r\n * //    mod: \"^\"\r\n * //    def: 123\r\n * // }\r\n *\r\n */\r\nclass Column extends InnerState {\r\n\r\n    constructor(col) {\r\n        super();\r\n\r\n        if (typeof col === 'string') {\r\n            const info = parseColumn(col);\r\n            this.name = info.name;\r\n            if ('mod' in info) {\r\n                this.mod = info.mod;\r\n            }\r\n            if ('cnd' in info) {\r\n                this.cnd = info.cnd;\r\n            }\r\n        } else {\r\n            col = assert(col, ['name', 'prop', 'mod', 'cast', 'cnd', 'def', 'init', 'skip']);\r\n            if ('name' in col) {\r\n                if (!npm.utils.isText(col.name)) {\r\n                    throw new TypeError(`Invalid 'name' value: ${npm.utils.toJson(col.name)}. A non-empty string was expected.`);\r\n                }\r\n                if (npm.utils.isNull(col.prop) && !isValidVariable(col.name)) {\r\n                    throw new TypeError(`Invalid 'name' syntax: ${npm.utils.toJson(col.name)}.`);\r\n                }\r\n                this.name = col.name; // column name + property name (if 'prop' isn't specified)\r\n\r\n                if (!npm.utils.isNull(col.prop)) {\r\n                    if (!npm.utils.isText(col.prop)) {\r\n                        throw new TypeError(`Invalid 'prop' value: ${npm.utils.toJson(col.prop)}. A non-empty string was expected.`);\r\n                    }\r\n                    if (!isValidVariable(col.prop)) {\r\n                        throw new TypeError(`Invalid 'prop' syntax: ${npm.utils.toJson(col.prop)}.`);\r\n                    }\r\n                    if (col.prop !== col.name) {\r\n                        // optional property name, if different from the column's name;\r\n                        this.prop = col.prop;\r\n                    }\r\n                }\r\n                if (!npm.utils.isNull(col.mod)) {\r\n                    if (typeof col.mod !== 'string' || !isValidMod(col.mod)) {\r\n                        throw new TypeError(`Invalid 'mod' value: ${npm.utils.toJson(col.mod)}.`);\r\n                    }\r\n                    this.mod = col.mod; // optional format modifier;\r\n                }\r\n                if (!npm.utils.isNull(col.cast)) {\r\n                    this.cast = parseCast(col.cast); // optional SQL type casting\r\n                }\r\n                if ('cnd' in col) {\r\n                    this.cnd = !!col.cnd;\r\n                }\r\n                if ('def' in col) {\r\n                    this.def = col.def; // optional default\r\n                }\r\n                if (typeof col.init === 'function') {\r\n                    this.init = col.init; // optional value override (overrides 'def' also)\r\n                }\r\n                if (typeof col.skip === 'function') {\r\n                    this.skip = col.skip;\r\n                }\r\n            } else {\r\n                throw new TypeError('Invalid column details.');\r\n            }\r\n        }\r\n\r\n        const variable = '${' + (this.prop || this.name) + (this.mod || '') + '}';\r\n        const castText = this.cast ? ('::' + this.cast) : '';\r\n        const escapedName = npm.formatting.as.name(this.name);\r\n\r\n        this.extendState({variable, castText, escapedName});\r\n        Object.freeze(this);\r\n    }\r\n\r\n    /**\r\n     * @name helpers.Column#variable\r\n     * @type string\r\n     * @readonly\r\n     * @description\r\n     * Full-syntax formatting variable, ready for direct use in query templates.\r\n     *\r\n     * @example\r\n     *\r\n     * const cs = new pgp.helpers.ColumnSet([\r\n     *     'id',\r\n     *     'coordinate:json',\r\n     *     {\r\n     *         name: 'places',\r\n     *         mod: ':csv',\r\n     *         cast: 'int[]'\r\n     *     }\r\n     * ]);\r\n     *\r\n     * // cs.columns[0].variable = ${id}\r\n     * // cs.columns[1].variable = ${coordinate:json}\r\n     * // cs.columns[2].variable = ${places:csv}::int[]\r\n     */\r\n    get variable() {\r\n        return this._inner.variable;\r\n    }\r\n\r\n    /**\r\n     * @name helpers.Column#castText\r\n     * @type string\r\n     * @readonly\r\n     * @description\r\n     * Full-syntax sql type casting, if there is any, or else an empty string.\r\n     */\r\n    get castText() {\r\n        return this._inner.castText;\r\n    }\r\n\r\n    /**\r\n     * @name helpers.Column#escapedName\r\n     * @type string\r\n     * @readonly\r\n     * @description\r\n     * Escaped name of the column, ready to be injected into queries directly.\r\n     *\r\n     */\r\n    get escapedName() {\r\n        return this._inner.escapedName;\r\n    }\r\n\r\n}\r\n\r\nfunction parseCast(name) {\r\n    if (typeof name === 'string') {\r\n        const s = name.replace(/^[:\\s]*|\\s*$/g, '');\r\n        if (s) {\r\n            return s;\r\n        }\r\n    }\r\n    throw new TypeError(`Invalid 'cast' value: ${npm.utils.toJson(name)}.`);\r\n}\r\n\r\nfunction parseColumn(name) {\r\n    const m = name.match(npm.patterns.validColumn);\r\n    if (m && m[0] === name) {\r\n        const res = {};\r\n        if (name[0] === '?') {\r\n            res.cnd = true;\r\n            name = name.substr(1);\r\n        }\r\n        const mod = name.match(npm.patterns.hasValidModifier);\r\n        if (mod) {\r\n            res.name = name.substr(0, mod.index);\r\n            res.mod = mod[0];\r\n        } else {\r\n            res.name = name;\r\n        }\r\n        return res;\r\n    }\r\n    throw new TypeError(`Invalid column syntax: ${npm.utils.toJson(name)}.`);\r\n}\r\n\r\nfunction isValidMod(mod) {\r\n    return npm.patterns.validModifiers.indexOf(mod) !== -1;\r\n}\r\n\r\nfunction isValidVariable(name) {\r\n    const m = name.match(npm.patterns.validVariable);\r\n    return !!m && m[0] === name;\r\n}\r\n\r\n/**\r\n * @method helpers.Column#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\r\nColumn.prototype.toString = function (level) {\r\n    level = level > 0 ? parseInt(level) : 0;\r\n    const gap0 = npm.utils.messageGap(level),\r\n        gap1 = npm.utils.messageGap(level + 1),\r\n        lines = [\r\n            gap0 + 'Column {',\r\n            gap1 + 'name: ' + npm.utils.toJson(this.name)\r\n        ];\r\n    if ('prop' in this) {\r\n        lines.push(gap1 + 'prop: ' + npm.utils.toJson(this.prop));\r\n    }\r\n    if ('mod' in this) {\r\n        lines.push(gap1 + 'mod: ' + npm.utils.toJson(this.mod));\r\n    }\r\n    if ('cast' in this) {\r\n        lines.push(gap1 + 'cast: ' + npm.utils.toJson(this.cast));\r\n    }\r\n    if ('cnd' in this) {\r\n        lines.push(gap1 + 'cnd: ' + npm.utils.toJson(this.cnd));\r\n    }\r\n    if ('def' in this) {\r\n        lines.push(gap1 + 'def: ' + npm.utils.toJson(this.def));\r\n    }\r\n    if ('init' in this) {\r\n        lines.push(gap1 + 'init: [Function]');\r\n    }\r\n    if ('skip' in this) {\r\n        lines.push(gap1 + 'skip: [Function]');\r\n    }\r\n    lines.push(gap0 + '}');\r\n    return lines.join(npm.os.EOL);\r\n};\r\n\r\nnpm.utils.addInspection(Column, function () {\r\n    return this.toString();\r\n});\r\n\r\n/**\r\n * @typedef helpers.ColumnConfig\r\n * @description\r\n * A simple structure with column details, to be passed into the {@link helpers.Column Column} constructor for initialization.\r\n *\r\n * @property {string} name\r\n * Destination column name + source property name (if `prop` is skipped). The name must adhere to JavaScript syntax for variables,\r\n * unless `prop` is specified, in which case `name` represents only the column name, and therefore can be any non-empty string.\r\n *\r\n * @property {string} [prop]\r\n * Source property name, if different from the column's name. It must adhere to JavaScript syntax for variables.\r\n *\r\n * It is ignored when it is the same as `name`.\r\n *\r\n * @property {string} [mod]\r\n * Formatting modifier, as supported by method {@link formatting.format as.format}: `^`, `~`, `#`, `:csv`, `:list`, `:json`, `:alias`, `:name`, `:raw`, `:value`.\r\n *\r\n * @property {string} [cast]\r\n * Server-side type casting. Leading `::` is allowed, but not needed (automatically removed when specified).\r\n *\r\n * @property {boolean} [cnd]\r\n * Conditional column flag.\r\n *\r\n * Used by methods {@link helpers.update update} and {@link helpers.sets sets}, ignored by methods {@link helpers.insert insert} and\r\n * {@link helpers.values values}. It indicates that the column is reserved for a `WHERE` condition, not to be set or updated.\r\n *\r\n * It can be set from a string initialization, by adding `?` in front of the name.\r\n *\r\n * @property {*} [def]\r\n * Default value for the property, to be used only when the source object doesn't have the property.\r\n * It is ignored when property `init` is set.\r\n *\r\n * @property {helpers.initCB} [init]\r\n * Override callback for the value.\r\n *\r\n * @property {helpers.skipCB} [skip]\r\n * An override for skipping columns dynamically.\r\n *\r\n * Used by methods {@link helpers.update update} (for a single object) and {@link helpers.sets sets}, ignored by methods\r\n * {@link helpers.insert insert} and {@link helpers.values values}.\r\n *\r\n * It is also ignored when conditional flag `cnd` is set.\r\n *\r\n */\r\n\r\n/**\r\n * @callback helpers.initCB\r\n * @description\r\n * A callback function type used by parameter `init` within {@link helpers.ColumnConfig ColumnConfig}.\r\n *\r\n * It works as an override for the corresponding property value in the `source` object.\r\n *\r\n * The function is called with `this` set to the `source` object.\r\n *\r\n * @param {*} col\r\n * Column-to-property descriptor.\r\n *\r\n * @param {object} col.source\r\n * The source object, equals to `this` that's passed into the function.\r\n *\r\n * @param {string} col.name\r\n * Resolved name of the property within the `source` object, i.e. the value of `name` when `prop` is not used\r\n * for the column, or the value of `prop` when it is specified.\r\n *\r\n * @param {*} col.value\r\n *\r\n * Property value, set to one of the following:\r\n *\r\n * - Value of the property within the `source` object (`value` = `source[name]`), if the property exists\r\n * - If the property doesn't exist and `def` is set in the column, then `value` is set to the value of `def`\r\n * - If the property doesn't exist and `def` is not set in the column, then `value` is set to `undefined`\r\n *\r\n * @param {boolean} col.exists\r\n * Indicates whether the property exists in the `source` object (`exists = name in source`).\r\n *\r\n * @returns {*}\r\n * The new value to be used for the corresponding column.\r\n */\r\n\r\n/**\r\n * @callback helpers.skipCB\r\n * @description\r\n * A callback function type used by parameter `skip` within {@link helpers.ColumnConfig ColumnConfig}.\r\n *\r\n * It is to dynamically determine when the property with specified `name` in the `source` object is to be skipped.\r\n *\r\n * The function is called with `this` set to the `source` object.\r\n *\r\n * @param {*} col\r\n * Column-to-property descriptor.\r\n *\r\n * @param {object} col.source\r\n * The source object, equals to `this` that's passed into the function.\r\n *\r\n * @param {string} col.name\r\n * Resolved name of the property within the `source` object, i.e. the value of `name` when `prop` is not used\r\n * for the column, or the value of `prop` when it is specified.\r\n *\r\n * @param {*} col.value\r\n *\r\n * Property value, set to one of the following:\r\n *\r\n * - Value of the property within the `source` object (`value` = `source[name]`), if the property exists\r\n * - If the property doesn't exist and `def` is set in the column, then `value` is set to the value of `def`\r\n * - If the property doesn't exist and `def` is not set in the column, then `value` is set to `undefined`\r\n *\r\n * @param {boolean} col.exists\r\n * Indicates whether the property exists in the `source` object (`exists = name in source`).\r\n *\r\n * @returns {boolean}\r\n * A truthy value that indicates whether the column is to be skipped.\r\n *\r\n */\r\n\r\nmodule.exports = {Column};\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM;EAACA;AAAU,CAAC,GAAGC,OAAO,CAAC,gBAAgB,CAAC;AAC9C,MAAM;EAACC;AAAM,CAAC,GAAGD,OAAO,CAAC,WAAW,CAAC;AAErC,MAAME,GAAG,GAAG;EACRC,EAAE,EAAEH,OAAO,CAAC,IAAI,CAAC;EACjBI,KAAK,EAAEJ,OAAO,CAAC,UAAU,CAAC;EAC1BK,UAAU,EAAEL,OAAO,CAAC,eAAe,CAAC;EACpCM,QAAQ,EAAEN,OAAO,CAAC,aAAa;AACnC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMO,MAAM,SAASR,UAAU,CAAC;EAE5BS,WAAWA,CAACC,GAAG,EAAE;IACb,KAAK,CAAC,CAAC;IAEP,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;MACzB,MAAMC,IAAI,GAAGC,WAAW,CAACF,GAAG,CAAC;MAC7B,IAAI,CAACG,IAAI,GAAGF,IAAI,CAACE,IAAI;MACrB,IAAI,KAAK,IAAIF,IAAI,EAAE;QACf,IAAI,CAACG,GAAG,GAAGH,IAAI,CAACG,GAAG;MACvB;MACA,IAAI,KAAK,IAAIH,IAAI,EAAE;QACf,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AACC,IAAI,CAACF,IAAI,GAAG,QAAQ,GAAGnD,GAAG,CAACE,KAAK,CAACa,MAAM,CAAC,IAAI,CAACE,IAAI,CAAC,CAAC;EAC7D;EACA,IAAI,KAAK,IAAI,IAAI,EAAE;IACfmC,KAAK,CAACC,IAAI,CAACF,IAAI,GAAG,OAAO,GAAGnD,GAAG,CAACE,KAAK,CAACa,MAAM,CAAC,IAAI,CAACJ,GAAG,CAAC,CAAC;EAC3D;EACA,IAAI,MAAM,IAAI,IAAI,EAAE;IAChByC,KAAK,CAACC,IAAI,CAACF,IAAI,GAAG,QAAQ,GAAGnD,GAAG,CAACE,KAAK,CAACa,MAAM,CAAC,IAAI,CAACK,IAAI,CAAC,CAAC;EAC7D;EACA,IAAI,KAAK,IAAI,IAAI,EAAE;IACfgC,KAAK,CAACC,IAAI,CAACF,IAAI,GAAG,OAAO,GAAGnD,GAAG,CAACE,KAAK,CAACa,MAAM,CAAC,IAAI,CAACH,GAAG,CAAC,CAAC;EAC3D;EACA,IAAI,KAAK,IAAI,IAAI,EAAE;IACfwC,KAAK,CAACC,IAAI,CAACF,IAAI,GAAG,OAAO,GAAGnD,GAAG,CAACE,KAAK,CAACa,MAAM,CAAC,IAAI,CAACO,GAAG,CAAC,CAAC;EAC3D;EACA,IAAI,MAAM,IAAI,IAAI,EAAE;IAChB8B,KAAK,CAACC,IAAI,CAACF,IAAI,GAAG,kBAAkB,CAAC;EACzC;EACA,IAAI,MAAM,IAAI,IAAI,EAAE;IAChBC,KAAK,CAACC,IAAI,CAACF,IAAI,GAAG,kBAAkB,CAAC;EACzC;EACAC,KAAK,CAACC,IAAI,CAACJ,IAAI,GAAG,GAAG,CAAC;EACtB,OAAOG,KAAK,CAACE,IAAI,CAACtD,GAAG,CAACC,EAAE,CAACsD,GAAG,CAAC;AACjC,CAAC;AAEDvD,GAAG,CAACE,KAAK,CAACsD,aAAa,CAACnD,MAAM,EAAE,YAAY;EACxC,OAAO,IAAI,CAACyC,QAAQ,CAAC,CAAC;AAC1B,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAW,MAAM,CAACC,OAAO,GAAG;EAACrD;AAAM,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}