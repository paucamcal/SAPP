{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\n\nconst {\n  Events\n} = require('./events');\nconst {\n  ColorConsole\n} = require('./utils/color');\nconst npm = {\n  utils: require('./utils'),\n  text: require('./text'),\n  formatting: require('./formatting')\n};\nfunction poolConnect(ctx, db, config) {\n  return config.promise((resolve, reject) => {\n    const p = db.$pool;\n    if (p.ending) {\n      db.$destroy();\n      const err = new Error(npm.text.poolDestroyed);\n      Events.error(ctx.options, err, {\n        dc: ctx.dc\n      });\n      reject(err);\n      return;\n    }\n    p.connect((err, client) => {\n      if (err) {\n        Events.error(ctx.options, err, {\n          cn: npm.utils.getSafeConnection(ctx.cn),\n          dc: ctx.dc\n        });\n        reject(err);\n      } else {\n        if ('$useCount' in client) {\n          // Make sure useCount drops to 1, if it ever reaches maximum integer number;\n          // We do not drop it to zero, to avoid rerun of initialization queries that\n          // usually check for useCount === 0;\n          // istanbul ignore if\n          if (client.$useCount >= Number.MAX_SAFE_INTEGER) {\n            client.$useCount = 1; // resetting; cannot auto-test this\n          } else {\n            client.$useCount = ++client.$useCount;\n          }\n        } else {\n          Object.defineProperty(client, '$useCount', {\n            value: 0,\n            configurable: false,\n            enumerable: false,\n            writable: true\n          });\n          setSchema(client, ctx);\n        }\n        setCtx(client, ctx);\n        const end = lockClientEnd(client);\n        client.on('error', onError);\n        resolve({\n          client,\n          useCount: client.$useCount,\n          release(kill) {\n            client.end = end;\n            client.release(kill || client.$connectionError);\n            Events.disconnect(ctx, client);\n            client.removeListener('error', onError);\n          }\n        });\n        Events.connect(ctx, client, client.$useCount);\n      }\n    });\n  });\n}\nfunction directConnect(ctx, config) {\n  return config.promise((resolve, reject) => {\n    const client = new config.pgp.pg.Client(ctx.cn);\n    client.connect(err => {\n      if (err) {\n        Events.error(ctx.options, err, {\n          cn: npm.utils.getSafeConnection(ctx.cn),\n          dc: ctx.dc\n        });\n        reject(err);\n      } else {\n        setSchema(client, ctx);\n        setCtx(client, ctx);\n        const end = lockClientEnd(client);\n        client.on('error', onError);\n        resolve({\n          client,\n          useCount: 0,\n          release() {\n            client.end = end;\n            const p = config.promise((res, rej) => client.end().then(res).catch(rej));\n            Events.disconnect(ctx, client);\n            client.removeListener('error', onError);\n            return p;\n          }\n        });\n        Events.connect(ctx, client, 0);\n      }\n    });\n  });\n}\n\n// this event only happens when the connection is lost physically,\n// which cannot be tested automatically; removing from coverage:\n// istanbul ignore next\nfunction onError(err) {\n  const ctx = this.$ctx;\n  const cn = npm.utils.getSafeConnection(ctx.cn);\n  Events.error(ctx.options, err, {\n    cn,\n    dc: ctx.dc\n  });\n  if (ctx.cnOptions && typeof ctx.cnOptions.onLost === 'function' && !ctx.notified) {\n    try {\n      ctx.cnOptions.onLost.call(this, err, {\n        cn,\n        dc: ctx.dc,\n        start: ctx.start,\n        client: this\n      });\n    } catch (e) {\n      ColorConsole.error(e && e.stack || e);\n    }\n    ctx.notified = true;\n  }\n}\nfunction lockClientEnd(client) {\n  const end = client.end;\n  client.end = doNotCall => {\n    // This call can happen only in the following two cases:\n    // 1. the client made the call directly, against the library's documentation (invalid code)\n    // 2. connection with the server broke, and the pool is terminating all clients forcefully.\n    ColorConsole.error(`${npm.text.clientEnd}\\n${npm.utils.getLocalStack(1, 3)}\\n`);\n    if (!doNotCall) {\n      end.call(client);\n    }\n  };\n  return end;\n}\nfunction setCtx(client, ctx) {\n  Object.defineProperty(client, '$ctx', {\n    value: ctx,\n    writable: true\n  });\n}\nfunction setSchema(client, ctx) {\n  let s = ctx.options.schema;\n  if (!s) {\n    return;\n  }\n  if (typeof s === 'function') {\n    s = s.call(ctx.dc, ctx.dc);\n  }\n  if (Array.isArray(s)) {\n    s = s.filter(a => a && typeof a === 'string');\n  }\n  if (typeof s === 'string' || Array.isArray(s) && s.length) {\n    client.query(npm.formatting.as.format('SET search_path TO $1:name', [s]), err => {\n      // istanbul ignore if;\n      if (err) {\n        // This is unlikely to ever happen, unless the connection is created faulty,\n        // and fails on the very first query, which is impossible to test automatically.\n        throw err;\n      }\n    });\n  }\n}\nmodule.exports = config => ({\n  pool: (ctx, db) => poolConnect(ctx, db, config),\n  direct: ctx => directConnect(ctx, config)\n});","map":{"version":3,"names":["Events","require","ColorConsole","npm","utils","text","formatting","poolConnect","ctx","db","config","promise","resolve","reject","p","$pool","ending","$destroy","err","Error","poolDestroyed","error","options","dc","connect","client","cn","getSafeConnection","$useCount","Number","MAX_SAFE_INTEGER","Object","defineProperty","value","configurable","enumerable","writable","setSchema","setCtx","end","lockClientEnd","on","onError","useCount","release","kill","$connectionError","disconnect","removeListener","directConnect","pgp","pg","Client","res","rej","then","catch","$ctx","cnOptions","onLost","notified","call","start","e","stack","doNotCall","clientEnd","getLocalStack","s","schema","Array","isArray","filter","a","length","query","as","format","module","exports","pool","direct"],"sources":["/Users/luna/Library/Mobile Documents/com~apple~CloudDocs/GitHub/paucamcal.github.io/AESP/node_modules/pg-promise/lib/connect.js"],"sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {Events} = require('./events');\r\nconst {ColorConsole} = require('./utils/color');\r\n\r\nconst npm = {\r\n    utils: require('./utils'),\r\n    text: require('./text'),\r\n    formatting: require('./formatting')\r\n};\r\n\r\nfunction poolConnect(ctx, db, config) {\r\n    return config.promise((resolve, reject) => {\r\n        const p = db.$pool;\r\n        if (p.ending) {\r\n            db.$destroy();\r\n            const err = new Error(npm.text.poolDestroyed);\r\n            Events.error(ctx.options, err, {\r\n                dc: ctx.dc\r\n            });\r\n            reject(err);\r\n            return;\r\n        }\r\n        p.connect((err, client) => {\r\n            if (err) {\r\n                Events.error(ctx.options, err, {\r\n                    cn: npm.utils.getSafeConnection(ctx.cn),\r\n                    dc: ctx.dc\r\n                });\r\n                reject(err);\r\n            } else {\r\n                if ('$useCount' in client) {\r\n                    // Make sure useCount drops to 1, if it ever reaches maximum integer number;\r\n                    // We do not drop it to zero, to avoid rerun of initialization queries that\r\n                    // usually check for useCount === 0;\r\n                    // istanbul ignore if\r\n                    if (client.$useCount >= Number.MAX_SAFE_INTEGER) {\r\n                        client.$useCount = 1; // resetting; cannot auto-test this\r\n                    } else {\r\n                        client.$useCount = ++client.$useCount;\r\n                    }\r\n                } else {\r\n                    Object.defineProperty(client, '$useCount', {\r\n                        value: 0,\r\n                        configurable: false,\r\n                        enumerable: false,\r\n                        writable: true\r\n                    });\r\n                    setSchema(client, ctx);\r\n                }\r\n                setCtx(client, ctx);\r\n                const end = lockClientEnd(client);\r\n                client.on('error', onError);\r\n                resolve({\r\n                    client,\r\n                    useCount: client.$useCount,\r\n                    release(kill) {\r\n                        client.end = end;\r\n                        client.release(kill || client.$connectionError);\r\n                        Events.disconnect(ctx, client);\r\n                        client.removeListener('error', onError);\r\n                    }\r\n                });\r\n                Events.connect(ctx, client, client.$useCount);\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\nfunction directConnect(ctx, config) {\r\n    return config.promise((resolve, reject) => {\r\n        const client = new config.pgp.pg.Client(ctx.cn);\r\n        client.connect(err => {\r\n            if (err) {\r\n                Events.error(ctx.options, err, {\r\n                    cn: npm.utils.getSafeConnection(ctx.cn),\r\n                    dc: ctx.dc\r\n                });\r\n                reject(err);\r\n            } else {\r\n                setSchema(client, ctx);\r\n                setCtx(client, ctx);\r\n                const end = lockClientEnd(client);\r\n                client.on('error', onError);\r\n                resolve({\r\n                    client,\r\n                    useCount: 0,\r\n                    release() {\r\n                        client.end = end;\r\n                        const p = config.promise((res, rej) => client.end().then(res).catch(rej));\r\n                        Events.disconnect(ctx, client);\r\n                        client.removeListener('error', onError);\r\n                        return p;\r\n                    }\r\n                });\r\n                Events.connect(ctx, client, 0);\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\n// this event only happens when the connection is lost physically,\r\n// which cannot be tested automatically; removing from coverage:\r\n// istanbul ignore next\r\nfunction onError(err) {\r\n    const ctx = this.$ctx;\r\n    const cn = npm.utils.getSafeConnection(ctx.cn);\r\n    Events.error(ctx.options, err, {cn, dc: ctx.dc});\r\n    if (ctx.cnOptions && typeof ctx.cnOptions.onLost === 'function' && !ctx.notified) {\r\n        try {\r\n            ctx.cnOptions.onLost.call(this, err, {\r\n                cn,\r\n                dc: ctx.dc,\r\n                start: ctx.start,\r\n                client: this\r\n            });\r\n        } catch (e) {\r\n            ColorConsole.error(e && e.stack || e);\r\n        }\r\n        ctx.notified = true;\r\n    }\r\n}\r\n\r\nfunction lockClientEnd(client) {\r\n    const end = client.end;\r\n    client.end = doNotCall => {\r\n        // This call can happen only in the following two cases:\r\n        // 1. the client made the call directly, against the library's documentation (invalid code)\r\n        // 2. connection with the server broke, and the pool is terminating all clients forcefully.\r\n        ColorConsole.error(`${npm.text.clientEnd}\\n${npm.utils.getLocalStack(1, 3)}\\n`);\r\n        if (!doNotCall) {\r\n            end.call(client);\r\n        }\r\n    };\r\n    return end;\r\n}\r\n\r\nfunction setCtx(client, ctx) {\r\n    Object.defineProperty(client, '$ctx', {\r\n        value: ctx,\r\n        writable: true\r\n    });\r\n}\r\n\r\nfunction setSchema(client, ctx) {\r\n    let s = ctx.options.schema;\r\n    if (!s) {\r\n        return;\r\n    }\r\n    if (typeof s === 'function') {\r\n        s = s.call(ctx.dc, ctx.dc);\r\n    }\r\n    if (Array.isArray(s)) {\r\n        s = s.filter(a => a && typeof a === 'string');\r\n    }\r\n    if (typeof s === 'string' || (Array.isArray(s) && s.length)) {\r\n        client.query(npm.formatting.as.format('SET search_path TO $1:name', [s]), err => {\r\n            // istanbul ignore if;\r\n            if (err) {\r\n                // This is unlikely to ever happen, unless the connection is created faulty,\r\n                // and fails on the very first query, which is impossible to test automatically.\r\n                throw err;\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nmodule.exports = config => ({\r\n    pool: (ctx, db) => poolConnect(ctx, db, config),\r\n    direct: ctx => directConnect(ctx, config)\r\n});\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}