{"ast":null,"code":"const {\n  PageError\n} = require('../errors/page');\n\n/**\r\n * @method page\r\n * @description\r\n * Resolves a dynamic sequence of pages/arrays with [mixed values]{@tutorial mixed}.\r\n *\r\n * The method acquires pages (arrays of [mixed values]{@tutorial mixed}) from the `source` function, one by one,\r\n * and resolves each page as a {@link batch}, till no more pages left or an error/reject occurs.\r\n *\r\n * @param {Function|generator} source\r\n * Expected to return a [mixed value]{@tutorial mixed} that resolves with the next page of data (array of [mixed values]{@tutorial mixed}).\r\n * Returning or resolving with `undefined` ends the sequence, and the method resolves.\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * Parameters:\r\n *  - `index` = index of the page being requested\r\n *  - `data` = previously returned page, resolved as a {@link batch} (`undefined` when `index=0`)\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * If the function throws an error or returns a rejected promise, the method rejects with\r\n * {@link errors.PageError PageError}, which will have property `source` set.\r\n *\r\n * And if the function returns or resolves with anything other than an array or `undefined`,\r\n * the method rejects with the same {@link errors.PageError PageError}, but with `error` set to\r\n * `Unexpected data returned from the source.`\r\n *\r\n * Passing in anything other than a function will reject with {@link external:TypeError TypeError} = `Parameter 'source' must be a function.`\r\n *\r\n * @param {Object} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {Function|generator} [options.dest]\r\n * Optional destination function (or generator), to receive a resolved {@link batch} of data\r\n * for each page, process it and respond as required.\r\n *\r\n * Parameters:\r\n *  - `index` = page index in the sequence\r\n *  - `data` = page data resolved as a {@link batch}\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * It can optionally return a promise object, if notifications are handled asynchronously.\r\n * And if a promise is returned, the method will not request another page from the `source`\r\n * function until the promise has been resolved.\r\n *\r\n * If the function throws an error or returns a rejected promise, the sequence terminates,\r\n * and the method rejects with {@link errors.PageError PageError}, which will have property `dest` set.\r\n *\r\n * @param {Number} [options.limit=0]\r\n * Limits the maximum number of pages to be requested from the `source`. If the value is greater\r\n * than 0, the method will successfully resolve once the specified limit has been reached.\r\n *\r\n * When `limit` isn't specified (default), the sequence is unlimited, and it will continue\r\n * till one of the following occurs:\r\n *  - `source` returns or resolves with `undefined` or an invalid value (non-array)\r\n *  - either `source` or `dest` functions throw an error or return a rejected promise\r\n *\r\n * @returns {external:Promise}\r\n *\r\n * When successful, the method resolves with object `{pages, total, duration}`:\r\n *  - `pages` = number of pages resolved\r\n *  - `total` = the sum of all page sizes (total number of values resolved)\r\n *  - `duration` = number of milliseconds consumed by the method\r\n *\r\n * When the method fails, it rejects with {@link errors.PageError PageError}.\r\n *\r\n */\nfunction page(source, options, config) {\n  const $p = config.promise,\n    spex = config.spex,\n    utils = config.utils;\n  if (typeof source !== 'function') {\n    return $p.reject(new TypeError('Parameter \\'source\\' must be a function.'));\n  }\n  options = options || {};\n  source = utils.wrap(source);\n  const limit = options.limit > 0 ? parseInt(options.limit) : 0,\n    dest = utils.wrap(options.dest),\n    self = this,\n    start = Date.now();\n  let request,\n    srcTime,\n    destTime,\n    total = 0;\n  return $p((resolve, reject) => {\n    function loop(idx) {\n      const srcNow = Date.now(),\n        srcDelay = idx ? srcNow - srcTime : undefined;\n      srcTime = srcNow;\n      utils.resolve.call(self, source, [idx, request, srcDelay], value => {\n        if (value === undefined) {\n          success();\n        } else {\n          if (value instanceof Array) {\n            spex.batch(value).then(data => {\n              request = data;\n              total += data.length;\n              if (dest) {\n                const destNow = Date.now(),\n                  destDelay = idx ? destNow - destTime : undefined;\n                let destResult;\n                destTime = destNow;\n                try {\n                  destResult = dest.call(self, idx, data, destDelay);\n                } catch (err) {\n                  fail({\n                    error: err,\n                    dest: data\n                  }, 4, dest.name);\n                  return;\n                }\n                if (utils.isPromise(destResult)) {\n                  destResult.then(next).catch(error => {\n                    fail({\n                      error: error,\n                      dest: data\n                    }, 3, dest.name);\n                  });\n                } else {\n                  next();\n                }\n              } else {\n                next();\n              }\n              return null; // this dummy return is just to prevent Bluebird warnings;\n            }).catch(error => {\n              fail({\n                error: error\n              }, 0);\n            });\n          } else {\n            fail({\n              error: new Error('Unexpected data returned from the source.'),\n              source: request\n            }, 5, source.name);\n          }\n        }\n      }, (reason, isRej) => {\n        fail({\n          error: reason,\n          source: request\n        }, isRej ? 1 : 2, source.name);\n      });\n      function next() {\n        if (limit === ++idx) {\n          success();\n        } else {\n          loop(idx);\n        }\n        return null; // this dummy return is just to prevent Bluebird warnings;\n      }\n\n      function success() {\n        resolve({\n          pages: idx,\n          total: total,\n          duration: Date.now() - start\n        });\n      }\n      function fail(reason, code, cbName) {\n        reason.index = idx;\n        reject(new PageError(reason, code, cbName, Date.now() - start));\n      }\n    }\n    loop(0);\n  });\n}\nmodule.exports = function (config) {\n  return function (source, options) {\n    return page.call(this, source, options, config);\n  };\n};","map":{"version":3,"names":["PageError","require","page","source","options","config","$p","promise","spex","utils","reject","TypeError","wrap","limit","parseInt","dest","self","start","Date","now","request","srcTime","destTime","total","resolve","loop","idx","srcNow","srcDelay","undefined","call","value","success","Array","batch","then","data","length","destNow","destDelay","destResult","err","fail","error","name","isPromise","next","catch","Error","reason","isRej","pages","duration","code","cbName","index","module","exports"],"sources":["/Users/luna/Library/Mobile Documents/com~apple~CloudDocs/GitHub/paucamcal.github.io/AESP/node_modules/spex/lib/ext/page.js"],"sourcesContent":["const {PageError} = require('../errors/page');\r\n\r\n/**\r\n * @method page\r\n * @description\r\n * Resolves a dynamic sequence of pages/arrays with [mixed values]{@tutorial mixed}.\r\n *\r\n * The method acquires pages (arrays of [mixed values]{@tutorial mixed}) from the `source` function, one by one,\r\n * and resolves each page as a {@link batch}, till no more pages left or an error/reject occurs.\r\n *\r\n * @param {Function|generator} source\r\n * Expected to return a [mixed value]{@tutorial mixed} that resolves with the next page of data (array of [mixed values]{@tutorial mixed}).\r\n * Returning or resolving with `undefined` ends the sequence, and the method resolves.\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * Parameters:\r\n *  - `index` = index of the page being requested\r\n *  - `data` = previously returned page, resolved as a {@link batch} (`undefined` when `index=0`)\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * If the function throws an error or returns a rejected promise, the method rejects with\r\n * {@link errors.PageError PageError}, which will have property `source` set.\r\n *\r\n * And if the function returns or resolves with anything other than an array or `undefined`,\r\n * the method rejects with the same {@link errors.PageError PageError}, but with `error` set to\r\n * `Unexpected data returned from the source.`\r\n *\r\n * Passing in anything other than a function will reject with {@link external:TypeError TypeError} = `Parameter 'source' must be a function.`\r\n *\r\n * @param {Object} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {Function|generator} [options.dest]\r\n * Optional destination function (or generator), to receive a resolved {@link batch} of data\r\n * for each page, process it and respond as required.\r\n *\r\n * Parameters:\r\n *  - `index` = page index in the sequence\r\n *  - `data` = page data resolved as a {@link batch}\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * It can optionally return a promise object, if notifications are handled asynchronously.\r\n * And if a promise is returned, the method will not request another page from the `source`\r\n * function until the promise has been resolved.\r\n *\r\n * If the function throws an error or returns a rejected promise, the sequence terminates,\r\n * and the method rejects with {@link errors.PageError PageError}, which will have property `dest` set.\r\n *\r\n * @param {Number} [options.limit=0]\r\n * Limits the maximum number of pages to be requested from the `source`. If the value is greater\r\n * than 0, the method will successfully resolve once the specified limit has been reached.\r\n *\r\n * When `limit` isn't specified (default), the sequence is unlimited, and it will continue\r\n * till one of the following occurs:\r\n *  - `source` returns or resolves with `undefined` or an invalid value (non-array)\r\n *  - either `source` or `dest` functions throw an error or return a rejected promise\r\n *\r\n * @returns {external:Promise}\r\n *\r\n * When successful, the method resolves with object `{pages, total, duration}`:\r\n *  - `pages` = number of pages resolved\r\n *  - `total` = the sum of all page sizes (total number of values resolved)\r\n *  - `duration` = number of milliseconds consumed by the method\r\n *\r\n * When the method fails, it rejects with {@link errors.PageError PageError}.\r\n *\r\n */\r\nfunction page(source, options, config) {\r\n\r\n    const $p = config.promise, spex = config.spex, utils = config.utils;\r\n\r\n    if (typeof source !== 'function') {\r\n        return $p.reject(new TypeError('Parameter \\'source\\' must be a function.'));\r\n    }\r\n\r\n    options = options || {};\r\n    source = utils.wrap(source);\r\n\r\n    const limit = (options.limit > 0) ? parseInt(options.limit) : 0,\r\n        dest = utils.wrap(options.dest), self = this, start = Date.now();\r\n    let request, srcTime, destTime, total = 0;\r\n\r\n    return $p((resolve, reject) => {\r\n\r\n        function loop(idx) {\r\n            const srcNow = Date.now(),\r\n                srcDelay = idx ? (srcNow - srcTime) : undefined;\r\n            srcTime = srcNow;\r\n            utils.resolve.call(self, source, [idx, request, srcDelay], value => {\r\n                if (value === undefined) {\r\n                    success();\r\n                } else {\r\n                    if (value instanceof Array) {\r\n                        spex.batch(value)\r\n                            .then(data => {\r\n                                request = data;\r\n                                total += data.length;\r\n                                if (dest) {\r\n                                    const destNow = Date.now(),\r\n                                        destDelay = idx ? (destNow - destTime) : undefined;\r\n                                    let destResult;\r\n                                    destTime = destNow;\r\n                                    try {\r\n                                        destResult = dest.call(self, idx, data, destDelay);\r\n                                    } catch (err) {\r\n                                        fail({\r\n                                            error: err,\r\n                                            dest: data\r\n                                        }, 4, dest.name);\r\n                                        return;\r\n                                    }\r\n                                    if (utils.isPromise(destResult)) {\r\n                                        destResult\r\n                                            .then(next)\r\n                                            .catch(error => {\r\n                                                fail({\r\n                                                    error: error,\r\n                                                    dest: data\r\n                                                }, 3, dest.name);\r\n                                            });\r\n                                    } else {\r\n                                        next();\r\n                                    }\r\n                                } else {\r\n                                    next();\r\n                                }\r\n                                return null; // this dummy return is just to prevent Bluebird warnings;\r\n                            })\r\n                            .catch(error => {\r\n                                fail({\r\n                                    error: error\r\n                                }, 0);\r\n                            });\r\n                    } else {\r\n                        fail({\r\n                            error: new Error('Unexpected data returned from the source.'),\r\n                            source: request\r\n                        }, 5, source.name);\r\n                    }\r\n                }\r\n            }, (reason, isRej) => {\r\n                fail({\r\n                    error: reason,\r\n                    source: request\r\n                }, isRej ? 1 : 2, source.name);\r\n            });\r\n\r\n            function next() {\r\n                if (limit === ++idx) {\r\n                    success();\r\n                } else {\r\n                    loop(idx);\r\n                }\r\n                return null; // this dummy return is just to prevent Bluebird warnings;\r\n            }\r\n\r\n            function success() {\r\n                resolve({\r\n                    pages: idx,\r\n                    total: total,\r\n                    duration: Date.now() - start\r\n                });\r\n            }\r\n\r\n            function fail(reason, code, cbName) {\r\n                reason.index = idx;\r\n                reject(new PageError(reason, code, cbName, Date.now() - start));\r\n            }\r\n        }\r\n\r\n        loop(0);\r\n    });\r\n}\r\n\r\nmodule.exports = function (config) {\r\n    return function (source, options) {\r\n        return page.call(this, source, options, config);\r\n    };\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}