{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\n\nconst {\n  assert\n} = require('../assert');\nconst npm = {\n  utils: require('../utils'),\n  format: require('../formatting').as // formatting namespace\n};\n\n/**\r\n * @class helpers.TableName\r\n * @description\r\n * Represents a full table name that can be injected into queries directly.\r\n *\r\n * This is a read-only type that can be used wherever parameter `table` is supported.\r\n *\r\n * It supports $[Custom Type Formatting], which means you can use the type directly as a formatting\r\n * parameter, without specifying any escaping.\r\n *\r\n * Filter `:alias` is an alternative approach to splitting an SQL name into multiple ones.\r\n *\r\n * @param {string|object} table\r\n * Table name details, depending on the type:\r\n *\r\n * - table name, if `table` is a string\r\n * - object `{table, [schema]}`\r\n *\r\n * @property {string} name\r\n * Formatted/escaped full table name, combining `schema` + `table`.\r\n *\r\n * @property {string} table\r\n * Table name.\r\n *\r\n * @property {string} schema\r\n * Database schema name.\r\n *\r\n * It is `undefined` when no valid schema was specified.\r\n *\r\n * @returns {helpers.TableName}\r\n *\r\n * @see\r\n * {@link helpers.TableName#toPostgres toPostgres}\r\n *\r\n * @example\r\n *\r\n * const table = new pgp.helpers.TableName({table: 'my-table', schema: 'my-schema'});\r\n * console.log(table);\r\n * //=> \"my-schema\".\"my-table\"\r\n *\r\n * // Formatting the type directly:\r\n * pgp.as.format('SELECT * FROM $1', table);\r\n * //=> SELECT * FROM \"my-schema\".\"my-table\"\r\n *\r\n */\nclass TableName {\n  constructor(table) {\n    if (typeof table === 'string') {\n      this.table = table;\n    } else {\n      const config = assert(table, ['table', 'schema']);\n      this.table = config.table;\n      if (npm.utils.isText(config.schema)) {\n        this.schema = config.schema;\n      }\n    }\n    if (!npm.utils.isText(this.table)) {\n      throw new TypeError('Table name must be a non-empty text string.');\n    }\n    this.name = npm.format.name(this.table);\n    if (this.schema) {\n      this.name = npm.format.name(this.schema) + '.' + this.name;\n    }\n    Object.freeze(this);\n  }\n}\n\n/**\r\n * @method helpers.TableName#toPostgres\r\n * @description\r\n * $[Custom Type Formatting], based on $[Symbolic CTF], i.e. the actual method is available only via {@link external:Symbol Symbol}:\r\n *\r\n * ```js\r\n * const ctf = pgp.as.ctf; // Custom Type Formatting symbols namespace\r\n * const fullName = tn[ctf.toPostgres]; // tn = an object of type TableName\r\n * ```\r\n *\r\n * This is a raw formatting type (`rawType = true`), i.e. when used as a query-formatting parameter, type `TableName`\r\n * injects full table name as raw text.\r\n *\r\n * @param {helpers.TableName} [self]\r\n * Optional self-reference, for ES6 arrow functions.\r\n *\r\n * @returns {string}\r\n * Escaped full table name that includes optional schema name, if specified.\r\n */\nTableName.prototype[npm.format.ctf.toPostgres] = function (self) {\n  self = this instanceof TableName && this || self;\n  return self.name;\n};\nTableName.prototype[npm.format.ctf.rawType] = true; // use as pre-formatted\n\n/**\r\n * @method helpers.TableName#toString\r\n * @description\r\n * Creates a well-formatted string that represents the object.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @returns {string}\r\n */\nTableName.prototype.toString = function () {\n  return this.name;\n};\nnpm.utils.addInspection(TableName, function () {\n  return this.toString();\n});\nmodule.exports = {\n  TableName\n};","map":{"version":3,"names":["assert","require","npm","utils","format","as","TableName","constructor","table","config","isText","schema","TypeError","name","Object","freeze","prototype","ctf","toPostgres","self","rawType","toString","addInspection","module","exports"],"sources":["/Users/luna/Library/Mobile Documents/com~apple~CloudDocs/GitHub/paucamcal.github.io/AESP/node_modules/pg-promise/lib/helpers/table-name.js"],"sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {assert} = require('../assert');\r\n\r\nconst npm = {\r\n    utils: require('../utils'),\r\n    format: require('../formatting').as // formatting namespace\r\n};\r\n\r\n/**\r\n * @class helpers.TableName\r\n * @description\r\n * Represents a full table name that can be injected into queries directly.\r\n *\r\n * This is a read-only type that can be used wherever parameter `table` is supported.\r\n *\r\n * It supports $[Custom Type Formatting], which means you can use the type directly as a formatting\r\n * parameter, without specifying any escaping.\r\n *\r\n * Filter `:alias` is an alternative approach to splitting an SQL name into multiple ones.\r\n *\r\n * @param {string|object} table\r\n * Table name details, depending on the type:\r\n *\r\n * - table name, if `table` is a string\r\n * - object `{table, [schema]}`\r\n *\r\n * @property {string} name\r\n * Formatted/escaped full table name, combining `schema` + `table`.\r\n *\r\n * @property {string} table\r\n * Table name.\r\n *\r\n * @property {string} schema\r\n * Database schema name.\r\n *\r\n * It is `undefined` when no valid schema was specified.\r\n *\r\n * @returns {helpers.TableName}\r\n *\r\n * @see\r\n * {@link helpers.TableName#toPostgres toPostgres}\r\n *\r\n * @example\r\n *\r\n * const table = new pgp.helpers.TableName({table: 'my-table', schema: 'my-schema'});\r\n * console.log(table);\r\n * //=> \"my-schema\".\"my-table\"\r\n *\r\n * // Formatting the type directly:\r\n * pgp.as.format('SELECT * FROM $1', table);\r\n * //=> SELECT * FROM \"my-schema\".\"my-table\"\r\n *\r\n */\r\nclass TableName {\r\n\r\n    constructor(table) {\r\n        if (typeof table === 'string') {\r\n            this.table = table;\r\n        } else {\r\n            const config = assert(table, ['table', 'schema']);\r\n            this.table = config.table;\r\n            if (npm.utils.isText(config.schema)) {\r\n                this.schema = config.schema;\r\n            }\r\n        }\r\n        if (!npm.utils.isText(this.table)) {\r\n            throw new TypeError('Table name must be a non-empty text string.');\r\n        }\r\n        this.name = npm.format.name(this.table);\r\n        if (this.schema) {\r\n            this.name = npm.format.name(this.schema) + '.' + this.name;\r\n        }\r\n        Object.freeze(this);\r\n    }\r\n}\r\n\r\n/**\r\n * @method helpers.TableName#toPostgres\r\n * @description\r\n * $[Custom Type Formatting], based on $[Symbolic CTF], i.e. the actual method is available only via {@link external:Symbol Symbol}:\r\n *\r\n * ```js\r\n * const ctf = pgp.as.ctf; // Custom Type Formatting symbols namespace\r\n * const fullName = tn[ctf.toPostgres]; // tn = an object of type TableName\r\n * ```\r\n *\r\n * This is a raw formatting type (`rawType = true`), i.e. when used as a query-formatting parameter, type `TableName`\r\n * injects full table name as raw text.\r\n *\r\n * @param {helpers.TableName} [self]\r\n * Optional self-reference, for ES6 arrow functions.\r\n *\r\n * @returns {string}\r\n * Escaped full table name that includes optional schema name, if specified.\r\n */\r\nTableName.prototype[npm.format.ctf.toPostgres] = function (self) {\r\n    self = this instanceof TableName && this || self;\r\n    return self.name;\r\n};\r\n\r\nTableName.prototype[npm.format.ctf.rawType] = true; // use as pre-formatted\r\n\r\n/**\r\n * @method helpers.TableName#toString\r\n * @description\r\n * Creates a well-formatted string that represents the object.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @returns {string}\r\n */\r\nTableName.prototype.toString = function () {\r\n    return this.name;\r\n};\r\n\r\nnpm.utils.addInspection(TableName, function () {\r\n    return this.toString();\r\n});\r\n\r\nmodule.exports = {TableName};\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM;EAACA;AAAM,CAAC,GAAGC,OAAO,CAAC,WAAW,CAAC;AAErC,MAAMC,GAAG,GAAG;EACRC,KAAK,EAAEF,OAAO,CAAC,UAAU,CAAC;EAC1BG,MAAM,EAAEH,OAAO,CAAC,eAAe,CAAC,CAACI,EAAE,CAAC;AACxC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,SAAS,CAAC;EAEZC,WAAWA,CAACC,KAAK,EAAE;IACf,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC3B,IAAI,CAACA,KAAK,GAAGA,KAAK;IACtB,CAAC,MAAM;MACH,MAAMC,MAAM,GAAGT,MAAM,CAACQ,KAAK,EAAE,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;MACjD,IAAI,CAACA,KAAK,GAAGC,MAAM,CAACD,KAAK;MACzB,IAAIN,GAAG,CAACC,KAAK,CAACO,MAAM,CAACD,MAAM,CAACE,MAAM,CAAC,EAAE;QACjC,IAAI,CAACA,MAAM,GAAGF,MAAM,CAACE,MAAM;MAC/B;IACJ;IACA,IAAI,CAACT,GAAG,CAACC,KAAK,CAACO,MAAM,CAAC,IAAI,CAACF,KAAK,CAAC,EAAE;MAC/B,MAAM,IAAII,SAAS,CAAC,6CAA6C,CAAC;IACtE;IACA,IAAI,CAACC,IAAI,GAAGX,GAAG,CAACE,MAAM,CAACS,IAAI,CAAC,IAAI,CAACL,KAAK,CAAC;IACvC,IAAI,IAAI,CAACG,MAAM,EAAE;MACb,IAAI,CAACE,IAAI,GAAGX,GAAG,CAACE,MAAM,CAACS,IAAI,CAAC,IAAI,CAACF,MAAM,CAAC,GAAG,GAAG,GAAG,IAAI,CAACE,IAAI;IAC9D;IACAC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;EACvB;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAT,SAAS,CAACU,SAAS,CAACd,GAAG,CAACE,MAAM,CAACa,GAAG,CAACC,UAAU,CAAC,GAAG,UAAUC,IAAI,EAAE;EAC7DA,IAAI,GAAG,IAAI,YAAYb,SAAS,IAAI,IAAI,IAAIa,IAAI;EAChD,OAAOA,IAAI,CAACN,IAAI;AACpB,CAAC;AAEDP,SAAS,CAACU,SAAS,CAACd,GAAG,CAACE,MAAM,CAACa,GAAG,CAACG,OAAO,CAAC,GAAG,IAAI,CAAC,CAAC;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAd,SAAS,CAACU,SAAS,CAACK,QAAQ,GAAG,YAAY;EACvC,OAAO,IAAI,CAACR,IAAI;AACpB,CAAC;AAEDX,GAAG,CAACC,KAAK,CAACmB,aAAa,CAAChB,SAAS,EAAE,YAAY;EAC3C,OAAO,IAAI,CAACe,QAAQ,CAAC,CAAC;AAC1B,CAAC,CAAC;AAEFE,MAAM,CAACC,OAAO,GAAG;EAAClB;AAAS,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}