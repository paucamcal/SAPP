{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\n\nconst {\n  assert\n} = require('./assert');\nconst npm = {\n  pgUtils: require('pg/lib/utils'),\n  patterns: require('./patterns'),\n  utils: require('./utils')\n};\n\n// Format Modification Flags;\nconst fmFlags = {\n  raw: 1,\n  // Raw-Text variable\n  alias: 2,\n  // SQL Alias\n  name: 4,\n  // SQL Name/Identifier\n  json: 8,\n  // JSON modifier\n  csv: 16,\n  // CSV modifier\n  value: 32 // escaped, but without ''\n};\n\n// Format Modification Map;\nconst fmMap = {\n  '^': fmFlags.raw,\n  ':raw': fmFlags.raw,\n  ':alias': fmFlags.alias,\n  '~': fmFlags.name,\n  ':name': fmFlags.name,\n  ':json': fmFlags.json,\n  ':csv': fmFlags.csv,\n  ':list': fmFlags.csv,\n  ':value': fmFlags.value,\n  '#': fmFlags.value\n};\n\n// Global symbols for Custom Type Formatting:\nconst ctfSymbols = {\n  toPostgres: Symbol.for('ctf.toPostgres'),\n  rawType: Symbol.for('ctf.rawType')\n};\nconst maxVariable = 100000; // maximum supported variable is '$100000'\n\n////////////////////////////////////////////////////\n// Converts a single value into its Postgres format.\nfunction formatValue({\n  value,\n  fm,\n  cc,\n  options\n}) {\n  if (typeof value === 'function') {\n    return formatValue({\n      value: resolveFunc(value, cc),\n      fm,\n      cc\n    });\n  }\n  const ctf = getCTF(value); // Custom Type Formatting\n  if (ctf) {\n    fm |= ctf.rawType ? fmFlags.raw : 0;\n    return formatValue({\n      value: resolveFunc(ctf.toPostgres, value),\n      fm,\n      cc\n    });\n  }\n  const isRaw = !!(fm & fmFlags.raw);\n  fm &= ~fmFlags.raw;\n  switch (fm) {\n    case fmFlags.alias:\n      return $as.alias(value);\n    case fmFlags.name:\n      return $as.name(value);\n    case fmFlags.json:\n      return $as.json(value, isRaw);\n    case fmFlags.csv:\n      return $to.csv(value, options);\n    case fmFlags.value:\n      return $as.value(value);\n    default:\n      break;\n  }\n  if (isNull(value)) {\n    throwIfRaw(isRaw);\n    return 'null';\n  }\n  switch (typeof value) {\n    case 'string':\n      return $to.text(value, isRaw);\n    case 'boolean':\n      return $to.bool(value);\n    case 'number':\n    case 'bigint':\n      return $to.number(value);\n    case 'symbol':\n      throw new TypeError(`Type Symbol has no meaning for PostgreSQL: ${value.toString()}`);\n    default:\n      if (value instanceof Date) {\n        return $to.date(value, isRaw);\n      }\n      if (Array.isArray(value)) {\n        return $to.array(value, options);\n      }\n      if (Buffer.isBuffer(value)) {\n        return $to.buffer(value, isRaw);\n      }\n      return $to.json(value, isRaw);\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Converts array of values into PostgreSQL Array Constructor: array[...], as per PostgreSQL documentation:\n// http://www.postgresql.org/docs/9.6/static/arrays.html\n//\n// Arrays of any depth/dimension are supported.\n//\n// Top-level empty arrays are formatted as literal '{}' to avoid the necessity of explicit type casting,\n// as the server cannot automatically infer the type of empty non-literal array.\nfunction formatArray(array, options) {\n  const loop = a => '[' + a.map(value => Array.isArray(value) ? loop(value) : formatValue({\n    value,\n    options\n  })).join() + ']';\n  const prefix = options && options.capSQL ? 'ARRAY' : 'array';\n  return array.length ? prefix + loop(array) : '\\'{}\\'';\n}\n\n///////////////////////////////////////////////////////////////////\n// Formats array/object/value as a list of comma-separated values.\nfunction formatCSV(values, options) {\n  if (Array.isArray(values)) {\n    return values.map(value => formatValue({\n      value,\n      options\n    })).join();\n  }\n  if (typeof values === 'object' && values !== null) {\n    return Object.keys(values).map(v => formatValue({\n      value: values[v],\n      options\n    })).join();\n  }\n  return values === undefined ? '' : formatValue({\n    value: values,\n    options\n  });\n}\n\n///////////////////////////////\n// Query formatting helpers;\nconst formatAs = {\n  object({\n    query,\n    obj,\n    raw,\n    options\n  }) {\n    options = options && typeof options === 'object' ? options : {};\n    return query.replace(npm.patterns.namedParameters, name => {\n      const v = formatAs.stripName(name.replace(/^\\$[{(<[/]|[\\s})>\\]/]/g, ''), raw),\n        c = npm.utils.getIfHas(obj, v.name);\n      if (!c.valid) {\n        throw new Error(`Invalid property name '${v.name}'.`);\n      }\n      if (c.has) {\n        return formatValue({\n          value: c.value,\n          fm: v.fm,\n          cc: c.target,\n          options\n        });\n      }\n      if (v.name === 'this') {\n        return formatValue({\n          value: obj,\n          fm: v.fm,\n          options\n        });\n      }\n      if ('def' in options) {\n        const d = options.def,\n          value = typeof d === 'function' ? d.call(obj, v.name, obj) : d;\n        return formatValue({\n          value,\n          fm: v.fm,\n          cc: obj,\n          options\n        });\n      }\n      if (options.partial) {\n        return name;\n      }\n      // property must exist as the object's own or inherited;\n      throw new Error(`Property '${v.name}' doesn't exist.`);\n    });\n  },\n  array({\n    query,\n    array,\n    raw,\n    options\n  }) {\n    options = options && typeof options === 'object' ? options : {};\n    return query.replace(npm.patterns.multipleValues, name => {\n      const v = formatAs.stripName(name.substr(1), raw);\n      const idx = v.name - 1;\n      if (idx >= maxVariable) {\n        throw new RangeError(`Variable $${v.name} exceeds supported maximum of $${maxVariable}`);\n      }\n      if (idx < array.length) {\n        return formatValue({\n          value: array[idx],\n          fm: v.fm,\n          options\n        });\n      }\n      if ('def' in options) {\n        const d = options.def,\n          value = typeof d === 'function' ? d.call(array, idx, array) : d;\n        return formatValue({\n          value,\n          fm: v.fm,\n          options\n        });\n      }\n      if (options.partial) {\n        return name;\n      }\n      throw new RangeError(`Variable $${v.name} out of range. Parameters array length: ${array.length}`);\n    });\n  },\n  value({\n    query,\n    value,\n    raw,\n    options\n  }) {\n    return query.replace(npm.patterns.singleValue, name => {\n      const v = formatAs.stripName(name, raw);\n      return formatValue({\n        value,\n        fm: v.fm,\n        options\n      });\n    });\n  },\n  stripName(name, raw) {\n    const mod = name.match(npm.patterns.hasValidModifier);\n    if (mod) {\n      return {\n        name: name.substr(0, mod.index),\n        fm: fmMap[mod[0]] | (raw ? fmFlags.raw : 0)\n      };\n    }\n    return {\n      name,\n      fm: raw ? fmFlags.raw : null\n    };\n  }\n};\n\n////////////////////////////////////////////\n// Simpler check for null/undefined;\nfunction isNull(value) {\n  return value === undefined || value === null;\n}\n\n//////////////////////////////////////////////////////////////////\n// Checks if the value supports Custom Type Formatting,\n// to return {toPostgres, rawType}, if it does, or null otherwise.\nfunction getCTF(value) {\n  if (!isNull(value)) {\n    let toPostgres = value[ctfSymbols.toPostgres],\n      rawType = !!value[ctfSymbols.rawType];\n    if (typeof toPostgres !== 'function') {\n      toPostgres = value.toPostgres;\n      rawType = !!value.rawType;\n    }\n    if (typeof toPostgres === 'function') {\n      if (toPostgres.constructor.name !== 'Function') {\n        throw new Error('CTF does not support asynchronous toPostgres functions.');\n      }\n      return {\n        toPostgres,\n        rawType\n      };\n    }\n  }\n  return null;\n}\n\n/////////////////////////////////////////\n// Wraps a text string in single quotes;\nfunction wrapText(text) {\n  return `'${text}'`;\n}\n\n////////////////////////////////////////////////\n// Replaces each single-quote symbol ' with two,\n// for compliance with PostgreSQL strings.\nfunction safeText(text) {\n  return text.replace(/'/g, '\\'\\'');\n}\n\n/////////////////////////////////////////////\n// Throws an exception, if flag 'raw' is set.\nfunction throwIfRaw(raw) {\n  if (raw) {\n    throw new TypeError('Values null/undefined cannot be used as raw text.');\n  }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Recursively resolves parameter-function, with an optional Calling Context.\nfunction resolveFunc(value, cc) {\n  while (typeof value === 'function') {\n    if (value.constructor.name !== 'Function') {\n      // Constructor name for asynchronous functions have different names:\n      // - 'GeneratorFunction' for ES6 generators\n      // - 'AsyncFunction' for ES7 async functions\n      throw new Error('Cannot use asynchronous functions with query formatting.');\n    }\n    value = value.call(cc, cc);\n  }\n  return value;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// It implements two types of formatting, depending on the 'values' passed:\n//\n// 1. format '$1, $2, etc', when 'values' is of type string, boolean, number, date,\n//    function or null (or an array of the same types, plus undefined values);\n// 2. format $*propName*, when 'values' is an object (not null and not Date),\n//    and where * is any of the supported open-close pairs: {}, (), [], <>, //\n//\nfunction formatQuery(query, values, raw, options) {\n  if (typeof query !== 'string') {\n    throw new TypeError('Parameter \\'query\\' must be a text string.');\n  }\n  const ctf = getCTF(values);\n  if (ctf) {\n    // Custom Type Formatting\n    return formatQuery(query, resolveFunc(ctf.toPostgres, values), raw || ctf.rawType, options);\n  }\n  if (typeof values === 'object' && values !== null) {\n    if (Array.isArray(values)) {\n      // $1, $2,... formatting to be applied;\n      return formatAs.array({\n        query,\n        array: values,\n        raw,\n        options\n      });\n    }\n    if (!(values instanceof Date || values instanceof Buffer)) {\n      // $*propName* formatting to be applied;\n      return formatAs.object({\n        query,\n        obj: values,\n        raw,\n        options\n      });\n    }\n  }\n  // $1 formatting to be applied, if values != undefined;\n  return values === undefined ? query : formatAs.value({\n    query,\n    value: values,\n    raw,\n    options\n  });\n}\n\n//////////////////////////////////////////////////////\n// Formats a function or stored procedure call query;\nfunction formatEntity(entity, values, {\n  capSQL,\n  type\n}) {\n  let prefix = type === 'func' ? 'select * from' : 'call';\n  if (capSQL) {\n    prefix = prefix.toUpperCase();\n  }\n  return `${prefix} ${$as.alias(entity)}(${formatCSV(values, {\n    capSQL\n  })})`;\n}\nfunction formatSqlName(name) {\n  return `\"${name.replace(/\"/g, '\"\"')}\"`;\n}\n\n/**\r\n * @namespace formatting\r\n * @description\r\n * Namespace for all query-formatting functions, available from `pgp.as` before and after initializing the library.\r\n *\r\n * @property {formatting.ctf} ctf\r\n * Namespace for symbols used by $[Custom Type Formatting].\r\n *\r\n * @property {function} alias\r\n * {@link formatting.alias alias} - formats an SQL alias.\r\n *\r\n * @property {function} name\r\n * {@link formatting.name name} - formats an SQL Name/Identifier.\r\n *\r\n * @property {function} text\r\n * {@link formatting.text text} - formats a text string.\r\n *\r\n * @property {function} number\r\n * {@link formatting.number number} - formats a number.\r\n *\r\n * @property {function} buffer\r\n * {@link formatting.buffer buffer} - formats a `Buffer` object.\r\n *\r\n * @property {function} value\r\n * {@link formatting.value value} - formats text as an open value.\r\n *\r\n * @property {function} json\r\n * {@link formatting.json json} - formats any value as JSON.\r\n *\r\n * @property {function} array\r\n * {@link formatting.array array} - formats an array of any depth.\r\n *\r\n * @property {function} csv\r\n * {@link formatting.csv csv} - formats an array as a list of comma-separated values.\r\n *\r\n * @property {function} func\r\n * {@link formatting.func func} - formats the value returned from a function.\r\n *\r\n * @property {function} format\r\n * {@link formatting.format format} - formats a query, according to parameters.\r\n *\r\n */\nconst $as = {\n  /**\r\n   * @namespace formatting.ctf\r\n   * @description\r\n   * Namespace for ES6 symbols used by $[Custom Type Formatting], available from `pgp.as.ctf` before and after initializing the library.\r\n   *\r\n   * It was added to avoid explicit/enumerable extension of types that need to be used as formatting parameters, to keep their type signature intact.\r\n   *\r\n   * @property {external:Symbol} toPostgres\r\n   * Property name for the $[Custom Type Formatting] callback function `toPostgres`.\r\n   *\r\n   * @property {external:Symbol} rawType\r\n   * Property name for the $[Custom Type Formatting] flag `rawType`.\r\n   *\r\n   * @example\r\n   * const ctf = pgp.as.ctf; // Custom Type Formatting symbols\r\n   *\r\n   * class MyType {\r\n   *     constructor() {\r\n   *         this[ctf.rawType] = true; // set it only when toPostgres returns a pre-formatted result\r\n   *     }\r\n   *\r\n   *     [ctf.toPostgres](self) {\r\n   *         // self = this\r\n   *\r\n   *         // return the custom/actual value here\r\n   *     }\r\n   * }\r\n   *\r\n   * const a = new MyType();\r\n   *\r\n   * const s = pgp.as.format('$1', a); // will be custom-formatted\r\n   */\n  ctf: ctfSymbols,\n  /**\r\n   * @method formatting.text\r\n   * @description\r\n   * Converts a value into PostgreSQL text presentation, escaped as required.\r\n   *\r\n   * Escaping the result means:\r\n   *  1. Every single-quote (apostrophe) is replaced with two\r\n   *  2. The resulting text is wrapped in apostrophes\r\n   *\r\n   * @param {value|function} value\r\n   * Value to be converted, or a function that returns the value.\r\n   *\r\n   * If the `value` resolves as `null` or `undefined`, while `raw`=`true`,\r\n   * it will throw {@link external:TypeError TypeError} = `Values null/undefined cannot be used as raw text.`\r\n   *\r\n   * @param {boolean} [raw=false]\r\n   * Indicates when not to escape the resulting text.\r\n   *\r\n   * @returns {string}\r\n   *\r\n   * - `null` string, if the `value` resolves as `null` or `undefined`\r\n   * - escaped result of `value.toString()`, if the `value` isn't a string\r\n   * - escaped string version, if `value` is a string.\r\n   *\r\n   *  The result is not escaped, if `raw` was passed in as `true`.\r\n   */\n  text(value, raw) {\n    value = resolveFunc(value);\n    if (isNull(value)) {\n      throwIfRaw(raw);\n      return 'null';\n    }\n    if (typeof value !== 'string') {\n      value = value.toString();\n    }\n    return $to.text(value, raw);\n  },\n  /**\r\n   * @method formatting.name\r\n   * @description\r\n   * Properly escapes an sql name or identifier, fixing double-quote symbols and wrapping the result in double quotes.\r\n   *\r\n   * Implements a safe way to format $[SQL Names] that neutralizes SQL Injection.\r\n   *\r\n   * When formatting a query, a variable makes use of this method via modifier `:name` or `~`. See method {@link formatting.format format}.\r\n   *\r\n   * @param {string|function|array|object} name\r\n   * SQL name or identifier, or a function that returns it.\r\n   *\r\n   * The name must be at least 1 character long.\r\n   *\r\n   * If `name` doesn't resolve into a non-empty string, it throws {@link external:TypeError TypeError} = `Invalid sql name: ...`\r\n   *\r\n   * If the `name` contains only a single `*` (trailing spaces are ignored), then `name` is returned exactly as is (unescaped).\r\n   *\r\n   * - If `name` is an Array, it is formatted as a comma-separated list of $[SQL Names]\r\n   * - If `name` is a non-Array object, its keys are formatted as a comma-separated list of $[SQL Names]\r\n   *\r\n   * Passing in an empty array/object will throw {@link external:Error Error} = `Cannot retrieve sql names from an empty array/object.`\r\n   *\r\n   * @returns {string}\r\n   * The SQL Name/Identifier, properly escaped for compliance with the PostgreSQL standard for $[SQL Names] and identifiers.\r\n   *\r\n   * @see\r\n   * {@link formatting.alias alias},\r\n   * {@link formatting.format format}\r\n   *\r\n   * @example\r\n   *\r\n   * // automatically list object properties as sql names:\r\n   * format('INSERT INTO table(${this~}) VALUES(${one}, ${two})', {\r\n   *     one: 1,\r\n   *     two: 2\r\n   * });\r\n   * //=> INSERT INTO table(\"one\",\"two\") VALUES(1, 2)\r\n   *\r\n   */\n  name(name) {\n    name = resolveFunc(name);\n    if (name) {\n      if (typeof name === 'string') {\n        return /^\\s*\\*(\\s*)$/.test(name) ? name : formatSqlName(name);\n      }\n      if (typeof name === 'object') {\n        const keys = Array.isArray(name) ? name : Object.keys(name);\n        if (!keys.length) {\n          throw new Error('Cannot retrieve sql names from an empty array/object.');\n        }\n        return keys.map(value => {\n          if (!value || typeof value !== 'string') {\n            throw new Error(`Invalid sql name: ${npm.utils.toJson(value)}`);\n          }\n          return formatSqlName(value);\n        }).join();\n      }\n    }\n    throw new TypeError(`Invalid sql name: ${npm.utils.toJson(name)}`);\n  },\n  /**\r\n   * @method formatting.alias\r\n   * @description\r\n   * Simpler (non-verbose) version of method {@link formatting.name name}, to handle only a regular string-identifier\r\n   * that's mostly used as an SQL alias, i.e. it doesn't support `*` or an array/object of names, which in the context of\r\n   * an SQL alias would be incorrect. However, it supports `.` as name-separator, for simpler escaping of composite names.\r\n   *\r\n   * The surrounding double quotes are not added when the alias uses a simple syntax:\r\n   *  - it is a same-case single word, without spaces\r\n   *  - it can contain underscores, and can even start with them\r\n   *  - it can contain digits and `$`, but cannot start with those\r\n   *\r\n   * The method will automatically split the string with `.`, to support composite SQL names.\r\n   *\r\n   * When formatting a query, a variable makes use of this method via modifier `:alias`. See method {@link formatting.format format}.\r\n   *\r\n   * @param {string|function} name\r\n   * SQL alias name, or a function that returns it.\r\n   *\r\n   * The name must be at least 1 character long. And it can contain `.`, to split into multiple SQL names.\r\n   *\r\n   * If `name` doesn't resolve into a non-empty string, it throws {@link external:TypeError TypeError} = `Invalid sql alias: ...`\r\n   *\r\n   * @returns {string}\r\n   * The SQL alias, properly escaped for compliance with the PostgreSQL standard for $[SQL Names] and identifiers.\r\n   *\r\n   * @see\r\n   * {@link formatting.name name},\r\n   * {@link formatting.format format}\r\n   *\r\n   */\n  alias(name) {\n    name = resolveFunc(name);\n    if (name && typeof name === 'string') {\n      return name.split('.').filter(f => f).map(a => {\n        const m = a.match(/^([a-z_][a-z0-9_$]*|[A-Z_][A-Z0-9_$]*)$/);\n        if (m && m[0] === a) {\n          return a;\n        }\n        return `\"${a.replace(/\"/g, '\"\"')}\"`;\n      }).join('.');\n    }\n    throw new TypeError(`Invalid sql alias: ${npm.utils.toJson(name)}`);\n  },\n  /**\r\n   * @method formatting.value\r\n   * @description\r\n   * Represents an open value, one to be formatted according to its type, properly escaped, but without surrounding quotes for text types.\r\n   *\r\n   * When formatting a query, a variable makes use of this method via modifier `:value` or `#`. See method {@link formatting.format format}.\r\n   *\r\n   * @param {value|function} value\r\n   * Value to be converted, or a function that returns the value.\r\n   *\r\n   * If `value` resolves as `null` or `undefined`, it will throw {@link external:TypeError TypeError} = `Open values cannot be null or undefined.`\r\n   *\r\n   * @returns {string}\r\n   * Formatted and properly escaped string, but without surrounding quotes for text types.\r\n   *\r\n   * @see {@link formatting.format format}\r\n   *\r\n   */\n  value(value) {\n    value = resolveFunc(value);\n    if (isNull(value)) {\n      throw new TypeError('Open values cannot be null or undefined.');\n    }\n    return safeText(formatValue({\n      value,\n      fm: fmFlags.raw\n    }));\n  },\n  /**\r\n   * @method formatting.buffer\r\n   * @description\r\n   * Converts an object of type `Buffer` into a hex string compatible with PostgreSQL type `bytea`.\r\n   *\r\n   * @param {Buffer|function} obj\r\n   * Object to be converted, or a function that returns one.\r\n   *\r\n   * @param {boolean} [raw=false]\r\n   * Indicates when not to wrap the resulting string in quotes.\r\n   *\r\n   * The generated hex string doesn't need to be escaped.\r\n   *\r\n   * @returns {string}\r\n   */\n  buffer(obj, raw) {\n    obj = resolveFunc(obj);\n    if (isNull(obj)) {\n      throwIfRaw(raw);\n      return 'null';\n    }\n    if (obj instanceof Buffer) {\n      return $to.buffer(obj, raw);\n    }\n    throw new TypeError(`${wrapText(obj)} is not a Buffer object.`);\n  },\n  /**\r\n   * @method formatting.bool\r\n   * @description\r\n   * Converts a truthy value into PostgreSQL boolean presentation.\r\n   *\r\n   * @param {boolean|function} value\r\n   * Value to be converted, or a function that returns the value.\r\n   *\r\n   * @returns {string}\r\n   */\n  bool(value) {\n    value = resolveFunc(value);\n    if (isNull(value)) {\n      return 'null';\n    }\n    return $to.bool(value);\n  },\n  /**\r\n   * @method formatting.date\r\n   * @description\r\n   * Converts a `Date`-type value into PostgreSQL date/time presentation,\r\n   * wrapped in quotes (unless flag `raw` is set).\r\n   *\r\n   * @param {Date|function} d\r\n   * Date object to be converted, or a function that returns one.\r\n   *\r\n   * @param {boolean} [raw=false]\r\n   * Indicates when not to escape the value.\r\n   *\r\n   * @returns {string}\r\n   */\n  date(d, raw) {\n    d = resolveFunc(d);\n    if (isNull(d)) {\n      throwIfRaw(raw);\n      return 'null';\n    }\n    if (d instanceof Date) {\n      return $to.date(d, raw);\n    }\n    throw new TypeError(`${wrapText(d)} is not a Date object.`);\n  },\n  /**\r\n   * @method formatting.number\r\n   * @description\r\n   * Converts a numeric value into its PostgreSQL number presentation, with support\r\n   * for special values of `NaN`, `+Infinity` and `-Infinity`.\r\n   *\r\n   * @param {number|bigint|function} num\r\n   * Number to be converted, or a function that returns one.\r\n   *\r\n   * @returns {string}\r\n   */\n  number(num) {\n    num = resolveFunc(num);\n    if (isNull(num)) {\n      return 'null';\n    }\n    const t = typeof num;\n    if (t !== 'number' && t !== 'bigint') {\n      throw new TypeError(`${wrapText(num)} is not a number.`);\n    }\n    return $to.number(num);\n  },\n  /**\r\n   * @method formatting.array\r\n   * @description\r\n   * Converts an array of values into its PostgreSQL presentation as an Array-Type constructor string: `array[]`.\r\n   *\r\n   * Top-level empty arrays are formatted as literal `{}`, to avoid the necessity of explicit type casting,\r\n   * as the server cannot automatically infer type of empty non-literal array.\r\n   *\r\n   * @param {Array|function} arr\r\n   * Array to be converted, or a function that returns one.\r\n   *\r\n   * @param {{}} [options]\r\n   * Array-Formatting Options.\r\n   *\r\n   * @param {boolean} [options.capSQL=false]\r\n   * When `true`, outputs `ARRAY` instead of `array`.\r\n   *\r\n   * @returns {string}\r\n   */\n  array(arr, options) {\n    options = assert(options, ['capSQL']);\n    arr = resolveFunc(arr);\n    if (isNull(arr)) {\n      return 'null';\n    }\n    if (Array.isArray(arr)) {\n      return $to.array(arr, options);\n    }\n    throw new TypeError(`${wrapText(arr)} is not an Array object.`);\n  },\n  /**\r\n   * @method formatting.csv\r\n   * @description\r\n   * Converts a single value or an array of values into a CSV (comma-separated values) string, with all values formatted\r\n   * according to their JavaScript type.\r\n   *\r\n   * When formatting a query, a variable makes use of this method via modifier `:csv` or its alias `:list`.\r\n   *\r\n   * When `values` is an object that's not `null` or `Array`, its properties are enumerated for the actual values.\r\n   *\r\n   * @param {Array|Object|value|function} values\r\n   * Value(s) to be converted, or a function that returns it.\r\n   *\r\n   * @returns {string}\r\n   *\r\n   * @see {@link formatting.format format}\r\n   */\n  csv(values) {\n    return $to.csv(values);\n  },\n  /**\r\n   * @method formatting.json\r\n   * @description\r\n   * Converts any value into JSON (includes `BigInt` support), and returns it as a valid string,\r\n   * with single-quote symbols fixed, unless flag `raw` is set.\r\n   *\r\n   * When formatting a query, a variable makes use of this method via modifier `:json`. See method {@link formatting.format format}.\r\n   *\r\n   * @param {*} data\r\n   * Object/value to be converted, or a function that returns it.\r\n   *\r\n   * @param {boolean} [raw=false]\r\n   * Indicates when not to escape the result.\r\n   *\r\n   * @returns {string}\r\n   *\r\n   * @see {@link formatting.format format}\r\n   */\n  json(data, raw) {\n    data = resolveFunc(data);\n    if (isNull(data)) {\n      throwIfRaw(raw);\n      return 'null';\n    }\n    return $to.json(data, raw);\n  },\n  /**\r\n   * @method formatting.func\r\n   * @description\r\n   * Calls the function to get the actual value, and then formats the result according to its type + `raw` flag.\r\n   *\r\n   * @param {function} func\r\n   * Function to be called, with support for nesting.\r\n   *\r\n   * @param {boolean} [raw=false]\r\n   * Indicates when not to escape the result.\r\n   *\r\n   * @param {*} [cc]\r\n   * Calling Context: `this` + the only value to be passed into the function on all nested levels.\r\n   *\r\n   * @returns {string}\r\n   */\n  func(func, raw, cc) {\n    if (isNull(func)) {\n      throwIfRaw(raw);\n      return 'null';\n    }\n    if (typeof func !== 'function') {\n      throw new TypeError(`${wrapText(func)} is not a function.`);\n    }\n    const fm = raw ? fmFlags.raw : null;\n    return formatValue({\n      value: resolveFunc(func, cc),\n      fm,\n      cc\n    });\n  },\n  /**\r\n   * @method formatting.format\r\n   * @description\r\n   * Replaces variables in a string according to the type of `values`:\r\n   *\r\n   * - Replaces `$1` occurrences when `values` is of type `string`, `boolean`, `number`, `bigint`, `Date`, `Buffer` or when it is `null`.\r\n   *\r\n   * - Replaces variables `$1`, `$2`, ...`$100000` when `values` is an array of parameters. It throws a {@link external:RangeError RangeError}\r\n   * when the values or variables are out of range.\r\n   *\r\n   * - Replaces `$*propName*`, where `*` is any of `{}`, `()`, `[]`, `<>`, `//`, when `values` is an object that's not a\r\n   * `Date`, `Buffer`, {@link QueryFile} or `null`. Special property name `this` refers to the formatting object itself,\r\n   *   to be injected as a JSON string. When referencing a property that doesn't exist in the formatting object, it throws\r\n   *   {@link external:Error Error} = `Property 'PropName' doesn't exist`, unless option `partial` is used.\r\n   *\r\n   * - Supports $[Nested Named Parameters] of any depth.\r\n   *\r\n   * By default, each variable is automatically formatted according to its type, unless it is a special variable:\r\n   *\r\n   * - Raw-text variables end with `:raw` or symbol `^`, and prevent escaping the text. Such variables are not\r\n   *   allowed to be `null` or `undefined`, or the method will throw {@link external:TypeError TypeError} = `Values null/undefined cannot be used as raw text.`\r\n   *   - `$1:raw`, `$2:raw`,..., and `$*propName:raw*` (see `*` above)\r\n   *   - `$1^`, `$2^`,..., and `$*propName^*` (see `*` above)\r\n   *\r\n   * - Open-value variables end with `:value` or symbol `#`, to be escaped, but not wrapped in quotes. Such variables are\r\n   *   not allowed to be `null` or `undefined`, or the method will throw {@link external:TypeError TypeError} = `Open values cannot be null or undefined.`\r\n   *   - `$1:value`, `$2:value`,..., and `$*propName:value*` (see `*` above)\r\n   *   - `$1#`, `$2#`,..., and `$*propName#*` (see `*` above)\r\n   *\r\n   * - SQL name variables end with `:name` or symbol `~` (tilde), and provide proper escaping for SQL names/identifiers:\r\n   *   - `$1:name`, `$2:name`,..., and `$*propName:name*` (see `*` above)\r\n   *   - `$1~`, `$2~`,..., and `$*propName~*` (see `*` above)\r\n   *\r\n   * - Modifier `:alias` - non-verbose $[SQL Names] escaping.\r\n   *\r\n   * - JSON override ends with `:json` to format the value of any type as a JSON string\r\n   *\r\n   * - CSV override ends with `:csv` or `:list` to format an array as a properly escaped comma-separated list of values.\r\n   *\r\n   * @param {string|QueryFile|object} query\r\n   * A query string, a {@link QueryFile} or any object that implements $[Custom Type Formatting], to be formatted according to `values`.\r\n   *\r\n   * @param {array|object|value} [values]\r\n   * Formatting parameter(s) / variable value(s).\r\n   *\r\n   * @param {{}} [options]\r\n   * Formatting Options.\r\n   *\r\n   * @param {boolean} [options.capSQL=false]\r\n   * Formats reserved SQL words capitalized. Presently, this only concerns arrays, to output `ARRAY` when required.\r\n   *\r\n   * @param {boolean} [options.partial=false]\r\n   * Indicates that we intend to do only a partial replacement, i.e. throw no error when encountering a variable or\r\n   * property name that's missing within the formatting parameters.\r\n   *\r\n   * **NOTE:** This option has no meaning when option `def` is used.\r\n   *\r\n   * @param {*} [options.def]\r\n   * Sets default value for every variable that's missing, consequently preventing errors when encountering a variable\r\n   * or property name that's missing within the formatting parameters.\r\n   *\r\n   * It can also be set to a function, to be called with two parameters that depend on the type of formatting being used,\r\n   * and to return the actual default value:\r\n   *\r\n   * - For $[Named Parameters] formatting:\r\n   *   - `name` - name of the property missing in the formatting object\r\n   *   - `obj` - the formatting object, and is the same as `this` context\r\n   *\r\n   * - For $[Index Variables] formatting:\r\n   *   - `index` - element's index (starts with 1) that's outside of the input array\r\n   *   - `arr` - the formatting/input array, and is the same as `this` context\r\n   *\r\n   *   You can tell which type of call it is by checking the type of the first parameter.\r\n   *\r\n   * @returns {string}\r\n   * Formatted query string.\r\n   *\r\n   * The function will throw an error, if any occurs during formatting.\r\n   */\n  format(query, values, options) {\n    options = assert(options, ['capSQL', 'partial', 'def']);\n    const ctf = getCTF(query);\n    if (ctf) {\n      query = ctf.toPostgres.call(query, query);\n    }\n    return formatQuery(query, values, false, options);\n  }\n};\n\n/* Pre-parsed type formatting */\nconst $to = {\n  array(arr, options) {\n    return formatArray(arr, options);\n  },\n  csv(values, options) {\n    return formatCSV(resolveFunc(values), options);\n  },\n  bool(value) {\n    return value ? 'true' : 'false';\n  },\n  buffer(obj, raw) {\n    const s = `\\\\x${obj.toString('hex')}`;\n    return raw ? s : wrapText(s);\n  },\n  date(d, raw) {\n    const s = npm.pgUtils.prepareValue(d);\n    return raw ? s : wrapText(s);\n  },\n  json(data, raw) {\n    const s = npm.utils.toJson(data);\n    return raw ? s : wrapText(safeText(s));\n  },\n  number(num) {\n    if (typeof num === 'bigint' || Number.isFinite(num)) {\n      return num.toString();\n    }\n    // Converting NaN/+Infinity/-Infinity according to Postgres documentation:\n    // http://www.postgresql.org/docs/9.6/static/datatype-numeric.html#DATATYPE-FLOAT\n    //\n    // NOTE: strings for 'NaN'/'+Infinity'/'-Infinity' are not case-sensitive.\n    if (num === Number.POSITIVE_INFINITY) {\n      return wrapText('+Infinity');\n    }\n    if (num === Number.NEGATIVE_INFINITY) {\n      return wrapText('-Infinity');\n    }\n    return wrapText('NaN');\n  },\n  text(value, raw) {\n    return raw ? value : wrapText(safeText(value));\n  }\n};\nmodule.exports = {\n  formatQuery,\n  formatEntity,\n  resolveFunc,\n  as: $as\n};\n\n/**\r\n * @external Error\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\r\n */\n\n/**\r\n * @external TypeError\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError\r\n */\n\n/**\r\n * @external RangeError\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError\r\n */\n\n/**\r\n * @external Symbol\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol\r\n */","map":{"version":3,"names":["assert","require","npm","pgUtils","patterns","utils","fmFlags","raw","alias","name","json","csv","value","fmMap","ctfSymbols","toPostgres","Symbol","for","rawType","maxVariable","formatValue","fm","cc","options","resolveFunc","ctf","getCTF","isRaw","$as","$to","isNull","throwIfRaw","text","bool","number","TypeError","toString","Date","date","Array","isArray","array","Buffer","isBuffer","buffer","formatArray","loop","a","map","join","prefix","capSQL","length","formatCSV","values","Object","keys","v","undefined","formatAs","object","query","obj","replace","namedParameters","stripName","c","getIfHas","valid","Error","has","target","d","def","call","partial","multipleValues","substr","idx","RangeError","singleValue","mod","match","hasValidModifier","index","constructor","wrapText","safeText","formatQuery","formatEntity","entity","type","toUpperCase","formatSqlName","test","toJson","split","filter","f","m","num","t","arr","data","func","format","s","prepareValue","Number","isFinite","POSITIVE_INFINITY","NEGATIVE_INFINITY","module","exports","as"],"sources":["/Users/luna/Library/Mobile Documents/com~apple~CloudDocs/GitHub/paucamcal.github.io/AESP/node_modules/pg-promise/lib/formatting.js"],"sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {assert} = require('./assert');\r\n\r\nconst npm = {\r\n    pgUtils: require('pg/lib/utils'),\r\n    patterns: require('./patterns'),\r\n    utils: require('./utils')\r\n};\r\n\r\n// Format Modification Flags;\r\nconst fmFlags = {\r\n    raw: 1, // Raw-Text variable\r\n    alias: 2, // SQL Alias\r\n    name: 4, // SQL Name/Identifier\r\n    json: 8, // JSON modifier\r\n    csv: 16, // CSV modifier\r\n    value: 32 // escaped, but without ''\r\n};\r\n\r\n// Format Modification Map;\r\nconst fmMap = {\r\n    '^': fmFlags.raw,\r\n    ':raw': fmFlags.raw,\r\n    ':alias': fmFlags.alias,\r\n    '~': fmFlags.name,\r\n    ':name': fmFlags.name,\r\n    ':json': fmFlags.json,\r\n    ':csv': fmFlags.csv,\r\n    ':list': fmFlags.csv,\r\n    ':value': fmFlags.value,\r\n    '#': fmFlags.value\r\n};\r\n\r\n// Global symbols for Custom Type Formatting:\r\nconst ctfSymbols = {\r\n    toPostgres: Symbol.for('ctf.toPostgres'),\r\n    rawType: Symbol.for('ctf.rawType')\r\n};\r\n\r\nconst maxVariable = 100000; // maximum supported variable is '$100000'\r\n\r\n////////////////////////////////////////////////////\r\n// Converts a single value into its Postgres format.\r\nfunction formatValue({value, fm, cc, options}) {\r\n\r\n    if (typeof value === 'function') {\r\n        return formatValue({value: resolveFunc(value, cc), fm, cc});\r\n    }\r\n\r\n    const ctf = getCTF(value); // Custom Type Formatting\r\n    if (ctf) {\r\n        fm |= ctf.rawType ? fmFlags.raw : 0;\r\n        return formatValue({value: resolveFunc(ctf.toPostgres, value), fm, cc});\r\n    }\r\n\r\n    const isRaw = !!(fm & fmFlags.raw);\r\n    fm &= ~fmFlags.raw;\r\n\r\n    switch (fm) {\r\n        case fmFlags.alias:\r\n            return $as.alias(value);\r\n        case fmFlags.name:\r\n            return $as.name(value);\r\n        case fmFlags.json:\r\n            return $as.json(value, isRaw);\r\n        case fmFlags.csv:\r\n            return $to.csv(value, options);\r\n        case fmFlags.value:\r\n            return $as.value(value);\r\n        default:\r\n            break;\r\n    }\r\n\r\n    if (isNull(value)) {\r\n        throwIfRaw(isRaw);\r\n        return 'null';\r\n    }\r\n\r\n    switch (typeof value) {\r\n        case 'string':\r\n            return $to.text(value, isRaw);\r\n        case 'boolean':\r\n            return $to.bool(value);\r\n        case 'number':\r\n        case 'bigint':\r\n            return $to.number(value);\r\n        case 'symbol':\r\n            throw new TypeError(`Type Symbol has no meaning for PostgreSQL: ${value.toString()}`);\r\n        default:\r\n            if (value instanceof Date) {\r\n                return $to.date(value, isRaw);\r\n            }\r\n            if (Array.isArray(value)) {\r\n                return $to.array(value, options);\r\n            }\r\n            if (Buffer.isBuffer(value)) {\r\n                return $to.buffer(value, isRaw);\r\n            }\r\n            return $to.json(value, isRaw);\r\n    }\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// Converts array of values into PostgreSQL Array Constructor: array[...], as per PostgreSQL documentation:\r\n// http://www.postgresql.org/docs/9.6/static/arrays.html\r\n//\r\n// Arrays of any depth/dimension are supported.\r\n//\r\n// Top-level empty arrays are formatted as literal '{}' to avoid the necessity of explicit type casting,\r\n// as the server cannot automatically infer the type of empty non-literal array.\r\nfunction formatArray(array, options) {\r\n    const loop = a => '[' + a.map(value => Array.isArray(value) ? loop(value) : formatValue({\r\n        value,\r\n        options\r\n    })).join() + ']';\r\n    const prefix = options && options.capSQL ? 'ARRAY' : 'array';\r\n    return array.length ? (prefix + loop(array)) : '\\'{}\\'';\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////\r\n// Formats array/object/value as a list of comma-separated values.\r\nfunction formatCSV(values, options) {\r\n    if (Array.isArray(values)) {\r\n        return values.map(value => formatValue({value, options})).join();\r\n    }\r\n    if (typeof values === 'object' && values !== null) {\r\n        return Object.keys(values).map(v => formatValue({value: values[v], options})).join();\r\n    }\r\n    return values === undefined ? '' : formatValue({value: values, options});\r\n}\r\n\r\n///////////////////////////////\r\n// Query formatting helpers;\r\nconst formatAs = {\r\n\r\n    object({query, obj, raw, options}) {\r\n        options = options && typeof options === 'object' ? options : {};\r\n        return query.replace(npm.patterns.namedParameters, name => {\r\n            const v = formatAs.stripName(name.replace(/^\\$[{(<[/]|[\\s})>\\]/]/g, ''), raw),\r\n                c = npm.utils.getIfHas(obj, v.name);\r\n            if (!c.valid) {\r\n                throw new Error(`Invalid property name '${v.name}'.`);\r\n            }\r\n            if (c.has) {\r\n                return formatValue({value: c.value, fm: v.fm, cc: c.target, options});\r\n            }\r\n            if (v.name === 'this') {\r\n                return formatValue({value: obj, fm: v.fm, options});\r\n            }\r\n            if ('def' in options) {\r\n                const d = options.def, value = typeof d === 'function' ? d.call(obj, v.name, obj) : d;\r\n                return formatValue({value, fm: v.fm, cc: obj, options});\r\n            }\r\n            if (options.partial) {\r\n                return name;\r\n            }\r\n            // property must exist as the object's own or inherited;\r\n            throw new Error(`Property '${v.name}' doesn't exist.`);\r\n        });\r\n    },\r\n\r\n    array({query, array, raw, options}) {\r\n        options = options && typeof options === 'object' ? options : {};\r\n        return query.replace(npm.patterns.multipleValues, name => {\r\n            const v = formatAs.stripName(name.substr(1), raw);\r\n            const idx = v.name - 1;\r\n            if (idx >= maxVariable) {\r\n                throw new RangeError(`Variable $${v.name} exceeds supported maximum of $${maxVariable}`);\r\n            }\r\n            if (idx < array.length) {\r\n                return formatValue({value: array[idx], fm: v.fm, options});\r\n            }\r\n            if ('def' in options) {\r\n                const d = options.def, value = typeof d === 'function' ? d.call(array, idx, array) : d;\r\n                return formatValue({value, fm: v.fm, options});\r\n            }\r\n            if (options.partial) {\r\n                return name;\r\n            }\r\n            throw new RangeError(`Variable $${v.name} out of range. Parameters array length: ${array.length}`);\r\n        });\r\n    },\r\n\r\n    value({query, value, raw, options}) {\r\n        return query.replace(npm.patterns.singleValue, name => {\r\n            const v = formatAs.stripName(name, raw);\r\n            return formatValue({value, fm: v.fm, options});\r\n        });\r\n    },\r\n\r\n    stripName(name, raw) {\r\n        const mod = name.match(npm.patterns.hasValidModifier);\r\n        if (mod) {\r\n            return {\r\n                name: name.substr(0, mod.index),\r\n                fm: fmMap[mod[0]] | (raw ? fmFlags.raw : 0)\r\n            };\r\n        }\r\n        return {\r\n            name,\r\n            fm: raw ? fmFlags.raw : null\r\n        };\r\n    }\r\n};\r\n\r\n////////////////////////////////////////////\r\n// Simpler check for null/undefined;\r\nfunction isNull(value) {\r\n    return value === undefined || value === null;\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////\r\n// Checks if the value supports Custom Type Formatting,\r\n// to return {toPostgres, rawType}, if it does, or null otherwise.\r\nfunction getCTF(value) {\r\n    if (!isNull(value)) {\r\n        let toPostgres = value[ctfSymbols.toPostgres], rawType = !!value[ctfSymbols.rawType];\r\n        if (typeof toPostgres !== 'function') {\r\n            toPostgres = value.toPostgres;\r\n            rawType = !!value.rawType;\r\n        }\r\n        if (typeof toPostgres === 'function') {\r\n            if (toPostgres.constructor.name !== 'Function') {\r\n                throw new Error('CTF does not support asynchronous toPostgres functions.');\r\n            }\r\n            return {toPostgres, rawType};\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/////////////////////////////////////////\r\n// Wraps a text string in single quotes;\r\nfunction wrapText(text) {\r\n    return `'${text}'`;\r\n}\r\n\r\n////////////////////////////////////////////////\r\n// Replaces each single-quote symbol ' with two,\r\n// for compliance with PostgreSQL strings.\r\nfunction safeText(text) {\r\n    return text.replace(/'/g, '\\'\\'');\r\n}\r\n\r\n/////////////////////////////////////////////\r\n// Throws an exception, if flag 'raw' is set.\r\nfunction throwIfRaw(raw) {\r\n    if (raw) {\r\n        throw new TypeError('Values null/undefined cannot be used as raw text.');\r\n    }\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Recursively resolves parameter-function, with an optional Calling Context.\r\nfunction resolveFunc(value, cc) {\r\n    while (typeof value === 'function') {\r\n        if (value.constructor.name !== 'Function') {\r\n            // Constructor name for asynchronous functions have different names:\r\n            // - 'GeneratorFunction' for ES6 generators\r\n            // - 'AsyncFunction' for ES7 async functions\r\n            throw new Error('Cannot use asynchronous functions with query formatting.');\r\n        }\r\n        value = value.call(cc, cc);\r\n    }\r\n    return value;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////////\r\n// It implements two types of formatting, depending on the 'values' passed:\r\n//\r\n// 1. format '$1, $2, etc', when 'values' is of type string, boolean, number, date,\r\n//    function or null (or an array of the same types, plus undefined values);\r\n// 2. format $*propName*, when 'values' is an object (not null and not Date),\r\n//    and where * is any of the supported open-close pairs: {}, (), [], <>, //\r\n//\r\nfunction formatQuery(query, values, raw, options) {\r\n    if (typeof query !== 'string') {\r\n        throw new TypeError('Parameter \\'query\\' must be a text string.');\r\n    }\r\n    const ctf = getCTF(values);\r\n    if (ctf) {\r\n        // Custom Type Formatting\r\n        return formatQuery(query, resolveFunc(ctf.toPostgres, values), raw || ctf.rawType, options);\r\n    }\r\n    if (typeof values === 'object' && values !== null) {\r\n        if (Array.isArray(values)) {\r\n            // $1, $2,... formatting to be applied;\r\n            return formatAs.array({query, array: values, raw, options});\r\n        }\r\n        if (!(values instanceof Date || values instanceof Buffer)) {\r\n            // $*propName* formatting to be applied;\r\n            return formatAs.object({query, obj: values, raw, options});\r\n        }\r\n    }\r\n    // $1 formatting to be applied, if values != undefined;\r\n    return values === undefined ? query : formatAs.value({query, value: values, raw, options});\r\n}\r\n\r\n//////////////////////////////////////////////////////\r\n// Formats a function or stored procedure call query;\r\nfunction formatEntity(entity, values, {capSQL, type}) {\r\n    let prefix = type === 'func' ? 'select * from' : 'call';\r\n    if (capSQL) {\r\n        prefix = prefix.toUpperCase();\r\n    }\r\n    return `${prefix} ${$as.alias(entity)}(${formatCSV(values, {capSQL})})`;\r\n}\r\n\r\nfunction formatSqlName(name) {\r\n    return `\"${name.replace(/\"/g, '\"\"')}\"`;\r\n}\r\n\r\n/**\r\n * @namespace formatting\r\n * @description\r\n * Namespace for all query-formatting functions, available from `pgp.as` before and after initializing the library.\r\n *\r\n * @property {formatting.ctf} ctf\r\n * Namespace for symbols used by $[Custom Type Formatting].\r\n *\r\n * @property {function} alias\r\n * {@link formatting.alias alias} - formats an SQL alias.\r\n *\r\n * @property {function} name\r\n * {@link formatting.name name} - formats an SQL Name/Identifier.\r\n *\r\n * @property {function} text\r\n * {@link formatting.text text} - formats a text string.\r\n *\r\n * @property {function} number\r\n * {@link formatting.number number} - formats a number.\r\n *\r\n * @property {function} buffer\r\n * {@link formatting.buffer buffer} - formats a `Buffer` object.\r\n *\r\n * @property {function} value\r\n * {@link formatting.value value} - formats text as an open value.\r\n *\r\n * @property {function} json\r\n * {@link formatting.json json} - formats any value as JSON.\r\n *\r\n * @property {function} array\r\n * {@link formatting.array array} - formats an array of any depth.\r\n *\r\n * @property {function} csv\r\n * {@link formatting.csv csv} - formats an array as a list of comma-separated values.\r\n *\r\n * @property {function} func\r\n * {@link formatting.func func} - formats the value returned from a function.\r\n *\r\n * @property {function} format\r\n * {@link formatting.format format} - formats a query, according to parameters.\r\n *\r\n */\r\nconst $as = {\r\n\r\n    /**\r\n     * @namespace formatting.ctf\r\n     * @description\r\n     * Namespace for ES6 symbols used by $[Custom Type Formatting], available from `pgp.as.ctf` before and after initializing the library.\r\n     *\r\n     * It was added to avoid explicit/enumerable extension of types that need to be used as formatting parameters, to keep their type signature intact.\r\n     *\r\n     * @property {external:Symbol} toPostgres\r\n     * Property name for the $[Custom Type Formatting] callback function `toPostgres`.\r\n     *\r\n     * @property {external:Symbol} rawType\r\n     * Property name for the $[Custom Type Formatting] flag `rawType`.\r\n     *\r\n     * @example\r\n     * const ctf = pgp.as.ctf; // Custom Type Formatting symbols\r\n     *\r\n     * class MyType {\r\n     *     constructor() {\r\n     *         this[ctf.rawType] = true; // set it only when toPostgres returns a pre-formatted result\r\n     *     }\r\n     *\r\n     *     [ctf.toPostgres](self) {\r\n     *         // self = this\r\n     *\r\n     *         // return the custom/actual value here\r\n     *     }\r\n     * }\r\n     *\r\n     * const a = new MyType();\r\n     *\r\n     * const s = pgp.as.format('$1', a); // will be custom-formatted\r\n     */\r\n    ctf: ctfSymbols,\r\n\r\n    /**\r\n     * @method formatting.text\r\n     * @description\r\n     * Converts a value into PostgreSQL text presentation, escaped as required.\r\n     *\r\n     * Escaping the result means:\r\n     *  1. Every single-quote (apostrophe) is replaced with two\r\n     *  2. The resulting text is wrapped in apostrophes\r\n     *\r\n     * @param {value|function} value\r\n     * Value to be converted, or a function that returns the value.\r\n     *\r\n     * If the `value` resolves as `null` or `undefined`, while `raw`=`true`,\r\n     * it will throw {@link external:TypeError TypeError} = `Values null/undefined cannot be used as raw text.`\r\n     *\r\n     * @param {boolean} [raw=false]\r\n     * Indicates when not to escape the resulting text.\r\n     *\r\n     * @returns {string}\r\n     *\r\n     * - `null` string, if the `value` resolves as `null` or `undefined`\r\n     * - escaped result of `value.toString()`, if the `value` isn't a string\r\n     * - escaped string version, if `value` is a string.\r\n     *\r\n     *  The result is not escaped, if `raw` was passed in as `true`.\r\n     */\r\n    text(value, raw) {\r\n        value = resolveFunc(value);\r\n        if (isNull(value)) {\r\n            throwIfRaw(raw);\r\n            return 'null';\r\n        }\r\n        if (typeof value !== 'string') {\r\n            value = value.toString();\r\n        }\r\n        return $to.text(value, raw);\r\n    },\r\n\r\n    /**\r\n     * @method formatting.name\r\n     * @description\r\n     * Properly escapes an sql name or identifier, fixing double-quote symbols and wrapping the result in double quotes.\r\n     *\r\n     * Implements a safe way to format $[SQL Names] that neutralizes SQL Injection.\r\n     *\r\n     * When formatting a query, a variable makes use of this method via modifier `:name` or `~`. See method {@link formatting.format format}.\r\n     *\r\n     * @param {string|function|array|object} name\r\n     * SQL name or identifier, or a function that returns it.\r\n     *\r\n     * The name must be at least 1 character long.\r\n     *\r\n     * If `name` doesn't resolve into a non-empty string, it throws {@link external:TypeError TypeError} = `Invalid sql name: ...`\r\n     *\r\n     * If the `name` contains only a single `*` (trailing spaces are ignored), then `name` is returned exactly as is (unescaped).\r\n     *\r\n     * - If `name` is an Array, it is formatted as a comma-separated list of $[SQL Names]\r\n     * - If `name` is a non-Array object, its keys are formatted as a comma-separated list of $[SQL Names]\r\n     *\r\n     * Passing in an empty array/object will throw {@link external:Error Error} = `Cannot retrieve sql names from an empty array/object.`\r\n     *\r\n     * @returns {string}\r\n     * The SQL Name/Identifier, properly escaped for compliance with the PostgreSQL standard for $[SQL Names] and identifiers.\r\n     *\r\n     * @see\r\n     * {@link formatting.alias alias},\r\n     * {@link formatting.format format}\r\n     *\r\n     * @example\r\n     *\r\n     * // automatically list object properties as sql names:\r\n     * format('INSERT INTO table(${this~}) VALUES(${one}, ${two})', {\r\n     *     one: 1,\r\n     *     two: 2\r\n     * });\r\n     * //=> INSERT INTO table(\"one\",\"two\") VALUES(1, 2)\r\n     *\r\n     */\r\n    name(name) {\r\n        name = resolveFunc(name);\r\n        if (name) {\r\n            if (typeof name === 'string') {\r\n                return /^\\s*\\*(\\s*)$/.test(name) ? name : formatSqlName(name);\r\n            }\r\n            if (typeof name === 'object') {\r\n                const keys = Array.isArray(name) ? name : Object.keys(name);\r\n                if (!keys.length) {\r\n                    throw new Error('Cannot retrieve sql names from an empty array/object.');\r\n                }\r\n                return keys.map(value => {\r\n                    if (!value || typeof value !== 'string') {\r\n                        throw new Error(`Invalid sql name: ${npm.utils.toJson(value)}`);\r\n                    }\r\n                    return formatSqlName(value);\r\n                }).join();\r\n            }\r\n        }\r\n        throw new TypeError(`Invalid sql name: ${npm.utils.toJson(name)}`);\r\n    },\r\n\r\n    /**\r\n     * @method formatting.alias\r\n     * @description\r\n     * Simpler (non-verbose) version of method {@link formatting.name name}, to handle only a regular string-identifier\r\n     * that's mostly used as an SQL alias, i.e. it doesn't support `*` or an array/object of names, which in the context of\r\n     * an SQL alias would be incorrect. However, it supports `.` as name-separator, for simpler escaping of composite names.\r\n     *\r\n     * The surrounding double quotes are not added when the alias uses a simple syntax:\r\n     *  - it is a same-case single word, without spaces\r\n     *  - it can contain underscores, and can even start with them\r\n     *  - it can contain digits and `$`, but cannot start with those\r\n     *\r\n     * The method will automatically split the string with `.`, to support composite SQL names.\r\n     *\r\n     * When formatting a query, a variable makes use of this method via modifier `:alias`. See method {@link formatting.format format}.\r\n     *\r\n     * @param {string|function} name\r\n     * SQL alias name, or a function that returns it.\r\n     *\r\n     * The name must be at least 1 character long. And it can contain `.`, to split into multiple SQL names.\r\n     *\r\n     * If `name` doesn't resolve into a non-empty string, it throws {@link external:TypeError TypeError} = `Invalid sql alias: ...`\r\n     *\r\n     * @returns {string}\r\n     * The SQL alias, properly escaped for compliance with the PostgreSQL standard for $[SQL Names] and identifiers.\r\n     *\r\n     * @see\r\n     * {@link formatting.name name},\r\n     * {@link formatting.format format}\r\n     *\r\n     */\r\n    alias(name) {\r\n        name = resolveFunc(name);\r\n        if (name && typeof name === 'string') {\r\n            return name.split('.')\r\n                .filter(f => f)\r\n                .map(a => {\r\n                    const m = a.match(/^([a-z_][a-z0-9_$]*|[A-Z_][A-Z0-9_$]*)$/);\r\n                    if (m && m[0] === a) {\r\n                        return a;\r\n                    }\r\n                    return `\"${a.replace(/\"/g, '\"\"')}\"`;\r\n                }).join('.');\r\n        }\r\n        throw new TypeError(`Invalid sql alias: ${npm.utils.toJson(name)}`);\r\n    },\r\n\r\n    /**\r\n     * @method formatting.value\r\n     * @description\r\n     * Represents an open value, one to be formatted according to its type, properly escaped, but without surrounding quotes for text types.\r\n     *\r\n     * When formatting a query, a variable makes use of this method via modifier `:value` or `#`. See method {@link formatting.format format}.\r\n     *\r\n     * @param {value|function} value\r\n     * Value to be converted, or a function that returns the value.\r\n     *\r\n     * If `value` resolves as `null` or `undefined`, it will throw {@link external:TypeError TypeError} = `Open values cannot be null or undefined.`\r\n     *\r\n     * @returns {string}\r\n     * Formatted and properly escaped string, but without surrounding quotes for text types.\r\n     *\r\n     * @see {@link formatting.format format}\r\n     *\r\n     */\r\n    value(value) {\r\n        value = resolveFunc(value);\r\n        if (isNull(value)) {\r\n            throw new TypeError('Open values cannot be null or undefined.');\r\n        }\r\n        return safeText(formatValue({value, fm: fmFlags.raw}));\r\n    },\r\n\r\n    /**\r\n     * @method formatting.buffer\r\n     * @description\r\n     * Converts an object of type `Buffer` into a hex string compatible with PostgreSQL type `bytea`.\r\n     *\r\n     * @param {Buffer|function} obj\r\n     * Object to be converted, or a function that returns one.\r\n     *\r\n     * @param {boolean} [raw=false]\r\n     * Indicates when not to wrap the resulting string in quotes.\r\n     *\r\n     * The generated hex string doesn't need to be escaped.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    buffer(obj, raw) {\r\n        obj = resolveFunc(obj);\r\n        if (isNull(obj)) {\r\n            throwIfRaw(raw);\r\n            return 'null';\r\n        }\r\n        if (obj instanceof Buffer) {\r\n            return $to.buffer(obj, raw);\r\n        }\r\n        throw new TypeError(`${wrapText(obj)} is not a Buffer object.`);\r\n    },\r\n\r\n    /**\r\n     * @method formatting.bool\r\n     * @description\r\n     * Converts a truthy value into PostgreSQL boolean presentation.\r\n     *\r\n     * @param {boolean|function} value\r\n     * Value to be converted, or a function that returns the value.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    bool(value) {\r\n        value = resolveFunc(value);\r\n        if (isNull(value)) {\r\n            return 'null';\r\n        }\r\n        return $to.bool(value);\r\n    },\r\n\r\n    /**\r\n     * @method formatting.date\r\n     * @description\r\n     * Converts a `Date`-type value into PostgreSQL date/time presentation,\r\n     * wrapped in quotes (unless flag `raw` is set).\r\n     *\r\n     * @param {Date|function} d\r\n     * Date object to be converted, or a function that returns one.\r\n     *\r\n     * @param {boolean} [raw=false]\r\n     * Indicates when not to escape the value.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    date(d, raw) {\r\n        d = resolveFunc(d);\r\n        if (isNull(d)) {\r\n            throwIfRaw(raw);\r\n            return 'null';\r\n        }\r\n        if (d instanceof Date) {\r\n            return $to.date(d, raw);\r\n        }\r\n        throw new TypeError(`${wrapText(d)} is not a Date object.`);\r\n    },\r\n\r\n    /**\r\n     * @method formatting.number\r\n     * @description\r\n     * Converts a numeric value into its PostgreSQL number presentation, with support\r\n     * for special values of `NaN`, `+Infinity` and `-Infinity`.\r\n     *\r\n     * @param {number|bigint|function} num\r\n     * Number to be converted, or a function that returns one.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    number(num) {\r\n        num = resolveFunc(num);\r\n        if (isNull(num)) {\r\n            return 'null';\r\n        }\r\n        const t = typeof num;\r\n        if (t !== 'number' && t !== 'bigint') {\r\n            throw new TypeError(`${wrapText(num)} is not a number.`);\r\n        }\r\n        return $to.number(num);\r\n    },\r\n\r\n    /**\r\n     * @method formatting.array\r\n     * @description\r\n     * Converts an array of values into its PostgreSQL presentation as an Array-Type constructor string: `array[]`.\r\n     *\r\n     * Top-level empty arrays are formatted as literal `{}`, to avoid the necessity of explicit type casting,\r\n     * as the server cannot automatically infer type of empty non-literal array.\r\n     *\r\n     * @param {Array|function} arr\r\n     * Array to be converted, or a function that returns one.\r\n     *\r\n     * @param {{}} [options]\r\n     * Array-Formatting Options.\r\n     *\r\n     * @param {boolean} [options.capSQL=false]\r\n     * When `true`, outputs `ARRAY` instead of `array`.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    array(arr, options) {\r\n        options = assert(options, ['capSQL']);\r\n        arr = resolveFunc(arr);\r\n        if (isNull(arr)) {\r\n            return 'null';\r\n        }\r\n        if (Array.isArray(arr)) {\r\n            return $to.array(arr, options);\r\n        }\r\n        throw new TypeError(`${wrapText(arr)} is not an Array object.`);\r\n    },\r\n\r\n    /**\r\n     * @method formatting.csv\r\n     * @description\r\n     * Converts a single value or an array of values into a CSV (comma-separated values) string, with all values formatted\r\n     * according to their JavaScript type.\r\n     *\r\n     * When formatting a query, a variable makes use of this method via modifier `:csv` or its alias `:list`.\r\n     *\r\n     * When `values` is an object that's not `null` or `Array`, its properties are enumerated for the actual values.\r\n     *\r\n     * @param {Array|Object|value|function} values\r\n     * Value(s) to be converted, or a function that returns it.\r\n     *\r\n     * @returns {string}\r\n     *\r\n     * @see {@link formatting.format format}\r\n     */\r\n    csv(values) {\r\n        return $to.csv(values);\r\n    },\r\n\r\n    /**\r\n     * @method formatting.json\r\n     * @description\r\n     * Converts any value into JSON (includes `BigInt` support), and returns it as a valid string,\r\n     * with single-quote symbols fixed, unless flag `raw` is set.\r\n     *\r\n     * When formatting a query, a variable makes use of this method via modifier `:json`. See method {@link formatting.format format}.\r\n     *\r\n     * @param {*} data\r\n     * Object/value to be converted, or a function that returns it.\r\n     *\r\n     * @param {boolean} [raw=false]\r\n     * Indicates when not to escape the result.\r\n     *\r\n     * @returns {string}\r\n     *\r\n     * @see {@link formatting.format format}\r\n     */\r\n    json(data, raw) {\r\n        data = resolveFunc(data);\r\n        if (isNull(data)) {\r\n            throwIfRaw(raw);\r\n            return 'null';\r\n        }\r\n        return $to.json(data, raw);\r\n    },\r\n\r\n    /**\r\n     * @method formatting.func\r\n     * @description\r\n     * Calls the function to get the actual value, and then formats the result according to its type + `raw` flag.\r\n     *\r\n     * @param {function} func\r\n     * Function to be called, with support for nesting.\r\n     *\r\n     * @param {boolean} [raw=false]\r\n     * Indicates when not to escape the result.\r\n     *\r\n     * @param {*} [cc]\r\n     * Calling Context: `this` + the only value to be passed into the function on all nested levels.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    func(func, raw, cc) {\r\n        if (isNull(func)) {\r\n            throwIfRaw(raw);\r\n            return 'null';\r\n        }\r\n        if (typeof func !== 'function') {\r\n            throw new TypeError(`${wrapText(func)} is not a function.`);\r\n        }\r\n        const fm = raw ? fmFlags.raw : null;\r\n        return formatValue({value: resolveFunc(func, cc), fm, cc});\r\n    },\r\n\r\n    /**\r\n     * @method formatting.format\r\n     * @description\r\n     * Replaces variables in a string according to the type of `values`:\r\n     *\r\n     * - Replaces `$1` occurrences when `values` is of type `string`, `boolean`, `number`, `bigint`, `Date`, `Buffer` or when it is `null`.\r\n     *\r\n     * - Replaces variables `$1`, `$2`, ...`$100000` when `values` is an array of parameters. It throws a {@link external:RangeError RangeError}\r\n     * when the values or variables are out of range.\r\n     *\r\n     * - Replaces `$*propName*`, where `*` is any of `{}`, `()`, `[]`, `<>`, `//`, when `values` is an object that's not a\r\n     * `Date`, `Buffer`, {@link QueryFile} or `null`. Special property name `this` refers to the formatting object itself,\r\n     *   to be injected as a JSON string. When referencing a property that doesn't exist in the formatting object, it throws\r\n     *   {@link external:Error Error} = `Property 'PropName' doesn't exist`, unless option `partial` is used.\r\n     *\r\n     * - Supports $[Nested Named Parameters] of any depth.\r\n     *\r\n     * By default, each variable is automatically formatted according to its type, unless it is a special variable:\r\n     *\r\n     * - Raw-text variables end with `:raw` or symbol `^`, and prevent escaping the text. Such variables are not\r\n     *   allowed to be `null` or `undefined`, or the method will throw {@link external:TypeError TypeError} = `Values null/undefined cannot be used as raw text.`\r\n     *   - `$1:raw`, `$2:raw`,..., and `$*propName:raw*` (see `*` above)\r\n     *   - `$1^`, `$2^`,..., and `$*propName^*` (see `*` above)\r\n     *\r\n     * - Open-value variables end with `:value` or symbol `#`, to be escaped, but not wrapped in quotes. Such variables are\r\n     *   not allowed to be `null` or `undefined`, or the method will throw {@link external:TypeError TypeError} = `Open values cannot be null or undefined.`\r\n     *   - `$1:value`, `$2:value`,..., and `$*propName:value*` (see `*` above)\r\n     *   - `$1#`, `$2#`,..., and `$*propName#*` (see `*` above)\r\n     *\r\n     * - SQL name variables end with `:name` or symbol `~` (tilde), and provide proper escaping for SQL names/identifiers:\r\n     *   - `$1:name`, `$2:name`,..., and `$*propName:name*` (see `*` above)\r\n     *   - `$1~`, `$2~`,..., and `$*propName~*` (see `*` above)\r\n     *\r\n     * - Modifier `:alias` - non-verbose $[SQL Names] escaping.\r\n     *\r\n     * - JSON override ends with `:json` to format the value of any type as a JSON string\r\n     *\r\n     * - CSV override ends with `:csv` or `:list` to format an array as a properly escaped comma-separated list of values.\r\n     *\r\n     * @param {string|QueryFile|object} query\r\n     * A query string, a {@link QueryFile} or any object that implements $[Custom Type Formatting], to be formatted according to `values`.\r\n     *\r\n     * @param {array|object|value} [values]\r\n     * Formatting parameter(s) / variable value(s).\r\n     *\r\n     * @param {{}} [options]\r\n     * Formatting Options.\r\n     *\r\n     * @param {boolean} [options.capSQL=false]\r\n     * Formats reserved SQL words capitalized. Presently, this only concerns arrays, to output `ARRAY` when required.\r\n     *\r\n     * @param {boolean} [options.partial=false]\r\n     * Indicates that we intend to do only a partial replacement, i.e. throw no error when encountering a variable or\r\n     * property name that's missing within the formatting parameters.\r\n     *\r\n     * **NOTE:** This option has no meaning when option `def` is used.\r\n     *\r\n     * @param {*} [options.def]\r\n     * Sets default value for every variable that's missing, consequently preventing errors when encountering a variable\r\n     * or property name that's missing within the formatting parameters.\r\n     *\r\n     * It can also be set to a function, to be called with two parameters that depend on the type of formatting being used,\r\n     * and to return the actual default value:\r\n     *\r\n     * - For $[Named Parameters] formatting:\r\n     *   - `name` - name of the property missing in the formatting object\r\n     *   - `obj` - the formatting object, and is the same as `this` context\r\n     *\r\n     * - For $[Index Variables] formatting:\r\n     *   - `index` - element's index (starts with 1) that's outside of the input array\r\n     *   - `arr` - the formatting/input array, and is the same as `this` context\r\n     *\r\n     *   You can tell which type of call it is by checking the type of the first parameter.\r\n     *\r\n     * @returns {string}\r\n     * Formatted query string.\r\n     *\r\n     * The function will throw an error, if any occurs during formatting.\r\n     */\r\n    format(query, values, options) {\r\n        options = assert(options, ['capSQL', 'partial', 'def']);\r\n        const ctf = getCTF(query);\r\n        if (ctf) {\r\n            query = ctf.toPostgres.call(query, query);\r\n        }\r\n        return formatQuery(query, values, false, options);\r\n    }\r\n};\r\n\r\n/* Pre-parsed type formatting */\r\nconst $to = {\r\n    array(arr, options) {\r\n        return formatArray(arr, options);\r\n    },\r\n    csv(values, options) {\r\n        return formatCSV(resolveFunc(values), options);\r\n    },\r\n    bool(value) {\r\n        return value ? 'true' : 'false';\r\n    },\r\n    buffer(obj, raw) {\r\n        const s = `\\\\x${obj.toString('hex')}`;\r\n        return raw ? s : wrapText(s);\r\n    },\r\n    date(d, raw) {\r\n        const s = npm.pgUtils.prepareValue(d);\r\n        return raw ? s : wrapText(s);\r\n    },\r\n    json(data, raw) {\r\n        const s = npm.utils.toJson(data);\r\n        return raw ? s : wrapText(safeText(s));\r\n    },\r\n    number(num) {\r\n        if (typeof num === 'bigint' || Number.isFinite(num)) {\r\n            return num.toString();\r\n        }\r\n        // Converting NaN/+Infinity/-Infinity according to Postgres documentation:\r\n        // http://www.postgresql.org/docs/9.6/static/datatype-numeric.html#DATATYPE-FLOAT\r\n        //\r\n        // NOTE: strings for 'NaN'/'+Infinity'/'-Infinity' are not case-sensitive.\r\n        if (num === Number.POSITIVE_INFINITY) {\r\n            return wrapText('+Infinity');\r\n        }\r\n        if (num === Number.NEGATIVE_INFINITY) {\r\n            return wrapText('-Infinity');\r\n        }\r\n        return wrapText('NaN');\r\n    },\r\n    text(value, raw) {\r\n        return raw ? value : wrapText(safeText(value));\r\n    }\r\n};\r\n\r\nmodule.exports = {\r\n    formatQuery,\r\n    formatEntity,\r\n    resolveFunc,\r\n    as: $as\r\n};\r\n\r\n/**\r\n * @external Error\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\r\n */\r\n\r\n/**\r\n * @external TypeError\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError\r\n */\r\n\r\n/**\r\n * @external RangeError\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError\r\n */\r\n\r\n/**\r\n * @external Symbol\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol\r\n */\r\n"],"mappings":"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AAM,CAAC,CAAE,GAAE;AAC3E;AAEA,SAAS0C,aAAaA,CAACpF,IAAI,EAAE;EACzB,OAAQ,IAAGA,IAAI,CAACsD,OAAO,CAAC,IAAI,EAAE,IAAI,CAAE,GAAE;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMnC,GAAG,GAAG;EAER;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIH,GAAG,EAAEX,UAAU;EAEf;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIkB,IAAIA,CAACpB,KAAK,EAAEL,GAAG,EAAE;IACbK,KAAK,GAAGY,WAAW,CAACZ,KAAK,CAAC;IAC1B,IAAIkB,MAAM,CAAClB,KAAK,CAAC,EAAE;MACfmB,UAAU,CAACxB,GAAG,CAAC;MACf,OAAO,MAAM;IACjB;IACA,IAAI,OAAOK,KAAK,KAAK,QAAQ,EAAE;MAC3BA,KAAK,GAAGA,KAAK,CAACwB,QAAQ,CAAC,CAAC;IAC5B;IACA,OAAOP,GAAG,CAACG,IAAI,CAACpB,KAAK,EAAEL,GAAG,CAAC;EAC/B,CAAC;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAC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"},"metadata":{},"sourceType":"script","externalDependencies":[]}