{"ast":null,"code":"/**\r\n * @method stream.read\r\n * @description\r\n * Consumes and processes data from a $[Readable] stream.\r\n *\r\n * It reads the entire stream, using either **paused mode** (default), or in chunks (see `options.readChunks`)\r\n * with support for both synchronous and asynchronous data processing.\r\n *\r\n * **NOTE:** Once the method has finished, the onus is on the caller to release the stream\r\n * according to its protocol.\r\n *\r\n * @param {Object} stream\r\n * $[Readable] stream object.\r\n *\r\n * Passing in anything else will throw `Readable stream is required.`\r\n *\r\n * @param {Function|generator} receiver\r\n * Data processing callback (or generator).\r\n *\r\n * Passing in anything else will throw `Invalid stream receiver.`\r\n *\r\n * Parameters:\r\n *  - `index` = index of the call made to the function\r\n *  - `data` = array of all data reads from the stream's buffer\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function is called with the same `this` context as the calling method.\r\n *\r\n * It can optionally return a promise object, if data processing is asynchronous.\r\n * And if a promise is returned, the method will not read data from the stream again,\r\n * until the promise has been resolved.\r\n *\r\n * If the function throws an error or returns a rejected promise, the method rejects\r\n * with the same error / rejection reason.\r\n *\r\n * @param {Object} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {Boolean} [options.closable=false]\r\n * Instructs the method to resolve on event `close` supported by the stream, as opposed to event\r\n * `end` that's used by default.\r\n *\r\n * @param {Boolean} [options.readChunks=false]\r\n * By default, the method handles event `readable` of the stream to consume data in a simplified form,\r\n * item by item. If you enable this option, the method will instead handle event `data` of the stream,\r\n * to consume chunks of data.\r\n *\r\n * @param {Number} [options.readSize]\r\n * When the value is greater than 0, it sets the read size from the stream's buffer\r\n * when the next data is available. By default, the method uses as few reads as possible\r\n * to get all the data currently available in the buffer.\r\n *\r\n * NOTE: This option is ignored when option `readChunks` is enabled.\r\n *\r\n * @returns {external:Promise}\r\n *\r\n * When finished successfully, resolves with object `{calls, reads, length, duration}`:\r\n *  - `calls` = number of calls made into the `receiver`\r\n *  - `reads` = number of successful reads from the stream\r\n *  - `length` = total length for all the data reads from the stream\r\n *  - `duration` = number of milliseconds consumed by the method\r\n *\r\n * When it fails, the method rejects with the error/reject specified,\r\n * which can happen as a result of:\r\n *  - event `error` emitted by the stream\r\n *  - receiver throws an error or returns a rejected promise\r\n */\nfunction read(stream, receiver, options, config) {\n  const $p = config.promise,\n    utils = config.utils;\n  if (!utils.isReadableStream(stream)) {\n    return $p.reject(new TypeError('Readable stream is required.'));\n  }\n  if (typeof receiver !== 'function') {\n    return $p.reject(new TypeError('Invalid stream receiver.'));\n  }\n  receiver = utils.wrap(receiver);\n  options = options || {};\n  const readSize = options.readSize > 0 ? parseInt(options.readSize) : null,\n    self = this,\n    start = Date.now(),\n    receiveEvent = options.readChunks ? 'data' : 'readable';\n  let cbTime,\n    ready,\n    waiting,\n    stop,\n    reads = 0,\n    length = 0,\n    index = 0;\n  return $p((resolve, reject) => {\n    function onReceive(data) {\n      ready = true;\n      process(data);\n    }\n    function onEnd() {\n      if (!options.closable) {\n        success();\n      }\n    }\n    function onClose() {\n      success();\n    }\n    function onError(error) {\n      fail(error);\n    }\n    stream.on(receiveEvent, onReceive);\n    stream.on('end', onEnd);\n    stream.on('close', onClose);\n    stream.on('error', onError);\n    function process(data) {\n      if (!ready || stop || waiting) {\n        return;\n      }\n      ready = false;\n      let cache;\n      if (options.readChunks) {\n        cache = data;\n        // istanbul ignore else;\n        // we cannot test the else condition, as it requires a special broken stream interface.\n        if (!Array.isArray(cache)) {\n          cache = [cache];\n        }\n        length += cache.length;\n        reads++;\n      } else {\n        cache = [];\n        waiting = true;\n        let page;\n        do {\n          page = stream.read(readSize);\n          if (page) {\n            cache.push(page);\n            // istanbul ignore next: requires a unique stream that\n            // creates objects without property `length` defined.\n            length += page.length || 0;\n            reads++;\n          }\n        } while (page);\n        if (!cache.length) {\n          waiting = false;\n          return;\n        }\n      }\n      const cbNow = Date.now(),\n        cbDelay = index ? cbNow - cbTime : undefined;\n      let result;\n      cbTime = cbNow;\n      try {\n        result = receiver.call(self, index++, cache, cbDelay);\n      } catch (e) {\n        fail(e);\n        return;\n      }\n      if (utils.isPromise(result)) {\n        result.then(() => {\n          waiting = false;\n          process();\n          return null; // this dummy return is just to prevent Bluebird warnings;\n        }).catch(error => {\n          fail(error);\n        });\n      } else {\n        waiting = false;\n        process();\n      }\n    }\n    function success() {\n      cleanup();\n      resolve({\n        calls: index,\n        reads: reads,\n        length: length,\n        duration: Date.now() - start\n      });\n    }\n    function fail(error) {\n      stop = true;\n      cleanup();\n      reject(error);\n    }\n    function cleanup() {\n      stream.removeListener(receiveEvent, onReceive);\n      stream.removeListener('close', onClose);\n      stream.removeListener('error', onError);\n      stream.removeListener('end', onEnd);\n    }\n  });\n}\nmodule.exports = function (config) {\n  return function (stream, receiver, options) {\n    return read.call(this, stream, receiver, options, config);\n  };\n};","map":{"version":3,"names":["read","stream","receiver","options","config","$p","promise","utils","isReadableStream","reject","TypeError","wrap","readSize","parseInt","self","start","Date","now","receiveEvent","readChunks","cbTime","ready","waiting","stop","reads","length","index","resolve","onReceive","data","process","onEnd","closable","success","onClose","onError","error","fail","on","cache","Array","isArray","page","push","cbNow","cbDelay","undefined","result","call","e","isPromise","then","catch","cleanup","calls","duration","removeListener","module","exports"],"sources":["/Users/luna/Library/Mobile Documents/com~apple~CloudDocs/GitHub/paucamcal.github.io/AESP/node_modules/spex/lib/ext/stream/read.js"],"sourcesContent":["/**\r\n * @method stream.read\r\n * @description\r\n * Consumes and processes data from a $[Readable] stream.\r\n *\r\n * It reads the entire stream, using either **paused mode** (default), or in chunks (see `options.readChunks`)\r\n * with support for both synchronous and asynchronous data processing.\r\n *\r\n * **NOTE:** Once the method has finished, the onus is on the caller to release the stream\r\n * according to its protocol.\r\n *\r\n * @param {Object} stream\r\n * $[Readable] stream object.\r\n *\r\n * Passing in anything else will throw `Readable stream is required.`\r\n *\r\n * @param {Function|generator} receiver\r\n * Data processing callback (or generator).\r\n *\r\n * Passing in anything else will throw `Invalid stream receiver.`\r\n *\r\n * Parameters:\r\n *  - `index` = index of the call made to the function\r\n *  - `data` = array of all data reads from the stream's buffer\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function is called with the same `this` context as the calling method.\r\n *\r\n * It can optionally return a promise object, if data processing is asynchronous.\r\n * And if a promise is returned, the method will not read data from the stream again,\r\n * until the promise has been resolved.\r\n *\r\n * If the function throws an error or returns a rejected promise, the method rejects\r\n * with the same error / rejection reason.\r\n *\r\n * @param {Object} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {Boolean} [options.closable=false]\r\n * Instructs the method to resolve on event `close` supported by the stream, as opposed to event\r\n * `end` that's used by default.\r\n *\r\n * @param {Boolean} [options.readChunks=false]\r\n * By default, the method handles event `readable` of the stream to consume data in a simplified form,\r\n * item by item. If you enable this option, the method will instead handle event `data` of the stream,\r\n * to consume chunks of data.\r\n *\r\n * @param {Number} [options.readSize]\r\n * When the value is greater than 0, it sets the read size from the stream's buffer\r\n * when the next data is available. By default, the method uses as few reads as possible\r\n * to get all the data currently available in the buffer.\r\n *\r\n * NOTE: This option is ignored when option `readChunks` is enabled.\r\n *\r\n * @returns {external:Promise}\r\n *\r\n * When finished successfully, resolves with object `{calls, reads, length, duration}`:\r\n *  - `calls` = number of calls made into the `receiver`\r\n *  - `reads` = number of successful reads from the stream\r\n *  - `length` = total length for all the data reads from the stream\r\n *  - `duration` = number of milliseconds consumed by the method\r\n *\r\n * When it fails, the method rejects with the error/reject specified,\r\n * which can happen as a result of:\r\n *  - event `error` emitted by the stream\r\n *  - receiver throws an error or returns a rejected promise\r\n */\r\nfunction read(stream, receiver, options, config) {\r\n\r\n    const $p = config.promise, utils = config.utils;\r\n\r\n    if (!utils.isReadableStream(stream)) {\r\n        return $p.reject(new TypeError('Readable stream is required.'));\r\n    }\r\n\r\n    if (typeof receiver !== 'function') {\r\n        return $p.reject(new TypeError('Invalid stream receiver.'));\r\n    }\r\n\r\n    receiver = utils.wrap(receiver);\r\n\r\n    options = options || {};\r\n\r\n    const readSize = (options.readSize > 0) ? parseInt(options.readSize) : null,\r\n        self = this, start = Date.now(), receiveEvent = options.readChunks ? 'data' : 'readable';\r\n    let cbTime, ready, waiting, stop, reads = 0, length = 0, index = 0;\r\n\r\n    return $p((resolve, reject) => {\r\n\r\n        function onReceive(data) {\r\n            ready = true;\r\n            process(data);\r\n        }\r\n\r\n        function onEnd() {\r\n            if (!options.closable) {\r\n                success();\r\n            }\r\n        }\r\n\r\n        function onClose() {\r\n            success();\r\n        }\r\n\r\n        function onError(error) {\r\n            fail(error);\r\n        }\r\n\r\n        stream.on(receiveEvent, onReceive);\r\n        stream.on('end', onEnd);\r\n        stream.on('close', onClose);\r\n        stream.on('error', onError);\r\n\r\n        function process(data) {\r\n            if (!ready || stop || waiting) {\r\n                return;\r\n            }\r\n            ready = false;\r\n            let cache;\r\n            if (options.readChunks) {\r\n                cache = data;\r\n                // istanbul ignore else;\r\n                // we cannot test the else condition, as it requires a special broken stream interface.\r\n                if (!Array.isArray(cache)) {\r\n                    cache = [cache];\r\n                }\r\n                length += cache.length;\r\n                reads++;\r\n            } else {\r\n                cache = [];\r\n                waiting = true;\r\n                let page;\r\n                do {\r\n                    page = stream.read(readSize);\r\n                    if (page) {\r\n                        cache.push(page);\r\n                        // istanbul ignore next: requires a unique stream that\r\n                        // creates objects without property `length` defined.\r\n                        length += page.length || 0;\r\n                        reads++;\r\n                    }\r\n                } while (page);\r\n\r\n                if (!cache.length) {\r\n                    waiting = false;\r\n                    return;\r\n                }\r\n            }\r\n\r\n            const cbNow = Date.now(),\r\n                cbDelay = index ? (cbNow - cbTime) : undefined;\r\n            let result;\r\n            cbTime = cbNow;\r\n            try {\r\n                result = receiver.call(self, index++, cache, cbDelay);\r\n            } catch (e) {\r\n                fail(e);\r\n                return;\r\n            }\r\n\r\n            if (utils.isPromise(result)) {\r\n                result\r\n                    .then(() => {\r\n                        waiting = false;\r\n                        process();\r\n                        return null; // this dummy return is just to prevent Bluebird warnings;\r\n                    })\r\n                    .catch(error => {\r\n                        fail(error);\r\n                    });\r\n            } else {\r\n                waiting = false;\r\n                process();\r\n            }\r\n        }\r\n\r\n        function success() {\r\n            cleanup();\r\n            resolve({\r\n                calls: index,\r\n                reads: reads,\r\n                length: length,\r\n                duration: Date.now() - start\r\n            });\r\n        }\r\n\r\n        function fail(error) {\r\n            stop = true;\r\n            cleanup();\r\n            reject(error);\r\n        }\r\n\r\n        function cleanup() {\r\n            stream.removeListener(receiveEvent, onReceive);\r\n            stream.removeListener('close', onClose);\r\n            stream.removeListener('error', onError);\r\n            stream.removeListener('end', onEnd);\r\n        }\r\n    });\r\n}\r\n\r\nmodule.exports = function (config) {\r\n    return function (stream, receiver, options) {\r\n        return read.call(this, stream, receiver, options, config);\r\n    };\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}