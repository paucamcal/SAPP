{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\n\nconst {\n  ServerFormatting\n} = require('./server-formatting');\nconst {\n  PreparedStatementError\n} = require('../errors');\nconst {\n  QueryFile\n} = require('../query-file');\nconst {\n  assert\n} = require('../assert');\nconst npm = {\n  EOL: require('os').EOL,\n  utils: require('../utils')\n};\n\n/**\r\n * @class PreparedStatement\r\n * @description\r\n * Constructs a new $[Prepared Statement] object. All properties can also be set after the object's construction.\r\n *\r\n * This type extends the basic `{name, text, values}` object, i.e. when the basic object is used\r\n * with a query method, a new {@link PreparedStatement} object is created in its place.\r\n *\r\n * The type can be used in place of the `query` parameter, with any query method directly.\r\n *\r\n * The type is available from the library's root: `pgp.PreparedStatement`.\r\n *\r\n * @param {Object} [options]\r\n * Object configuration options / properties.\r\n *\r\n * @param {string} [options.name] - See property {@link PreparedStatement#name name}.\r\n * @param {string|QueryFile} [options.text] - See property {@link PreparedStatement#text text}.\r\n * @param {array} [options.values] - See property {@link PreparedStatement#values values}.\r\n * @param {boolean} [options.binary] - See property {@link PreparedStatement#binary binary}.\r\n * @param {string} [options.rowMode] - See property {@link PreparedStatement#rowMode rowMode}.\r\n * @param {number} [options.rows] - See property {@link PreparedStatement#rows rows}.\r\n *\r\n * @returns {PreparedStatement}\r\n *\r\n * @see\r\n * {@link errors.PreparedStatementError PreparedStatementError},\r\n * {@link http://www.postgresql.org/docs/9.6/static/sql-prepare.html PostgreSQL Prepared Statements}\r\n *\r\n * @example\r\n *\r\n * const {PreparedStatement: PS} = require('pg-promise');\r\n *\r\n * // Creating a complete Prepared Statement with parameters:\r\n * const findUser = new PS({name: 'find-user', text: 'SELECT * FROM Users WHERE id = $1', values: [123]});\r\n *\r\n * db.one(findUser)\r\n *     .then(user => {\r\n *         // user found;\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n *\r\n * @example\r\n *\r\n * const {PreparedStatement: PS} = require('pg-promise');\r\n *\r\n * // Creating a reusable Prepared Statement without values:\r\n * const addUser = new PS({name: 'add-user', text: 'INSERT INTO Users(name, age) VALUES($1, $2)'});\r\n *\r\n * // setting values explicitly:\r\n * addUser.values = ['John', 30];\r\n *\r\n * db.none(addUser)\r\n *     .then(() => {\r\n *         // user added;\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n *\r\n * // setting values implicitly, by passing them into the query method:\r\n * db.none(addUser, ['Mike', 25])\r\n *     .then(() => {\r\n *         // user added;\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n */\nclass PreparedStatement extends ServerFormatting {\n  constructor(options) {\n    options = assert(options, ['name', 'text', 'values', 'binary', 'rowMode', 'rows']);\n    super(options);\n  }\n\n  /**\r\n   * @name PreparedStatement#name\r\n   * @type {string}\r\n   * @description\r\n   * An arbitrary name given to this particular prepared statement. It must be unique within a single session and is\r\n   * subsequently used to execute or deallocate a previously prepared statement.\r\n   */\n  get name() {\n    return this._inner.options.name;\n  }\n  set name(value) {\n    const _i = this._inner;\n    if (value !== _i.options.name) {\n      _i.options.name = value;\n      _i.changed = true;\n    }\n  }\n\n  /**\r\n   * @name PreparedStatement#rows\r\n   * @type {number}\r\n   * @description\r\n   * Number of rows to return at a time from a Prepared Statement's portal.\r\n   * The default is 0, which means that all rows must be returned at once.\r\n   */\n  get rows() {\n    return this._inner.options.rows;\n  }\n  set rows(value) {\n    const _i = this._inner;\n    if (value !== _i.options.rows) {\n      _i.options.rows = value;\n      _i.changed = true;\n    }\n  }\n}\n\n/**\r\n * @method PreparedStatement#parse\r\n * @description\r\n * Parses the current object and returns a simple `{name, text, values}`, if successful,\r\n * or else it returns a {@link errors.PreparedStatementError PreparedStatementError} object.\r\n *\r\n * This method is primarily for internal use by the library.\r\n *\r\n * @returns {{name, text, values}|errors.PreparedStatementError}\r\n */\nPreparedStatement.prototype.parse = function () {\n  const _i = this._inner,\n    options = _i.options;\n  const qf = options.text instanceof QueryFile ? options.text : null;\n  if (!_i.changed && !qf) {\n    return _i.target;\n  }\n  const errors = [],\n    values = _i.target.values;\n  _i.target = {\n    name: options.name,\n    text: options.text\n  };\n  _i.changed = true;\n  _i.currentError = undefined;\n  if (!npm.utils.isText(_i.target.name)) {\n    errors.push('Property \\'name\\' must be a non-empty text string.');\n  }\n  if (qf) {\n    qf.prepare();\n    if (qf.error) {\n      errors.push(qf.error);\n    } else {\n      _i.target.text = qf[QueryFile.$query];\n    }\n  }\n  if (!npm.utils.isText(_i.target.text)) {\n    errors.push('Property \\'text\\' must be a non-empty text string.');\n  }\n  if (!npm.utils.isNull(values)) {\n    _i.target.values = values;\n  }\n  if (options.binary !== undefined) {\n    _i.target.binary = !!options.binary;\n  }\n  if (options.rowMode !== undefined) {\n    _i.target.rowMode = options.rowMode;\n  }\n  if (options.rows !== undefined) {\n    _i.target.rows = options.rows;\n  }\n  if (errors.length) {\n    return _i.currentError = new PreparedStatementError(errors[0], _i.target);\n  }\n  _i.changed = false;\n  return _i.target;\n};\n\n/**\r\n * @method PreparedStatement#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object's current state.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\nPreparedStatement.prototype.toString = function (level) {\n  level = level > 0 ? parseInt(level) : 0;\n  const gap = npm.utils.messageGap(level + 1);\n  const ps = this.parse();\n  const lines = ['PreparedStatement {', gap + 'name: ' + npm.utils.toJson(this.name)];\n  if (npm.utils.isText(ps.text)) {\n    lines.push(gap + 'text: \"' + ps.text + '\"');\n  }\n  if (this.values !== undefined) {\n    lines.push(gap + 'values: ' + npm.utils.toJson(this.values));\n  }\n  if (this.binary !== undefined) {\n    lines.push(gap + 'binary: ' + npm.utils.toJson(this.binary));\n  }\n  if (this.rowMode !== undefined) {\n    lines.push(gap + 'rowMode: ' + npm.utils.toJson(this.rowMode));\n  }\n  if (this.rows !== undefined) {\n    lines.push(gap + 'rows: ' + npm.utils.toJson(this.rows));\n  }\n  if (this.error) {\n    lines.push(gap + 'error: ' + this.error.toString(level + 1));\n  }\n  lines.push(npm.utils.messageGap(level) + '}');\n  return lines.join(npm.EOL);\n};\nmodule.exports = {\n  PreparedStatement\n};\n\n/**\r\n * @name PreparedStatement#text\r\n * @type {string|QueryFile}\r\n * @description\r\n * A non-empty query string or a {@link QueryFile} object.\r\n *\r\n * Only the basic variables (`$1`, `$2`, etc) can be used in the query, because $[Prepared Statements]\r\n * are formatted on the server side.\r\n *\r\n * Changing this property for the same {@link PreparedStatement#name name} will have no effect, because queries\r\n * for Prepared Statements are cached by the server, with {@link PreparedStatement#name name} being the cache key.\r\n */\n\n/**\r\n * @name PreparedStatement#values\r\n * @type {array}\r\n * @description\r\n * Query formatting parameters, depending on the type:\r\n *\r\n * - `null` / `undefined` means the query has no formatting parameters\r\n * - `Array` - it is an array of formatting parameters\r\n * - None of the above, means it is a single formatting value, which\r\n *   is then automatically wrapped into an array\r\n */\n\n/**\r\n * @name PreparedStatement#binary\r\n * @type {boolean}\r\n * @default undefined\r\n * @description\r\n * Activates binary result mode. The default is the text mode.\r\n *\r\n * @see {@link http://www.postgresql.org/docs/devel/static/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY Extended Query}\r\n */\n\n/**\r\n * @name PreparedStatement#rowMode\r\n * @type {string}\r\n * @default undefined\r\n * @description\r\n * Changes the way data arrives to the client, with only one value supported by $[pg]:\r\n *  - `array` will make all data rows arrive as arrays of values. By default, rows arrive as objects.\r\n */\n\n/**\r\n * @name PreparedStatement#error\r\n * @type {errors.PreparedStatementError}\r\n * @default undefined\r\n * @description\r\n * When in an error state, it is set to a {@link errors.PreparedStatementError PreparedStatementError} object. Otherwise, it is `undefined`.\r\n *\r\n * This property is primarily for internal use by the library.\r\n */","map":{"version":3,"names":["ServerFormatting","require","PreparedStatementError","QueryFile","assert","npm","EOL","utils","PreparedStatement","constructor","options","name","_inner","value","_i","changed","rows","prototype","parse","qf","text","target","errors","values","currentError","undefined","isText","push","prepare","error","$query","isNull","binary","rowMode","length","toString","level","parseInt","gap","messageGap","ps","lines","toJson","join","module","exports"],"sources":["/Users/luna/Library/Mobile Documents/com~apple~CloudDocs/GitHub/paucamcal.github.io/AESP/node_modules/pg-promise/lib/types/prepared-statement.js"],"sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {ServerFormatting} = require('./server-formatting');\r\nconst {PreparedStatementError} = require('../errors');\r\nconst {QueryFile} = require('../query-file');\r\nconst {assert} = require('../assert');\r\n\r\nconst npm = {\r\n    EOL: require('os').EOL,\r\n    utils: require('../utils')\r\n};\r\n\r\n/**\r\n * @class PreparedStatement\r\n * @description\r\n * Constructs a new $[Prepared Statement] object. All properties can also be set after the object's construction.\r\n *\r\n * This type extends the basic `{name, text, values}` object, i.e. when the basic object is used\r\n * with a query method, a new {@link PreparedStatement} object is created in its place.\r\n *\r\n * The type can be used in place of the `query` parameter, with any query method directly.\r\n *\r\n * The type is available from the library's root: `pgp.PreparedStatement`.\r\n *\r\n * @param {Object} [options]\r\n * Object configuration options / properties.\r\n *\r\n * @param {string} [options.name] - See property {@link PreparedStatement#name name}.\r\n * @param {string|QueryFile} [options.text] - See property {@link PreparedStatement#text text}.\r\n * @param {array} [options.values] - See property {@link PreparedStatement#values values}.\r\n * @param {boolean} [options.binary] - See property {@link PreparedStatement#binary binary}.\r\n * @param {string} [options.rowMode] - See property {@link PreparedStatement#rowMode rowMode}.\r\n * @param {number} [options.rows] - See property {@link PreparedStatement#rows rows}.\r\n *\r\n * @returns {PreparedStatement}\r\n *\r\n * @see\r\n * {@link errors.PreparedStatementError PreparedStatementError},\r\n * {@link http://www.postgresql.org/docs/9.6/static/sql-prepare.html PostgreSQL Prepared Statements}\r\n *\r\n * @example\r\n *\r\n * const {PreparedStatement: PS} = require('pg-promise');\r\n *\r\n * // Creating a complete Prepared Statement with parameters:\r\n * const findUser = new PS({name: 'find-user', text: 'SELECT * FROM Users WHERE id = $1', values: [123]});\r\n *\r\n * db.one(findUser)\r\n *     .then(user => {\r\n *         // user found;\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n *\r\n * @example\r\n *\r\n * const {PreparedStatement: PS} = require('pg-promise');\r\n *\r\n * // Creating a reusable Prepared Statement without values:\r\n * const addUser = new PS({name: 'add-user', text: 'INSERT INTO Users(name, age) VALUES($1, $2)'});\r\n *\r\n * // setting values explicitly:\r\n * addUser.values = ['John', 30];\r\n *\r\n * db.none(addUser)\r\n *     .then(() => {\r\n *         // user added;\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n *\r\n * // setting values implicitly, by passing them into the query method:\r\n * db.none(addUser, ['Mike', 25])\r\n *     .then(() => {\r\n *         // user added;\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n */\r\nclass PreparedStatement extends ServerFormatting {\r\n    constructor(options) {\r\n        options = assert(options, ['name', 'text', 'values', 'binary', 'rowMode', 'rows']);\r\n        super(options);\r\n    }\r\n\r\n    /**\r\n     * @name PreparedStatement#name\r\n     * @type {string}\r\n     * @description\r\n     * An arbitrary name given to this particular prepared statement. It must be unique within a single session and is\r\n     * subsequently used to execute or deallocate a previously prepared statement.\r\n     */\r\n    get name() {\r\n        return this._inner.options.name;\r\n    }\r\n\r\n    set name(value) {\r\n        const _i = this._inner;\r\n        if (value !== _i.options.name) {\r\n            _i.options.name = value;\r\n            _i.changed = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @name PreparedStatement#rows\r\n     * @type {number}\r\n     * @description\r\n     * Number of rows to return at a time from a Prepared Statement's portal.\r\n     * The default is 0, which means that all rows must be returned at once.\r\n     */\r\n    get rows() {\r\n        return this._inner.options.rows;\r\n    }\r\n\r\n    set rows(value) {\r\n        const _i = this._inner;\r\n        if (value !== _i.options.rows) {\r\n            _i.options.rows = value;\r\n            _i.changed = true;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @method PreparedStatement#parse\r\n * @description\r\n * Parses the current object and returns a simple `{name, text, values}`, if successful,\r\n * or else it returns a {@link errors.PreparedStatementError PreparedStatementError} object.\r\n *\r\n * This method is primarily for internal use by the library.\r\n *\r\n * @returns {{name, text, values}|errors.PreparedStatementError}\r\n */\r\nPreparedStatement.prototype.parse = function () {\r\n\r\n    const _i = this._inner, options = _i.options;\r\n\r\n    const qf = options.text instanceof QueryFile ? options.text : null;\r\n\r\n    if (!_i.changed && !qf) {\r\n        return _i.target;\r\n    }\r\n\r\n    const errors = [], values = _i.target.values;\r\n    _i.target = {\r\n        name: options.name,\r\n        text: options.text\r\n    };\r\n    _i.changed = true;\r\n    _i.currentError = undefined;\r\n\r\n    if (!npm.utils.isText(_i.target.name)) {\r\n        errors.push('Property \\'name\\' must be a non-empty text string.');\r\n    }\r\n\r\n    if (qf) {\r\n        qf.prepare();\r\n        if (qf.error) {\r\n            errors.push(qf.error);\r\n        } else {\r\n            _i.target.text = qf[QueryFile.$query];\r\n        }\r\n    }\r\n    if (!npm.utils.isText(_i.target.text)) {\r\n        errors.push('Property \\'text\\' must be a non-empty text string.');\r\n    }\r\n\r\n    if (!npm.utils.isNull(values)) {\r\n        _i.target.values = values;\r\n    }\r\n\r\n    if (options.binary !== undefined) {\r\n        _i.target.binary = !!options.binary;\r\n    }\r\n\r\n    if (options.rowMode !== undefined) {\r\n        _i.target.rowMode = options.rowMode;\r\n    }\r\n\r\n    if (options.rows !== undefined) {\r\n        _i.target.rows = options.rows;\r\n    }\r\n\r\n    if (errors.length) {\r\n        return _i.currentError = new PreparedStatementError(errors[0], _i.target);\r\n    }\r\n\r\n    _i.changed = false;\r\n\r\n    return _i.target;\r\n};\r\n\r\n/**\r\n * @method PreparedStatement#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object's current state.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\r\nPreparedStatement.prototype.toString = function (level) {\r\n    level = level > 0 ? parseInt(level) : 0;\r\n    const gap = npm.utils.messageGap(level + 1);\r\n    const ps = this.parse();\r\n    const lines = [\r\n        'PreparedStatement {',\r\n        gap + 'name: ' + npm.utils.toJson(this.name)\r\n    ];\r\n    if (npm.utils.isText(ps.text)) {\r\n        lines.push(gap + 'text: \"' + ps.text + '\"');\r\n    }\r\n    if (this.values !== undefined) {\r\n        lines.push(gap + 'values: ' + npm.utils.toJson(this.values));\r\n    }\r\n    if (this.binary !== undefined) {\r\n        lines.push(gap + 'binary: ' + npm.utils.toJson(this.binary));\r\n    }\r\n    if (this.rowMode !== undefined) {\r\n        lines.push(gap + 'rowMode: ' + npm.utils.toJson(this.rowMode));\r\n    }\r\n    if (this.rows !== undefined) {\r\n        lines.push(gap + 'rows: ' + npm.utils.toJson(this.rows));\r\n    }\r\n    if (this.error) {\r\n        lines.push(gap + 'error: ' + this.error.toString(level + 1));\r\n    }\r\n    lines.push(npm.utils.messageGap(level) + '}');\r\n    return lines.join(npm.EOL);\r\n};\r\n\r\nmodule.exports = {PreparedStatement};\r\n\r\n/**\r\n * @name PreparedStatement#text\r\n * @type {string|QueryFile}\r\n * @description\r\n * A non-empty query string or a {@link QueryFile} object.\r\n *\r\n * Only the basic variables (`$1`, `$2`, etc) can be used in the query, because $[Prepared Statements]\r\n * are formatted on the server side.\r\n *\r\n * Changing this property for the same {@link PreparedStatement#name name} will have no effect, because queries\r\n * for Prepared Statements are cached by the server, with {@link PreparedStatement#name name} being the cache key.\r\n */\r\n\r\n/**\r\n * @name PreparedStatement#values\r\n * @type {array}\r\n * @description\r\n * Query formatting parameters, depending on the type:\r\n *\r\n * - `null` / `undefined` means the query has no formatting parameters\r\n * - `Array` - it is an array of formatting parameters\r\n * - None of the above, means it is a single formatting value, which\r\n *   is then automatically wrapped into an array\r\n */\r\n\r\n/**\r\n * @name PreparedStatement#binary\r\n * @type {boolean}\r\n * @default undefined\r\n * @description\r\n * Activates binary result mode. The default is the text mode.\r\n *\r\n * @see {@link http://www.postgresql.org/docs/devel/static/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY Extended Query}\r\n */\r\n\r\n/**\r\n * @name PreparedStatement#rowMode\r\n * @type {string}\r\n * @default undefined\r\n * @description\r\n * Changes the way data arrives to the client, with only one value supported by $[pg]:\r\n *  - `array` will make all data rows arrive as arrays of values. By default, rows arrive as objects.\r\n */\r\n\r\n/**\r\n * @name PreparedStatement#error\r\n * @type {errors.PreparedStatementError}\r\n * @default undefined\r\n * @description\r\n * When in an error state, it is set to a {@link errors.PreparedStatementError PreparedStatementError} object. Otherwise, it is `undefined`.\r\n *\r\n * This property is primarily for internal use by the library.\r\n */\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}