{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\n\nconst {\n  Events\n} = require('./events');\nconst npm = {\n  spex: require('spex'),\n  utils: require('./utils'),\n  mode: require('./tx-mode'),\n  query: require('./query'),\n  text: require('./text')\n};\n\n/**\r\n * @interface Task\r\n * @description\r\n * Extends {@link Database} for an automatic connection session, with methods for executing multiple database queries.\r\n *\r\n * The type isn't available directly, it can only be created via methods {@link Database#task Database.task}, {@link Database#tx Database.tx},\r\n * or their derivations.\r\n *\r\n * When executing more than one request at a time, one should allocate and release the connection only once,\r\n * while executing all the required queries within the same connection session. More importantly, a transaction\r\n * can only work within a single connection.\r\n *\r\n * This is an interface for tasks/transactions to implement a connection session, during which you can\r\n * execute multiple queries against the same connection that's released automatically when the task/transaction is finished.\r\n *\r\n * Each task/transaction manages the connection automatically. When executed on the root {@link Database} object, the connection\r\n * is allocated from the pool, and once the method's callback has finished, the connection is released back to the pool.\r\n * However, when invoked inside another task or transaction, the method reuses the parent connection.\r\n *\r\n * @see\r\n * {@link Task#ctx ctx},\r\n * {@link Task#batch batch},\r\n * {@link Task#sequence sequence},\r\n * {@link Task#page page}\r\n *\r\n * @example\r\n * db.task(t => {\r\n *       // t = task protocol context;\r\n *       // t.ctx = Task Context;\r\n *       return t.one('select * from users where id=$1', 123)\r\n *           .then(user => {\r\n *               return t.any('select * from events where login=$1', user.name);\r\n *           });\r\n *   })\r\n * .then(events => {\r\n *       // success;\r\n *   })\r\n * .catch(error => {\r\n *       // error;\r\n *   });\r\n *\r\n */\nfunction Task(ctx, tag, isTX, config) {\n  const $p = config.promise;\n\n  /**\r\n   * @member {TaskContext} Task#ctx\r\n   * @readonly\r\n   * @description\r\n   * Task/Transaction Context object - contains individual properties for each task/transaction.\r\n   *\r\n   * @see event {@link event:query query}\r\n   *\r\n   * @example\r\n   *\r\n   * db.task(t => {\r\n   *     return t.ctx; // task context object\r\n   * })\r\n   *     .then(ctx => {\r\n   *         console.log('Task Duration:', ctx.duration);\r\n   *     });\r\n   *\r\n   * @example\r\n   *\r\n   * db.tx(t => {\r\n   *     return t.ctx; // transaction context object\r\n   * })\r\n   *     .then(ctx => {\r\n   *         console.log('Transaction Duration:', ctx.duration);\r\n   *     });\r\n   */\n  this.ctx = ctx.ctx = {}; // task context object;\n\n  npm.utils.addReadProp(this.ctx, 'isTX', isTX);\n  if ('context' in ctx) {\n    npm.utils.addReadProp(this.ctx, 'context', ctx.context);\n  }\n  npm.utils.addReadProp(this.ctx, 'connected', !ctx.db);\n  npm.utils.addReadProp(this.ctx, 'tag', tag);\n  npm.utils.addReadProp(this.ctx, 'dc', ctx.dc);\n  npm.utils.addReadProp(this.ctx, 'level', ctx.level);\n  npm.utils.addReadProp(this.ctx, 'inTransaction', ctx.inTransaction);\n  if (isTX) {\n    npm.utils.addReadProp(this.ctx, 'txLevel', ctx.txLevel);\n  }\n  npm.utils.addReadProp(this.ctx, 'parent', ctx.parentCtx);\n\n  // generic query method;\n  this.query = function (query, values, qrm) {\n    if (!ctx.db) {\n      return $p.reject(new Error(npm.text.looseQuery));\n    }\n    return config.$npm.query.call(this, ctx, query, values, qrm);\n  };\n\n  /**\r\n   * @deprecated\r\n   * Consider using <b>async/await</b> syntax instead, or if you must have\r\n   * pre-generated promises, then $[Promise.allSettled].\r\n   *\r\n   * @method Task#batch\r\n   * @description\r\n   * Settles a predefined array of mixed values by redirecting to method $[spex.batch].\r\n   *\r\n   * For complete method documentation see $[spex.batch].\r\n   *\r\n   * @param {array} values\r\n   * @param {Object} [options]\r\n   * Optional Parameters.\r\n   * @param {function} [options.cb]\r\n   *\r\n   * @returns {external:Promise}\r\n   */\n  this.batch = function (values, options) {\n    return config.$npm.spex.batch.call(this, values, options);\n  };\n\n  /**\r\n   * @method Task#page\r\n   * @description\r\n   * Resolves a dynamic sequence of arrays/pages with mixed values, by redirecting to method $[spex.page].\r\n   *\r\n   * For complete method documentation see $[spex.page].\r\n   *\r\n   * @param {function} source\r\n   * @param {Object} [options]\r\n   * Optional Parameters.\r\n   * @param {function} [options.dest]\r\n   * @param {number} [options.limit=0]\r\n   *\r\n   * @returns {external:Promise}\r\n   */\n  this.page = function (source, options) {\n    return config.$npm.spex.page.call(this, source, options);\n  };\n\n  /**\r\n   * @method Task#sequence\r\n   * @description\r\n   * Resolves a dynamic sequence of mixed values by redirecting to method $[spex.sequence].\r\n   *\r\n   * For complete method documentation see $[spex.sequence].\r\n   *\r\n   * @param {function} source\r\n   * @param {Object} [options]\r\n   * Optional Parameters.\r\n   * @param {function} [options.dest]\r\n   * @param {number} [options.limit=0]\r\n   * @param {boolean} [options.track=false]\r\n   *\r\n   * @returns {external:Promise}\r\n   */\n  this.sequence = function (source, options) {\n    return config.$npm.spex.sequence.call(this, source, options);\n  };\n}\n\n/**\r\n * @private\r\n * @method Task.callback\r\n * Callback invocation helper.\r\n *\r\n * @param ctx\r\n * @param obj\r\n * @param cb\r\n * @param config\r\n * @returns {Promise.<TResult>}\r\n */\nconst callback = (ctx, obj, cb, config) => {\n  const $p = config.promise;\n  let result;\n  try {\n    if (cb.constructor.name === 'GeneratorFunction') {\n      // v9.0 dropped all support for ES6 generator functions;\n      // Clients should use the new ES7 async/await syntax.\n      throw new TypeError('ES6 generator functions are no longer supported!');\n    }\n    result = cb.call(obj, obj); // invoking the callback function;\n  } catch (err) {\n    Events.error(ctx.options, err, {\n      client: ctx.db && ctx.db.client,\n      // the error can be due to loss of connectivity\n      dc: ctx.dc,\n      ctx: ctx.ctx\n    });\n    return $p.reject(err); // reject with the error;\n  }\n\n  if (result && typeof result.then === 'function') {\n    return result; // result is a valid promise object;\n  }\n\n  return $p.resolve(result);\n};\n\n/**\r\n * @private\r\n * @method Task.execute\r\n * Executes a task.\r\n *\r\n * @param ctx\r\n * @param obj\r\n * @param isTX\r\n * @param config\r\n * @returns {Promise.<TResult>}\r\n */\nconst execute = (ctx, obj, isTX, config) => {\n  const $p = config.promise;\n\n  // updates the task context and notifies the client;\n  function update(start, success, result) {\n    const c = ctx.ctx;\n    if (start) {\n      npm.utils.addReadProp(c, 'start', new Date());\n    } else {\n      c.finish = new Date();\n      c.success = success;\n      c.result = result;\n      c.duration = c.finish - c.start;\n    }\n    (isTX ? Events.transact : Events.task)(ctx.options, {\n      client: ctx.db && ctx.db.client,\n      // loss of connectivity is possible at this point\n      dc: ctx.dc,\n      ctx: c\n    });\n  }\n  let cbData, cbReason, success, spName; // Save-Point Name;\n\n  const capSQL = ctx.options.capSQL; // capitalize sql;\n\n  update(true);\n  if (isTX) {\n    // executing a transaction;\n    spName = `sp_${ctx.txLevel}_${ctx.nextTxCount}`;\n    return begin().then(() => callback(ctx, obj, ctx.cb, config).then(data => {\n      cbData = data; // save callback data;\n      success = true;\n      return commit();\n    }, err => {\n      cbReason = err; // save callback failure reason;\n      return rollback();\n    }).then(() => {\n      if (success) {\n        update(false, true, cbData);\n        return cbData;\n      }\n      update(false, false, cbReason);\n      return $p.reject(cbReason);\n    }, err => {\n      // either COMMIT or ROLLBACK has failed, which is impossible\n      // to replicate in a test environment, so skipping from the test;\n      // istanbul ignore next:\n      update(false, false, err);\n      // istanbul ignore next:\n      return $p.reject(err);\n    }), err => {\n      // BEGIN has failed, which is impossible to replicate in a test\n      // environment, so skipping the whole block from the test;\n      // istanbul ignore next:\n      update(false, false, err);\n      // istanbul ignore next:\n      return $p.reject(err);\n    });\n  }\n  function begin() {\n    if (!ctx.txLevel && ctx.mode instanceof npm.mode.TransactionMode) {\n      return exec(ctx.mode.begin(capSQL), 'savepoint');\n    }\n    return exec('begin', 'savepoint');\n  }\n  function commit() {\n    return exec('commit', 'release savepoint');\n  }\n  function rollback() {\n    return exec('rollback', 'rollback to savepoint');\n  }\n  function exec(top, nested) {\n    if (ctx.txLevel) {\n      return obj.none((capSQL ? nested.toUpperCase() : nested) + ' ' + spName);\n    }\n    return obj.none(capSQL ? top.toUpperCase() : top);\n  }\n\n  // executing a task;\n  return callback(ctx, obj, ctx.cb, config).then(data => {\n    update(false, true, data);\n    return data;\n  }).catch(error => {\n    update(false, false, error);\n    return $p.reject(error);\n  });\n};\nmodule.exports = config => {\n  const npmLocal = config.$npm;\n\n  // istanbul ignore next:\n  // we keep 'npm.query' initialization here, even though it is always\n  // pre-initialized by the 'database' module, for integrity purpose.\n  npmLocal.query = npmLocal.query || npm.query(config);\n  npmLocal.spex = npmLocal.spex || npm.spex(config.promiseLib);\n  return {\n    Task,\n    execute,\n    callback\n  };\n};\n\n/**\r\n * @typedef TaskContext\r\n * @description\r\n * Task/Transaction Context used via property {@link Task#ctx ctx} inside tasks (methods {@link Database#task Database.task} and {@link Database#taskIf Database.taskIf})\r\n * and transactions (methods {@link Database#tx Database.tx} and {@link Database#txIf Database.txIf}).\r\n *\r\n * Properties `context`, `connected`, `parent`, `level`, `dc`, `isTX`, `tag`, `start`, `useCount` and `serverVersion` are set just before the operation has started,\r\n * while properties `finish`, `duration`, `success` and `result` are set immediately after the operation has finished.\r\n *\r\n * @property {*} context\r\n * If the operation was invoked with a calling context - `task.call(context,...)` or `tx.call(context,...)`,\r\n * this property is set with the context that was passed in. Otherwise, the property doesn't exist.\r\n *\r\n * @property {*} dc\r\n * _Database Context_ that was passed into the {@link Database} object during construction.\r\n *\r\n * @property {boolean} isTX\r\n * Indicates whether this operation is a transaction (as opposed to a regular task).\r\n *\r\n * @property {number} duration\r\n * Number of milliseconds consumed by the operation.\r\n *\r\n * Set after the operation has finished, it is simply a shortcut for `finish - start`.\r\n *\r\n * @property {number} level\r\n * Task nesting level, starting from 0, counting both regular tasks and transactions.\r\n *\r\n * @property {number} txLevel\r\n * Transaction nesting level, starting from 0. Transactions on level 0 use `BEGIN/COMMIT/ROLLBACK`,\r\n * while transactions on nested levels use the corresponding `SAVEPOINT` commands.\r\n *\r\n * This property exists only within the context of a transaction (`isTX = true`).\r\n *\r\n * @property {boolean} inTransaction\r\n * Available in both tasks and transactions, it simplifies checking when there is a transaction\r\n * going on either on this level or above.\r\n *\r\n * For example, when you want to check for a containing transaction while inside a task, and\r\n * only start a transaction when there is none yet.\r\n *\r\n * @property {TaskContext} parent\r\n * Parent task/transaction context, or `null` when it is top-level.\r\n *\r\n * @property {boolean} connected\r\n * Indicates when the task/transaction acquired the connection on its own (`connected = true`), and will release it once\r\n * the operation has finished. When the value is `false`, the operation is reusing an existing connection.\r\n *\r\n * @property {*} tag\r\n * Tag value as it was passed into the task. See methods {@link Database#task task} and {@link Database#tx tx}.\r\n *\r\n * @property {Date} start\r\n * Date/Time of when this operation started the execution.\r\n *\r\n * @property {number} useCount\r\n * Number of times the connection has been previously used, starting with 0 for a freshly\r\n * allocated physical connection.\r\n *\r\n * @property {string} serverVersion\r\n * Version of the PostgreSQL server to which we are connected.\r\n * Not available with $[Native Bindings].\r\n *\r\n * @property {Date} finish\r\n * Once the operation has finished, this property is set to the Data/Time of when it happened.\r\n *\r\n * @property {boolean} success\r\n * Once the operation has finished, this property indicates whether it was successful.\r\n *\r\n * @property {*} result\r\n * Once the operation has finished, this property contains the result, depending on property `success`:\r\n * - data resolved by the operation, if `success = true`\r\n * - error / rejection reason, if `success = false`\r\n *\r\n */","map":{"version":3,"names":["Events","require","npm","spex","utils","mode","query","text","Task","ctx","tag","isTX","config","$p","promise","addReadProp","context","db","dc","level","inTransaction","txLevel","parentCtx","values","qrm","reject","Error","looseQuery","$npm","call","batch","options","page","source","sequence","callback","obj","cb","result","constructor","name","TypeError","err","error","client","then","resolve","execute","update","start","success","c","Date","finish","duration","transact","task","cbData","cbReason","spName","capSQL","nextTxCount","begin","data","commit","rollback","TransactionMode","exec","top","nested","none","toUpperCase","catch","module","exports","npmLocal","promiseLib"],"sources":["/Users/luna/Library/Mobile Documents/com~apple~CloudDocs/GitHub/paucamcal.github.io/AESP/node_modules/pg-promise/lib/task.js"],"sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {Events} = require('./events');\r\n\r\nconst npm = {\r\n    spex: require('spex'),\r\n    utils: require('./utils'),\r\n    mode: require('./tx-mode'),\r\n    query: require('./query'),\r\n    text: require('./text')\r\n};\r\n\r\n/**\r\n * @interface Task\r\n * @description\r\n * Extends {@link Database} for an automatic connection session, with methods for executing multiple database queries.\r\n *\r\n * The type isn't available directly, it can only be created via methods {@link Database#task Database.task}, {@link Database#tx Database.tx},\r\n * or their derivations.\r\n *\r\n * When executing more than one request at a time, one should allocate and release the connection only once,\r\n * while executing all the required queries within the same connection session. More importantly, a transaction\r\n * can only work within a single connection.\r\n *\r\n * This is an interface for tasks/transactions to implement a connection session, during which you can\r\n * execute multiple queries against the same connection that's released automatically when the task/transaction is finished.\r\n *\r\n * Each task/transaction manages the connection automatically. When executed on the root {@link Database} object, the connection\r\n * is allocated from the pool, and once the method's callback has finished, the connection is released back to the pool.\r\n * However, when invoked inside another task or transaction, the method reuses the parent connection.\r\n *\r\n * @see\r\n * {@link Task#ctx ctx},\r\n * {@link Task#batch batch},\r\n * {@link Task#sequence sequence},\r\n * {@link Task#page page}\r\n *\r\n * @example\r\n * db.task(t => {\r\n *       // t = task protocol context;\r\n *       // t.ctx = Task Context;\r\n *       return t.one('select * from users where id=$1', 123)\r\n *           .then(user => {\r\n *               return t.any('select * from events where login=$1', user.name);\r\n *           });\r\n *   })\r\n * .then(events => {\r\n *       // success;\r\n *   })\r\n * .catch(error => {\r\n *       // error;\r\n *   });\r\n *\r\n */\r\nfunction Task(ctx, tag, isTX, config) {\r\n\r\n    const $p = config.promise;\r\n\r\n    /**\r\n     * @member {TaskContext} Task#ctx\r\n     * @readonly\r\n     * @description\r\n     * Task/Transaction Context object - contains individual properties for each task/transaction.\r\n     *\r\n     * @see event {@link event:query query}\r\n     *\r\n     * @example\r\n     *\r\n     * db.task(t => {\r\n     *     return t.ctx; // task context object\r\n     * })\r\n     *     .then(ctx => {\r\n     *         console.log('Task Duration:', ctx.duration);\r\n     *     });\r\n     *\r\n     * @example\r\n     *\r\n     * db.tx(t => {\r\n     *     return t.ctx; // transaction context object\r\n     * })\r\n     *     .then(ctx => {\r\n     *         console.log('Transaction Duration:', ctx.duration);\r\n     *     });\r\n     */\r\n    this.ctx = ctx.ctx = {}; // task context object;\r\n\r\n    npm.utils.addReadProp(this.ctx, 'isTX', isTX);\r\n\r\n    if ('context' in ctx) {\r\n        npm.utils.addReadProp(this.ctx, 'context', ctx.context);\r\n    }\r\n\r\n    npm.utils.addReadProp(this.ctx, 'connected', !ctx.db);\r\n    npm.utils.addReadProp(this.ctx, 'tag', tag);\r\n    npm.utils.addReadProp(this.ctx, 'dc', ctx.dc);\r\n    npm.utils.addReadProp(this.ctx, 'level', ctx.level);\r\n    npm.utils.addReadProp(this.ctx, 'inTransaction', ctx.inTransaction);\r\n\r\n    if (isTX) {\r\n        npm.utils.addReadProp(this.ctx, 'txLevel', ctx.txLevel);\r\n    }\r\n\r\n    npm.utils.addReadProp(this.ctx, 'parent', ctx.parentCtx);\r\n\r\n    // generic query method;\r\n    this.query = function (query, values, qrm) {\r\n        if (!ctx.db) {\r\n            return $p.reject(new Error(npm.text.looseQuery));\r\n        }\r\n        return config.$npm.query.call(this, ctx, query, values, qrm);\r\n    };\r\n\r\n    /**\r\n     * @deprecated\r\n     * Consider using <b>async/await</b> syntax instead, or if you must have\r\n     * pre-generated promises, then $[Promise.allSettled].\r\n     *\r\n     * @method Task#batch\r\n     * @description\r\n     * Settles a predefined array of mixed values by redirecting to method $[spex.batch].\r\n     *\r\n     * For complete method documentation see $[spex.batch].\r\n     *\r\n     * @param {array} values\r\n     * @param {Object} [options]\r\n     * Optional Parameters.\r\n     * @param {function} [options.cb]\r\n     *\r\n     * @returns {external:Promise}\r\n     */\r\n    this.batch = function (values, options) {\r\n        return config.$npm.spex.batch.call(this, values, options);\r\n    };\r\n\r\n    /**\r\n     * @method Task#page\r\n     * @description\r\n     * Resolves a dynamic sequence of arrays/pages with mixed values, by redirecting to method $[spex.page].\r\n     *\r\n     * For complete method documentation see $[spex.page].\r\n     *\r\n     * @param {function} source\r\n     * @param {Object} [options]\r\n     * Optional Parameters.\r\n     * @param {function} [options.dest]\r\n     * @param {number} [options.limit=0]\r\n     *\r\n     * @returns {external:Promise}\r\n     */\r\n    this.page = function (source, options) {\r\n        return config.$npm.spex.page.call(this, source, options);\r\n    };\r\n\r\n    /**\r\n     * @method Task#sequence\r\n     * @description\r\n     * Resolves a dynamic sequence of mixed values by redirecting to method $[spex.sequence].\r\n     *\r\n     * For complete method documentation see $[spex.sequence].\r\n     *\r\n     * @param {function} source\r\n     * @param {Object} [options]\r\n     * Optional Parameters.\r\n     * @param {function} [options.dest]\r\n     * @param {number} [options.limit=0]\r\n     * @param {boolean} [options.track=false]\r\n     *\r\n     * @returns {external:Promise}\r\n     */\r\n    this.sequence = function (source, options) {\r\n        return config.$npm.spex.sequence.call(this, source, options);\r\n    };\r\n\r\n}\r\n\r\n/**\r\n * @private\r\n * @method Task.callback\r\n * Callback invocation helper.\r\n *\r\n * @param ctx\r\n * @param obj\r\n * @param cb\r\n * @param config\r\n * @returns {Promise.<TResult>}\r\n */\r\nconst callback = (ctx, obj, cb, config) => {\r\n\r\n    const $p = config.promise;\r\n    let result;\r\n\r\n    try {\r\n        if (cb.constructor.name === 'GeneratorFunction') {\r\n            // v9.0 dropped all support for ES6 generator functions;\r\n            // Clients should use the new ES7 async/await syntax.\r\n            throw new TypeError('ES6 generator functions are no longer supported!');\r\n        }\r\n        result = cb.call(obj, obj); // invoking the callback function;\r\n    } catch (err) {\r\n        Events.error(ctx.options, err, {\r\n            client: ctx.db && ctx.db.client, // the error can be due to loss of connectivity\r\n            dc: ctx.dc,\r\n            ctx: ctx.ctx\r\n        });\r\n        return $p.reject(err); // reject with the error;\r\n    }\r\n    if (result && typeof result.then === 'function') {\r\n        return result; // result is a valid promise object;\r\n    }\r\n    return $p.resolve(result);\r\n};\r\n\r\n/**\r\n * @private\r\n * @method Task.execute\r\n * Executes a task.\r\n *\r\n * @param ctx\r\n * @param obj\r\n * @param isTX\r\n * @param config\r\n * @returns {Promise.<TResult>}\r\n */\r\nconst execute = (ctx, obj, isTX, config) => {\r\n\r\n    const $p = config.promise;\r\n\r\n    // updates the task context and notifies the client;\r\n    function update(start, success, result) {\r\n        const c = ctx.ctx;\r\n        if (start) {\r\n            npm.utils.addReadProp(c, 'start', new Date());\r\n        } else {\r\n            c.finish = new Date();\r\n            c.success = success;\r\n            c.result = result;\r\n            c.duration = c.finish - c.start;\r\n        }\r\n        (isTX ? Events.transact : Events.task)(ctx.options, {\r\n            client: ctx.db && ctx.db.client, // loss of connectivity is possible at this point\r\n            dc: ctx.dc,\r\n            ctx: c\r\n        });\r\n    }\r\n\r\n    let cbData, cbReason, success,\r\n        spName; // Save-Point Name;\r\n\r\n    const capSQL = ctx.options.capSQL; // capitalize sql;\r\n\r\n    update(true);\r\n\r\n    if (isTX) {\r\n        // executing a transaction;\r\n        spName = `sp_${ctx.txLevel}_${ctx.nextTxCount}`;\r\n        return begin()\r\n            .then(() => callback(ctx, obj, ctx.cb, config)\r\n                .then(data => {\r\n                    cbData = data; // save callback data;\r\n                    success = true;\r\n                    return commit();\r\n                }, err => {\r\n                    cbReason = err; // save callback failure reason;\r\n                    return rollback();\r\n                })\r\n                .then(() => {\r\n                    if (success) {\r\n                        update(false, true, cbData);\r\n                        return cbData;\r\n                    }\r\n                    update(false, false, cbReason);\r\n                    return $p.reject(cbReason);\r\n                },\r\n                err => {\r\n                    // either COMMIT or ROLLBACK has failed, which is impossible\r\n                    // to replicate in a test environment, so skipping from the test;\r\n                    // istanbul ignore next:\r\n                    update(false, false, err);\r\n                    // istanbul ignore next:\r\n                    return $p.reject(err);\r\n                }),\r\n            err => {\r\n                // BEGIN has failed, which is impossible to replicate in a test\r\n                // environment, so skipping the whole block from the test;\r\n                // istanbul ignore next:\r\n                update(false, false, err);\r\n                // istanbul ignore next:\r\n                return $p.reject(err);\r\n            });\r\n    }\r\n\r\n    function begin() {\r\n        if (!ctx.txLevel && ctx.mode instanceof npm.mode.TransactionMode) {\r\n            return exec(ctx.mode.begin(capSQL), 'savepoint');\r\n        }\r\n        return exec('begin', 'savepoint');\r\n    }\r\n\r\n    function commit() {\r\n        return exec('commit', 'release savepoint');\r\n    }\r\n\r\n    function rollback() {\r\n        return exec('rollback', 'rollback to savepoint');\r\n    }\r\n\r\n    function exec(top, nested) {\r\n        if (ctx.txLevel) {\r\n            return obj.none((capSQL ? nested.toUpperCase() : nested) + ' ' + spName);\r\n        }\r\n        return obj.none(capSQL ? top.toUpperCase() : top);\r\n    }\r\n\r\n    // executing a task;\r\n    return callback(ctx, obj, ctx.cb, config)\r\n        .then(data => {\r\n            update(false, true, data);\r\n            return data;\r\n        })\r\n        .catch(error => {\r\n            update(false, false, error);\r\n            return $p.reject(error);\r\n        });\r\n};\r\n\r\nmodule.exports = config => {\r\n    const npmLocal = config.$npm;\r\n\r\n    // istanbul ignore next:\r\n    // we keep 'npm.query' initialization here, even though it is always\r\n    // pre-initialized by the 'database' module, for integrity purpose.\r\n    npmLocal.query = npmLocal.query || npm.query(config);\r\n    npmLocal.spex = npmLocal.spex || npm.spex(config.promiseLib);\r\n\r\n    return {\r\n        Task, execute, callback\r\n    };\r\n};\r\n\r\n/**\r\n * @typedef TaskContext\r\n * @description\r\n * Task/Transaction Context used via property {@link Task#ctx ctx} inside tasks (methods {@link Database#task Database.task} and {@link Database#taskIf Database.taskIf})\r\n * and transactions (methods {@link Database#tx Database.tx} and {@link Database#txIf Database.txIf}).\r\n *\r\n * Properties `context`, `connected`, `parent`, `level`, `dc`, `isTX`, `tag`, `start`, `useCount` and `serverVersion` are set just before the operation has started,\r\n * while properties `finish`, `duration`, `success` and `result` are set immediately after the operation has finished.\r\n *\r\n * @property {*} context\r\n * If the operation was invoked with a calling context - `task.call(context,...)` or `tx.call(context,...)`,\r\n * this property is set with the context that was passed in. Otherwise, the property doesn't exist.\r\n *\r\n * @property {*} dc\r\n * _Database Context_ that was passed into the {@link Database} object during construction.\r\n *\r\n * @property {boolean} isTX\r\n * Indicates whether this operation is a transaction (as opposed to a regular task).\r\n *\r\n * @property {number} duration\r\n * Number of milliseconds consumed by the operation.\r\n *\r\n * Set after the operation has finished, it is simply a shortcut for `finish - start`.\r\n *\r\n * @property {number} level\r\n * Task nesting level, starting from 0, counting both regular tasks and transactions.\r\n *\r\n * @property {number} txLevel\r\n * Transaction nesting level, starting from 0. Transactions on level 0 use `BEGIN/COMMIT/ROLLBACK`,\r\n * while transactions on nested levels use the corresponding `SAVEPOINT` commands.\r\n *\r\n * This property exists only within the context of a transaction (`isTX = true`).\r\n *\r\n * @property {boolean} inTransaction\r\n * Available in both tasks and transactions, it simplifies checking when there is a transaction\r\n * going on either on this level or above.\r\n *\r\n * For example, when you want to check for a containing transaction while inside a task, and\r\n * only start a transaction when there is none yet.\r\n *\r\n * @property {TaskContext} parent\r\n * Parent task/transaction context, or `null` when it is top-level.\r\n *\r\n * @property {boolean} connected\r\n * Indicates when the task/transaction acquired the connection on its own (`connected = true`), and will release it once\r\n * the operation has finished. When the value is `false`, the operation is reusing an existing connection.\r\n *\r\n * @property {*} tag\r\n * Tag value as it was passed into the task. See methods {@link Database#task task} and {@link Database#tx tx}.\r\n *\r\n * @property {Date} start\r\n * Date/Time of when this operation started the execution.\r\n *\r\n * @property {number} useCount\r\n * Number of times the connection has been previously used, starting with 0 for a freshly\r\n * allocated physical connection.\r\n *\r\n * @property {string} serverVersion\r\n * Version of the PostgreSQL server to which we are connected.\r\n * Not available with $[Native Bindings].\r\n *\r\n * @property {Date} finish\r\n * Once the operation has finished, this property is set to the Data/Time of when it happened.\r\n *\r\n * @property {boolean} success\r\n * Once the operation has finished, this property indicates whether it was successful.\r\n *\r\n * @property {*} result\r\n * Once the operation has finished, this property contains the result, depending on property `success`:\r\n * - data resolved by the operation, if `success = true`\r\n * - error / rejection reason, if `success = false`\r\n *\r\n */\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM;EAACA;AAAM,CAAC,GAAGC,OAAO,CAAC,UAAU,CAAC;AAEpC,MAAMC,GAAG,GAAG;EACRC,IAAI,EAAEF,OAAO,CAAC,MAAM,CAAC;EACrBG,KAAK,EAAEH,OAAO,CAAC,SAAS,CAAC;EACzBI,IAAI,EAAEJ,OAAO,CAAC,WAAW,CAAC;EAC1BK,KAAK,EAAEL,OAAO,CAAC,SAAS,CAAC;EACzBM,IAAI,EAAEN,OAAO,CAAC,QAAQ;AAC1B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASO,IAAIA,CAACC,GAAG,EAAEC,GAAG,EAAEC,IAAI,EAAEC,MAAM,EAAE;EAElC,MAAMC,EAAE,GAAGD,MAAM,CAACE,OAAO;;EAEzB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACL,GAAG,GAAGA,GAAG,CAACA,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;;EAEzBP,GAAG,CAACE,KAAK,CAACW,WAAW,CAAC,IAAI,CAACN,GAAG,EAAE,MAAM,EAAEE,IAAI,CAAC;EAE7C,IAAI,SAAS,IAAIF,GAAG,EAAE;IAClBP,GAAG,CAACE,KAAK,CAACW,WAAW,CAAC,IAAI,CAACN,GAAG,EAAE,SAAS,EAAEA,GAAG,CAACO,OAAO,CAAC;EAC3D;EAEAd,GAAG,CAACE,KAAK,CAACW,WAAW,CAAC,IAAI,CAACN,GAAG,EAAE,WAAW,EAAE,CAACA,GAAG,CAACQ,EAAE,CAAC;EACrDf,GAAG,CAACE,KAAK,CAACW,WAAW,CAAC,IAAI,CAACN,GAAG,EAAE,KAAK,EAAEC,GAAG,CAAC;EAC3CR,GAAG,CAACE,KAAK,CAACW,WAAW,CAAC,IAAI,CAACN,GAAG,EAAE,IAAI,EAAEA,GAAG,CAACS,EAAE,CAAC;EAC7ChB,GAAG,CAACE,KAAK,CAACW,WAAW,CAAC,IAAI,CAACN,GAAG,EAAE,OAAO,EAAEA,GAAG,CAACU,KAAK,CAAC;EACnDjB,GAAG,CAACE,KAAK,CAACW,WAAW,CAAC,IAAI,CAACN,GAAG,EAAE,eAAe,EAAEA,GAAG,CAACW,aAAa,CAAC;EAEnE,IAAIT,IAAI,EAAE;IACNT,GAAG,CAACE,KAAK,CAACW,WAAW,CAAC,IAAI,CAACN,GAAG,EAAE,SAAS,EAAEA,GAAG,CAACY,OAAO,CAAC;EAC3D;EAEAnB,GAAG,CAACE,KAAK,CAACW,WAAW,CAAC,IAAI,CAACN,GAAG,EAAE,QAAQ,EAAEA,GAAG,CAACa,SAAS,CAAC;;EAExD;EACA,IAAI,CAAChB,KAAK,GAAG,UAAUA,KAAK,EAAEiB,MAAM,EAAEC,GAAG,EAAE;IACvC,IAAI,CAACf,GAAG,CAACQ,EAAE,EAAE;MACT,OAAOJ,EAAE,CAACY,MAAM,CAAC,IAAIC,KAAK,CAACxB,GAAG,CAACK,IAAI,CAACoB,UAAU,CAAC,CAAC;IACpD;IACA,OAAOf,MAAM,CAACgB,IAAI,CAACtB,KAAK,CAACuB,IAAI,CAAC,IAAI,EAAEpB,GAAG,EAAEH,KAAK,EAAEiB,MAAM,EAAEC,GAAG,CAAC;EAChE,CAAC;;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACM,KAAK,GAAG,UAAUP,MAAM,EAAEQ,OAAO,EAAE;IACpC,OAAOnB,MAAM,CAACgB,IAAI,CAACzB,IAAI,CAAC2B,KAAK,CAACD,IAAI,CAAC,IAAI,EAAEN,MAAM,EAAEQ,OAAO,CAAC;EAC7D,CAAC;;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACC,IAAI,GAAG,UAAUC,MAAM,EAAEF,OAAO,EAAE;IACnC,OAAOnB,MAAM,CAACgB,IAAI,CAACzB,IAAI,CAAC6B,IAAI,CAACH,IAAI,CAAC,IAAI,EAAEI,MAAM,EAAEF,OAAO,CAAC;EAC5D,CAAC;;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACG,QAAQ,GAAG,UAAUD,MAAM,EAAEF,OAAO,EAAE;IACvC,OAAOnB,MAAM,CAACgB,IAAI,CAACzB,IAAI,CAAC+B,QAAQ,CAACL,IAAI,CAAC,IAAI,EAAEI,MAAM,EAAEF,OAAO,CAAC;EAChE,CAAC;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMI,QAAQ,GAAGA,CAAC1B,GAAG,EAAE2B,GAAG,EAAEC,EAAE,EAAEzB,MAAM,KAAK;EAEvC,MAAMC,EAAE,GAAGD,MAAM,CAACE,OAAO;EACzB,IAAIwB,MAAM;EAEV,IAAI;IACA,IAAID,EAAE,CAACE,WAAW,CAACC,IAAI,KAAK,mBAAmB,EAAE;MAC7C;MACA;MACA,MAAM,IAAIC,SAAS,CAAC,kDAAkD,CAAC;IAC3E;IACAH,MAAM,GAAGD,EAAE,CAACR,IAAI,CAACO,GAAG,EAAEA,GAAG,CAAC,CAAC,CAAC;EAChC,CAAC,CAAC,OAAOM,GAAG,EAAE;IACV1C,MAAM,CAAC2C,KAAK,CAAClC,GAAG,CAACsB,OAAO,EAAEW,GAAG,EAAE;MAC3BE,MAAM,EAAEnC,GAAG,CAACQ,EAAE,IAAIR,GAAG,CAACQ,EAAE,CAAC2B,MAAM;MAAE;MACjC1B,EAAE,EAAET,GAAG,CAACS,EAAE;MACVT,GAAG,EAAEA,GAAG,CAACA;IACb,CAAC,CAAC;IACF,OAAOI,EAAE,CAACY,MAAM,CAACiB,GAAG,CAAC,CAAC,CAAC;EAC3B;;EACA,IAAIJ,MAAM,IAAI,OAAOA,MAAM,CAACO,IAAI,KAAK,UAAU,EAAE;IAC7C,OAAOP,MAAM,CAAC,CAAC;EACnB;;EACA,OAAOzB,EAAE,CAACiC,OAAO,CAACR,MAAM,CAAC;AAC7B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMS,OAAO,GAAGA,CAACtC,GAAG,EAAE2B,GAAG,EAAEzB,IAAI,EAAEC,MAAM,KAAK;EAExC,MAAMC,EAAE,GAAGD,MAAM,CAACE,OAAO;;EAEzB;EACA,SAASkC,MAAMA,CAACC,KAAK,EAAEC,OAAO,EAAEZ,MAAM,EAAE;IACpC,MAAMa,CAAC,GAAG1C,GAAG,CAACA,GAAG;IACjB,IAAIwC,KAAK,EAAE;MACP/C,GAAG,CAACE,KAAK,CAACW,WAAW,CAACoC,CAAC,EAAE,OAAO,EAAE,IAAIC,IAAI,CAAC,CAAC,CAAC;IACjD,CAAC,MAAM;MACHD,CAAC,CAACE,MAAM,GAAG,IAAID,IAAI,CAAC,CAAC;MACrBD,CAAC,CAACD,OAAO,GAAGA,OAAO;MACnBC,CAAC,CAACb,MAAM,GAAGA,MAAM;MACjBa,CAAC,CAACG,QAAQ,GAAGH,CAAC,CAACE,MAAM,GAAGF,CAAC,CAACF,KAAK;IACnC;IACA,CAACtC,IAAI,GAAGX,MAAM,CAACuD,QAAQ,GAAGvD,MAAM,CAACwD,IAAI,EAAE/C,GAAG,CAACsB,OAAO,EAAE;MAChDa,MAAM,EAAEnC,GAAG,CAACQ,EAAE,IAAIR,GAAG,CAACQ,EAAE,CAAC2B,MAAM;MAAE;MACjC1B,EAAE,EAAET,GAAG,CAACS,EAAE;MACVT,GAAG,EAAE0C;IACT,CAAC,CAAC;EACN;EAEA,IAAIM,MAAM,EAAEC,QAAQ,EAAER,OAAO,EACzBS,MAAM,CAAC,CAAC;;EAEZ,MAAMC,MAAM,GAAGnD,GAAG,CAACsB,OAAO,CAAC6B,MAAM,CAAC,CAAC;;EAEnCZ,MAAM,CAAC,IAAI,CAAC;EAEZ,IAAIrC,IAAI,EAAE;IACN;IACAgD,MAAM,GAAI,MAAKlD,GAAG,CAACY,OAAQ,IAAGZ,GAAG,CAACoD,WAAY,EAAC;IAC/C,OAAOC,KAAK,CAAC,CAAC,CACTjB,IAAI,CAAC,MAAMV,QAAQ,CAAC1B,GAAG,EAAE2B,GAAG,EAAE3B,GAAG,CAAC4B,EAAE,EAAEzB,MAAM,CAAC,CACzCiC,IAAI,CAACkB,IAAI,IAAI;MACVN,MAAM,GAAGM,IAAI,CAAC,CAAC;MACfb,OAAO,GAAG,IAAI;MACd,OAAOc,MAAM,CAAC,CAAC;IACnB,CAAC,EAAEtB,GAAG,IAAI;MACNgB,QAAQ,GAAGhB,GAAG,CAAC,CAAC;MAChB,OAAOuB,QAAQ,CAAC,CAAC;IACrB,CAAC,CAAC,CACDpB,IAAI,CAAC,MAAM;MACR,IAAIK,OAAO,EAAE;QACTF,MAAM,CAAC,KAAK,EAAE,IAAI,EAAES,MAAM,CAAC;QAC3B,OAAOA,MAAM;MACjB;MACAT,MAAM,CAAC,KAAK,EAAE,KAAK,EAAEU,QAAQ,CAAC;MAC9B,OAAO7C,EAAE,CAACY,MAAM,CAACiC,QAAQ,CAAC;IAC9B,CAAC,EACDhB,GAAG,IAAI;MACH;MACA;MACA;MACAM,MAAM,CAAC,KAAK,EAAE,KAAK,EAAEN,GAAG,CAAC;MACzB;MACA,OAAO7B,EAAE,CAACY,MAAM,CAACiB,GAAG,CAAC;IACzB,CAAC,CAAC,EACNA,GAAG,IAAI;MACH;MACA;MACA;MACAM,MAAM,CAAC,KAAK,EAAE,KAAK,EAAEN,GAAG,CAAC;MACzB;MACA,OAAO7B,EAAE,CAACY,MAAM,CAACiB,GAAG,CAAC;IACzB,CAAC,CAAC;EACV;EAEA,SAASoB,KAAKA,CAAA,EAAG;IACb,IAAI,CAACrD,GAAG,CAACY,OAAO,IAAIZ,GAAG,CAACJ,IAAI,YAAYH,GAAG,CAACG,IAAI,CAAC6D,eAAe,EAAE;MAC9D,OAAOC,IAAI,CAAC1D,GAAG,CAACJ,IAAI,CAACyD,KAAK,CAACF,MAAM,CAAC,EAAE,WAAW,CAAC;IACpD;IACA,OAAOO,IAAI,CAAC,OAAO,EAAE,WAAW,CAAC;EACrC;EAEA,SAASH,MAAMA,CAAA,EAAG;IACd,OAAOG,IAAI,CAAC,QAAQ,EAAE,mBAAmB,CAAC;EAC9C;EAEA,SAASF,QAAQA,CAAA,EAAG;IAChB,OAAOE,IAAI,CAAC,UAAU,EAAE,uBAAuB,CAAC;EACpD;EAEA,SAASA,IAAIA,CAACC,GAAG,EAAEC,MAAM,EAAE;IACvB,IAAI5D,GAAG,CAACY,OAAO,EAAE;MACb,OAAOe,GAAG,CAACkC,IAAI,CAAC,CAACV,MAAM,GAAGS,MAAM,CAACE,WAAW,CAAC,CAAC,GAAGF,MAAM,IAAI,GAAG,GAAGV,MAAM,CAAC;IAC5E;IACA,OAAOvB,GAAG,CAACkC,IAAI,CAACV,MAAM,GAAGQ,GAAG,CAACG,WAAW,CAAC,CAAC,GAAGH,GAAG,CAAC;EACrD;;EAEA;EACA,OAAOjC,QAAQ,CAAC1B,GAAG,EAAE2B,GAAG,EAAE3B,GAAG,CAAC4B,EAAE,EAAEzB,MAAM,CAAC,CACpCiC,IAAI,CAACkB,IAAI,IAAI;IACVf,MAAM,CAAC,KAAK,EAAE,IAAI,EAAEe,IAAI,CAAC;IACzB,OAAOA,IAAI;EACf,CAAC,CAAC,CACDS,KAAK,CAAC7B,KAAK,IAAI;IACZK,MAAM,CAAC,KAAK,EAAE,KAAK,EAAEL,KAAK,CAAC;IAC3B,OAAO9B,EAAE,CAACY,MAAM,CAACkB,KAAK,CAAC;EAC3B,CAAC,CAAC;AACV,CAAC;AAED8B,MAAM,CAACC,OAAO,GAAG9D,MAAM,IAAI;EACvB,MAAM+D,QAAQ,GAAG/D,MAAM,CAACgB,IAAI;;EAE5B;EACA;EACA;EACA+C,QAAQ,CAACrE,KAAK,GAAGqE,QAAQ,CAACrE,KAAK,IAAIJ,GAAG,CAACI,KAAK,CAACM,MAAM,CAAC;EACpD+D,QAAQ,CAACxE,IAAI,GAAGwE,QAAQ,CAACxE,IAAI,IAAID,GAAG,CAACC,IAAI,CAACS,MAAM,CAACgE,UAAU,CAAC;EAE5D,OAAO;IACHpE,IAAI;IAAEuC,OAAO;IAAEZ;EACnB,CAAC;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"script","externalDependencies":[]}