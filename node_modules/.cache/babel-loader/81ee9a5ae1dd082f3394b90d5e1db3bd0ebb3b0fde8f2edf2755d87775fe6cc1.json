{"ast":null,"code":"const {\n  BatchError\n} = require('../errors/batch');\n\n/**\r\n * @method batch\r\n * @description\r\n * Settles (resolves or rejects) every [mixed value]{@tutorial mixed} in the input array.\r\n *\r\n * The method resolves with an array of results, the same as the standard $[promise.all],\r\n * while providing comprehensive error details in case of a reject, in the form of\r\n * type {@link errors.BatchError BatchError}.\r\n *\r\n * @param {Array} values\r\n * Array of [mixed values]{@tutorial mixed} (it can be empty), to be resolved asynchronously, in no particular order.\r\n *\r\n * Passing in anything other than an array will reject with {@link external:TypeError TypeError} =\r\n * `Method 'batch' requires an array of values.`\r\n *\r\n * @param {Object} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {Function|generator} [options.cb]\r\n * Optional callback (or generator) to receive the result for each settled value.\r\n *\r\n * Callback Parameters:\r\n *  - `index` = index of the value in the source array\r\n *  - `success` - indicates whether the value was resolved (`true`), or rejected (`false`)\r\n *  - `result` = resolved data, if `success`=`true`, or else the rejection reason\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * It can optionally return a promise to indicate that notifications are handled asynchronously.\r\n * And if the returned promise resolves, it signals a successful handling, while any resolved\r\n * data is ignored.\r\n *\r\n * If the function returns a rejected promise or throws an error, the entire method rejects\r\n * with {@link errors.BatchError BatchError} where the corresponding value in property `data`\r\n * is set to `{success, result, origin}`:\r\n *  - `success` = `false`\r\n *  - `result` = the rejection reason or the error thrown by the notification callback\r\n *  - `origin` = the original data passed into the callback as object `{success, result}`\r\n *\r\n * @returns {external:Promise}\r\n *\r\n * The method resolves with an array of individual resolved results, the same as the standard $[promise.all].\r\n * In addition, the array is extended with a hidden read-only property `duration` - number of milliseconds\r\n * spent resolving all the data.\r\n *\r\n * The method rejects with {@link errors.BatchError BatchError} when any of the following occurs:\r\n *  - one or more values rejected or threw an error while being resolved as a [mixed value]{@tutorial mixed}\r\n *  - notification callback `cb` returned a rejected promise or threw an error\r\n *\r\n */\nfunction batch(values, options, config) {\n  const $p = config.promise,\n    utils = config.utils;\n  if (!Array.isArray(values)) {\n    return $p.reject(new TypeError('Method \\'batch\\' requires an array of values.'));\n  }\n  if (!values.length) {\n    const empty = [];\n    utils.extend(empty, 'duration', 0);\n    return $p.resolve(empty);\n  }\n  options = options || {};\n  const cb = utils.wrap(options.cb),\n    self = this,\n    start = Date.now();\n  return $p((resolve, reject) => {\n    let cbTime,\n      remaining = values.length;\n    const errors = [],\n      result = new Array(remaining);\n    values.forEach((item, i) => {\n      utils.resolve.call(self, item, null, data => {\n        result[i] = data;\n        step(i, true, data);\n      }, reason => {\n        result[i] = {\n          success: false,\n          result: reason\n        };\n        errors.push(i);\n        step(i, false, reason);\n      });\n    });\n    function step(idx, pass, data) {\n      if (cb) {\n        const cbNow = Date.now(),\n          cbDelay = idx ? cbNow - cbTime : undefined;\n        let cbResult;\n        cbTime = cbNow;\n        try {\n          cbResult = cb.call(self, idx, pass, data, cbDelay);\n        } catch (e) {\n          setError(e);\n        }\n        if (utils.isPromise(cbResult)) {\n          cbResult.then(check).catch(error => {\n            setError(error);\n            check();\n          });\n        } else {\n          check();\n        }\n      } else {\n        check();\n      }\n      function setError(e) {\n        const r = pass ? {\n          success: false\n        } : result[idx];\n        if (pass) {\n          result[idx] = r;\n          errors.push(idx);\n        }\n        r.result = e;\n        r.origin = {\n          success: pass,\n          result: data\n        };\n      }\n      function check() {\n        if (! --remaining) {\n          if (errors.length) {\n            errors.sort();\n            if (errors.length < result.length) {\n              for (let i = 0, k = 0; i < result.length; i++) {\n                if (i === errors[k]) {\n                  k++;\n                } else {\n                  result[i] = {\n                    success: true,\n                    result: result[i]\n                  };\n                }\n              }\n            }\n            reject(new BatchError(result, errors, Date.now() - start));\n          } else {\n            utils.extend(result, 'duration', Date.now() - start);\n            resolve(result);\n          }\n        }\n        return null; // this dummy return is just to prevent Bluebird warnings;\n      }\n    }\n  });\n}\n\nmodule.exports = function (config) {\n  return function (values, options) {\n    return batch.call(this, values, options, config);\n  };\n};","map":{"version":3,"names":["BatchError","require","batch","values","options","config","$p","promise","utils","Array","isArray","reject","TypeError","length","empty","extend","resolve","cb","wrap","self","start","Date","now","cbTime","remaining","errors","result","forEach","item","i","call","data","step","reason","success","push","idx","pass","cbNow","cbDelay","undefined","cbResult","e","setError","isPromise","then","check","catch","error","r","origin","sort","k","module","exports"],"sources":["/Users/luna/Library/Mobile Documents/com~apple~CloudDocs/GitHub/paucamcal.github.io/AESP/node_modules/spex/lib/ext/batch.js"],"sourcesContent":["const {BatchError} = require('../errors/batch');\r\n\r\n/**\r\n * @method batch\r\n * @description\r\n * Settles (resolves or rejects) every [mixed value]{@tutorial mixed} in the input array.\r\n *\r\n * The method resolves with an array of results, the same as the standard $[promise.all],\r\n * while providing comprehensive error details in case of a reject, in the form of\r\n * type {@link errors.BatchError BatchError}.\r\n *\r\n * @param {Array} values\r\n * Array of [mixed values]{@tutorial mixed} (it can be empty), to be resolved asynchronously, in no particular order.\r\n *\r\n * Passing in anything other than an array will reject with {@link external:TypeError TypeError} =\r\n * `Method 'batch' requires an array of values.`\r\n *\r\n * @param {Object} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {Function|generator} [options.cb]\r\n * Optional callback (or generator) to receive the result for each settled value.\r\n *\r\n * Callback Parameters:\r\n *  - `index` = index of the value in the source array\r\n *  - `success` - indicates whether the value was resolved (`true`), or rejected (`false`)\r\n *  - `result` = resolved data, if `success`=`true`, or else the rejection reason\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * It can optionally return a promise to indicate that notifications are handled asynchronously.\r\n * And if the returned promise resolves, it signals a successful handling, while any resolved\r\n * data is ignored.\r\n *\r\n * If the function returns a rejected promise or throws an error, the entire method rejects\r\n * with {@link errors.BatchError BatchError} where the corresponding value in property `data`\r\n * is set to `{success, result, origin}`:\r\n *  - `success` = `false`\r\n *  - `result` = the rejection reason or the error thrown by the notification callback\r\n *  - `origin` = the original data passed into the callback as object `{success, result}`\r\n *\r\n * @returns {external:Promise}\r\n *\r\n * The method resolves with an array of individual resolved results, the same as the standard $[promise.all].\r\n * In addition, the array is extended with a hidden read-only property `duration` - number of milliseconds\r\n * spent resolving all the data.\r\n *\r\n * The method rejects with {@link errors.BatchError BatchError} when any of the following occurs:\r\n *  - one or more values rejected or threw an error while being resolved as a [mixed value]{@tutorial mixed}\r\n *  - notification callback `cb` returned a rejected promise or threw an error\r\n *\r\n */\r\nfunction batch(values, options, config) {\r\n\r\n    const $p = config.promise, utils = config.utils;\r\n\r\n    if (!Array.isArray(values)) {\r\n        return $p.reject(new TypeError('Method \\'batch\\' requires an array of values.'));\r\n    }\r\n\r\n    if (!values.length) {\r\n        const empty = [];\r\n        utils.extend(empty, 'duration', 0);\r\n        return $p.resolve(empty);\r\n    }\r\n\r\n    options = options || {};\r\n\r\n    const cb = utils.wrap(options.cb),\r\n        self = this, start = Date.now();\r\n\r\n    return $p((resolve, reject) => {\r\n        let cbTime, remaining = values.length;\r\n        const errors = [], result = new Array(remaining);\r\n        values.forEach((item, i) => {\r\n            utils.resolve.call(self, item, null, data => {\r\n                result[i] = data;\r\n                step(i, true, data);\r\n            }, reason => {\r\n                result[i] = {success: false, result: reason};\r\n                errors.push(i);\r\n                step(i, false, reason);\r\n            });\r\n        });\r\n\r\n        function step(idx, pass, data) {\r\n            if (cb) {\r\n                const cbNow = Date.now(),\r\n                    cbDelay = idx ? (cbNow - cbTime) : undefined;\r\n                let cbResult;\r\n                cbTime = cbNow;\r\n                try {\r\n                    cbResult = cb.call(self, idx, pass, data, cbDelay);\r\n                } catch (e) {\r\n                    setError(e);\r\n                }\r\n                if (utils.isPromise(cbResult)) {\r\n                    cbResult\r\n                        .then(check)\r\n                        .catch(error => {\r\n                            setError(error);\r\n                            check();\r\n                        });\r\n                } else {\r\n                    check();\r\n                }\r\n            } else {\r\n                check();\r\n            }\r\n\r\n            function setError(e) {\r\n                const r = pass ? {success: false} : result[idx];\r\n                if (pass) {\r\n                    result[idx] = r;\r\n                    errors.push(idx);\r\n                }\r\n                r.result = e;\r\n                r.origin = {success: pass, result: data};\r\n            }\r\n\r\n            function check() {\r\n                if (!--remaining) {\r\n                    if (errors.length) {\r\n                        errors.sort();\r\n                        if (errors.length < result.length) {\r\n                            for (let i = 0, k = 0; i < result.length; i++) {\r\n                                if (i === errors[k]) {\r\n                                    k++;\r\n                                } else {\r\n                                    result[i] = {success: true, result: result[i]};\r\n                                }\r\n                            }\r\n                        }\r\n                        reject(new BatchError(result, errors, Date.now() - start));\r\n                    } else {\r\n                        utils.extend(result, 'duration', Date.now() - start);\r\n                        resolve(result);\r\n                    }\r\n                }\r\n                return null; // this dummy return is just to prevent Bluebird warnings;\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nmodule.exports = function (config) {\r\n    return function (values, options) {\r\n        return batch.call(this, values, options, config);\r\n    };\r\n};\r\n"],"mappings":"AAAA,MAAM;EAACA;AAAU,CAAC,GAAGC,OAAO,CAAC,iBAAiB,CAAC;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,KAAKA,CAACC,MAAM,EAAEC,OAAO,EAAEC,MAAM,EAAE;EAEpC,MAAMC,EAAE,GAAGD,MAAM,CAACE,OAAO;IAAEC,KAAK,GAAGH,MAAM,CAACG,KAAK;EAE/C,IAAI,CAACC,KAAK,CAACC,OAAO,CAACP,MAAM,CAAC,EAAE;IACxB,OAAOG,EAAE,CAACK,MAAM,CAAC,IAAIC,SAAS,CAAC,+CAA+C,CAAC,CAAC;EACpF;EAEA,IAAI,CAACT,MAAM,CAACU,MAAM,EAAE;IAChB,MAAMC,KAAK,GAAG,EAAE;IAChBN,KAAK,CAACO,MAAM,CAACD,KAAK,EAAE,UAAU,EAAE,CAAC,CAAC;IAClC,OAAOR,EAAE,CAACU,OAAO,CAACF,KAAK,CAAC;EAC5B;EAEAV,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EAEvB,MAAMa,EAAE,GAAGT,KAAK,CAACU,IAAI,CAACd,OAAO,CAACa,EAAE,CAAC;IAC7BE,IAAI,GAAG,IAAI;IAAEC,KAAK,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;EAEnC,OAAOhB,EAAE,CAAC,CAACU,OAAO,EAAEL,MAAM,KAAK;IAC3B,IAAIY,MAAM;MAAEC,SAAS,GAAGrB,MAAM,CAACU,MAAM;IACrC,MAAMY,MAAM,GAAG,EAAE;MAAEC,MAAM,GAAG,IAAIjB,KAAK,CAACe,SAAS,CAAC;IAChDrB,MAAM,CAACwB,OAAO,CAAC,CAACC,IAAI,EAAEC,CAAC,KAAK;MACxBrB,KAAK,CAACQ,OAAO,CAACc,IAAI,CAACX,IAAI,EAAES,IAAI,EAAE,IAAI,EAAEG,IAAI,IAAI;QACzCL,MAAM,CAACG,CAAC,CAAC,GAAGE,IAAI;QAChBC,IAAI,CAACH,CAAC,EAAE,IAAI,EAAEE,IAAI,CAAC;MACvB,CAAC,EAAEE,MAAM,IAAI;QACTP,MAAM,CAACG,CAAC,CAAC,GAAG;UAACK,OAAO,EAAE,KAAK;UAAER,MAAM,EAAEO;QAAM,CAAC;QAC5CR,MAAM,CAACU,IAAI,CAACN,CAAC,CAAC;QACdG,IAAI,CAACH,CAAC,EAAE,KAAK,EAAEI,MAAM,CAAC;MAC1B,CAAC,CAAC;IACN,CAAC,CAAC;IAEF,SAASD,IAAIA,CAACI,GAAG,EAAEC,IAAI,EAAEN,IAAI,EAAE;MAC3B,IAAId,EAAE,EAAE;QACJ,MAAMqB,KAAK,GAAGjB,IAAI,CAACC,GAAG,CAAC,CAAC;UACpBiB,OAAO,GAAGH,GAAG,GAAIE,KAAK,GAAGf,MAAM,GAAIiB,SAAS;QAChD,IAAIC,QAAQ;QACZlB,MAAM,GAAGe,KAAK;QACd,IAAI;UACAG,QAAQ,GAAGxB,EAAE,CAACa,IAAI,CAACX,IAAI,EAAEiB,GAAG,EAAEC,IAAI,EAAEN,IAAI,EAAEQ,OAAO,CAAC;QACtD,CAAC,CAAC,OAAOG,CAAC,EAAE;UACRC,QAAQ,CAACD,CAAC,CAAC;QACf;QACA,IAAIlC,KAAK,CAACoC,SAAS,CAACH,QAAQ,CAAC,EAAE;UAC3BA,QAAQ,CACHI,IAAI,CAACC,KAAK,CAAC,CACXC,KAAK,CAACC,KAAK,IAAI;YACZL,QAAQ,CAACK,KAAK,CAAC;YACfF,KAAK,CAAC,CAAC;UACX,CAAC,CAAC;QACV,CAAC,MAAM;UACHA,KAAK,CAAC,CAAC;QACX;MACJ,CAAC,MAAM;QACHA,KAAK,CAAC,CAAC;MACX;MAEA,SAASH,QAAQA,CAACD,CAAC,EAAE;QACjB,MAAMO,CAAC,GAAGZ,IAAI,GAAG;UAACH,OAAO,EAAE;QAAK,CAAC,GAAGR,MAAM,CAACU,GAAG,CAAC;QAC/C,IAAIC,IAAI,EAAE;UACNX,MAAM,CAACU,GAAG,CAAC,GAAGa,CAAC;UACfxB,MAAM,CAACU,IAAI,CAACC,GAAG,CAAC;QACpB;QACAa,CAAC,CAACvB,MAAM,GAAGgB,CAAC;QACZO,CAAC,CAACC,MAAM,GAAG;UAAChB,OAAO,EAAEG,IAAI;UAAEX,MAAM,EAAEK;QAAI,CAAC;MAC5C;MAEA,SAASe,KAAKA,CAAA,EAAG;QACb,IAAI,CAAC,GAAEtB,SAAS,EAAE;UACd,IAAIC,MAAM,CAACZ,MAAM,EAAE;YACfY,MAAM,CAAC0B,IAAI,CAAC,CAAC;YACb,IAAI1B,MAAM,CAACZ,MAAM,GAAGa,MAAM,CAACb,MAAM,EAAE;cAC/B,KAAK,IAAIgB,CAAC,GAAG,CAAC,EAAEuB,CAAC,GAAG,CAAC,EAAEvB,CAAC,GAAGH,MAAM,CAACb,MAAM,EAAEgB,CAAC,EAAE,EAAE;gBAC3C,IAAIA,CAAC,KAAKJ,MAAM,CAAC2B,CAAC,CAAC,EAAE;kBACjBA,CAAC,EAAE;gBACP,CAAC,MAAM;kBACH1B,MAAM,CAACG,CAAC,CAAC,GAAG;oBAACK,OAAO,EAAE,IAAI;oBAAER,MAAM,EAAEA,MAAM,CAACG,CAAC;kBAAC,CAAC;gBAClD;cACJ;YACJ;YACAlB,MAAM,CAAC,IAAIX,UAAU,CAAC0B,MAAM,EAAED,MAAM,EAAEJ,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGF,KAAK,CAAC,CAAC;UAC9D,CAAC,MAAM;YACHZ,KAAK,CAACO,MAAM,CAACW,MAAM,EAAE,UAAU,EAAEL,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGF,KAAK,CAAC;YACpDJ,OAAO,CAACU,MAAM,CAAC;UACnB;QACJ;QACA,OAAO,IAAI,CAAC,CAAC;MACjB;IACJ;EACJ,CAAC,CAAC;AACN;;AAEA2B,MAAM,CAACC,OAAO,GAAG,UAAUjD,MAAM,EAAE;EAC/B,OAAO,UAAUF,MAAM,EAAEC,OAAO,EAAE;IAC9B,OAAOF,KAAK,CAAC4B,IAAI,CAAC,IAAI,EAAE3B,MAAM,EAAEC,OAAO,EAAEC,MAAM,CAAC;EACpD,CAAC;AACL,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}