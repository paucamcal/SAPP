{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\n\nconst {\n  assert\n} = require('../../assert');\nconst {\n  TableName\n} = require('../table-name');\nconst {\n  ColumnSet\n} = require('../column-set');\nconst npm = {\n  formatting: require('../../formatting'),\n  utils: require('../../utils')\n};\n\n/**\r\n * @method helpers.update\r\n * @description\r\n * Generates a simplified `UPDATE` query for either one object or an array of objects.\r\n *\r\n * The resulting query needs a `WHERE` clause to be appended to it, to specify the update logic.\r\n * This is to allow for update conditions of any complexity that are easy to add.\r\n *\r\n * @param {object|object[]} data\r\n * An update object with properties for update values, or an array of such objects.\r\n *\r\n * When `data` is not a non-null object and not an array, it will throw {@link external:TypeError TypeError} = `Invalid parameter 'data' specified.`\r\n *\r\n * When `data` is an empty array, it will throw {@link external:TypeError TypeError} = `Cannot generate an UPDATE from an empty array.`\r\n *\r\n * When `data` is an array that contains a non-object value, the method will throw {@link external:Error Error} =\r\n * `Invalid update object at index N.`\r\n *\r\n * @param {array|helpers.Column|helpers.ColumnSet} [columns]\r\n * Set of columns to be updated.\r\n *\r\n * It is optional when `data` is a single object, and required when `data` is an array of objects. If not specified for an array\r\n * of objects, the method will throw {@link external:TypeError TypeError} = `Parameter 'columns' is required when updating multiple records.`\r\n *\r\n * When `columns` is not a {@link helpers.ColumnSet ColumnSet} object, a temporary {@link helpers.ColumnSet ColumnSet}\r\n * is created - from the value of `columns` (if it was specified), or from the value of `data` (if it is not an array).\r\n *\r\n * When the final {@link helpers.ColumnSet ColumnSet} is empty (no columns in it), the method will throw\r\n * {@link external:Error Error} = `Cannot generate an UPDATE without any columns.`, unless option `emptyUpdate` was specified.\r\n *\r\n * @param {helpers.TableName|string|{table,schema}} [table]\r\n * Table to be updated.\r\n *\r\n * It is normally a required parameter. But when `columns` is passed in as a {@link helpers.ColumnSet ColumnSet} object\r\n * with `table` set in it, that will be used when this parameter isn't specified. When neither is available, the method\r\n * will throw {@link external:Error Error} = `Table name is unknown.`\r\n *\r\n * @param {{}} [options]\r\n * An object with formatting options for multi-row `UPDATE` queries.\r\n *\r\n * @param {string} [options.tableAlias=t]\r\n * Name of the SQL variable that represents the destination table.\r\n *\r\n * @param {string} [options.valueAlias=v]\r\n * Name of the SQL variable that represents the values.\r\n *\r\n * @param {*} [options.emptyUpdate]\r\n * This is a convenience option, to avoid throwing an error when generating a conditional update results in no columns.\r\n *\r\n * When present, regardless of the value, this option overrides the method's behavior when applying `skip` logic results in no columns,\r\n * i.e. when every column is being skipped.\r\n *\r\n * By default, in that situation the method throws {@link external:Error Error} = `Cannot generate an UPDATE without any columns.`\r\n * But when this option is present, the method will instead return whatever value the option was passed.\r\n *\r\n * @returns {*}\r\n * An `UPDATE` query string that needs a `WHERE` condition appended.\r\n *\r\n * If it results in an empty update, and option `emptyUpdate` was passed in, then the method returns the value\r\n * to which the option was set.\r\n *\r\n * @see\r\n *  {@link helpers.Column Column},\r\n *  {@link helpers.ColumnSet ColumnSet},\r\n *  {@link helpers.TableName TableName}\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')({\r\n *    capSQL: true // if you want all generated SQL capitalized\r\n * });\r\n *\r\n * const dataSingle = {id: 1, val: 123, msg: 'hello'};\r\n * const dataMulti = [{id: 1, val: 123, msg: 'hello'}, {id: 2, val: 456, msg: 'world!'}];\r\n *\r\n * // Although column details can be taken from the data object, it is not\r\n * // a likely scenario for an update, unless updating the whole table:\r\n *\r\n * pgp.helpers.update(dataSingle, null, 'my-table');\r\n * //=> UPDATE \"my-table\" SET \"id\"=1,\"val\"=123,\"msg\"='hello'\r\n *\r\n * @example\r\n *\r\n * // A typical single-object update:\r\n *\r\n * // Dynamic conditions must be escaped/formatted properly:\r\n * const condition = pgp.as.format(' WHERE id = ${id}', dataSingle);\r\n *\r\n * pgp.helpers.update(dataSingle, ['val', 'msg'], 'my-table') + condition;\r\n * //=> UPDATE \"my-table\" SET \"val\"=123,\"msg\"='hello' WHERE id = 1\r\n *\r\n * @example\r\n *\r\n * // Column details are required for a multi-row `UPDATE`;\r\n * // Adding '?' in front of a column name means it is only for a WHERE condition:\r\n *\r\n * pgp.helpers.update(dataMulti, ['?id', 'val', 'msg'], 'my-table') + ' WHERE v.id = t.id';\r\n * //=> UPDATE \"my-table\" AS t SET \"val\"=v.\"val\",\"msg\"=v.\"msg\" FROM (VALUES(1,123,'hello'),(2,456,'world!'))\r\n * //   AS v(\"id\",\"val\",\"msg\") WHERE v.id = t.id\r\n *\r\n * @example\r\n *\r\n * // Column details from a reusable ColumnSet (recommended for performance):\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['?id', 'val', 'msg'], {table: 'my-table'});\r\n *\r\n * pgp.helpers.update(dataMulti, cs) + ' WHERE v.id = t.id';\r\n * //=> UPDATE \"my-table\" AS t SET \"val\"=v.\"val\",\"msg\"=v.\"msg\" FROM (VALUES(1,123,'hello'),(2,456,'world!'))\r\n * //   AS v(\"id\",\"val\",\"msg\") WHERE v.id = t.id\r\n *\r\n * @example\r\n *\r\n * // Using parameter `options` to change the default alias names:\r\n *\r\n * pgp.helpers.update(dataMulti, cs, null, {tableAlias: 'X', valueAlias: 'Y'}) + ' WHERE Y.id = X.id';\r\n * //=> UPDATE \"my-table\" AS X SET \"val\"=Y.\"val\",\"msg\"=Y.\"msg\" FROM (VALUES(1,123,'hello'),(2,456,'world!'))\r\n * //   AS Y(\"id\",\"val\",\"msg\") WHERE Y.id = X.id\r\n *\r\n * @example\r\n *\r\n * // Handling an empty update\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['?id', '?name'], {table: 'tt'}); // no actual update-able columns\r\n * const result = pgp.helpers.update(dataMulti, cs, null, {emptyUpdate: 123});\r\n * if(result === 123) {\r\n *    // We know the update is empty, i.e. no columns that can be updated;\r\n *    // And it didn't throw because we specified `emptyUpdate` option.\r\n * }\r\n */\nfunction update(data, columns, table, options, capSQL) {\n  if (!data || typeof data !== 'object') {\n    throw new TypeError('Invalid parameter \\'data\\' specified.');\n  }\n  const isArray = Array.isArray(data);\n  if (isArray && !data.length) {\n    throw new TypeError('Cannot generate an UPDATE from an empty array.');\n  }\n  if (columns instanceof ColumnSet) {\n    if (npm.utils.isNull(table)) {\n      table = columns.table;\n    }\n  } else {\n    if (isArray && npm.utils.isNull(columns)) {\n      throw new TypeError('Parameter \\'columns\\' is required when updating multiple records.');\n    }\n    columns = new ColumnSet(columns || data);\n  }\n  options = assert(options, ['tableAlias', 'valueAlias', 'emptyUpdate']);\n  const format = npm.formatting.as.format,\n    useEmptyUpdate = ('emptyUpdate' in options),\n    fmOptions = {\n      capSQL\n    };\n  if (isArray) {\n    const tableAlias = npm.formatting.as.alias(npm.utils.isNull(options.tableAlias) ? 't' : options.tableAlias);\n    const valueAlias = npm.formatting.as.alias(npm.utils.isNull(options.valueAlias) ? 'v' : options.valueAlias);\n    const q = capSQL ? sql.multi.capCase : sql.multi.lowCase;\n    const actualColumns = columns.columns.filter(c => !c.cnd);\n    if (checkColumns(actualColumns)) {\n      return options.emptyUpdate;\n    }\n    checkTable();\n    const targetCols = actualColumns.map(c => c.escapedName + '=' + valueAlias + '.' + c.escapedName).join();\n    const values = data.map((d, index) => {\n      if (!d || typeof d !== 'object') {\n        throw new Error(`Invalid update object at index ${index}.`);\n      }\n      return '(' + format(columns.variables, columns.prepare(d), fmOptions) + ')';\n    }).join();\n    return format(q, [table.name, tableAlias, targetCols, values, valueAlias, columns.names], fmOptions);\n  }\n  const updates = columns.assign({\n    source: data\n  });\n  if (checkColumns(updates)) {\n    return options.emptyUpdate;\n  }\n  checkTable();\n  const query = capSQL ? sql.single.capCase : sql.single.lowCase;\n  return format(query, table.name) + format(updates, columns.prepare(data), fmOptions);\n  function checkTable() {\n    if (table && !(table instanceof TableName)) {\n      table = new TableName(table);\n    }\n    if (!table) {\n      throw new Error('Table name is unknown.');\n    }\n  }\n  function checkColumns(cols) {\n    if (!cols.length) {\n      if (useEmptyUpdate) {\n        return true;\n      }\n      throw new Error('Cannot generate an UPDATE without any columns.');\n    }\n  }\n}\nconst sql = {\n  single: {\n    lowCase: 'update $1^ set ',\n    capCase: 'UPDATE $1^ SET '\n  },\n  multi: {\n    lowCase: 'update $1^ as $2^ set $3^ from (values$4^) as $5^($6^)',\n    capCase: 'UPDATE $1^ AS $2^ SET $3^ FROM (VALUES$4^) AS $5^($6^)'\n  }\n};\nmodule.exports = {\n  update\n};","map":{"version":3,"names":["assert","require","TableName","ColumnSet","npm","formatting","utils","update","data","columns","table","options","capSQL","TypeError","isArray","Array","length","isNull","format","as","useEmptyUpdate","fmOptions","tableAlias","alias","valueAlias","q","sql","multi","capCase","lowCase","actualColumns","filter","c","cnd","checkColumns","emptyUpdate","checkTable","targetCols","map","escapedName","join","values","d","index","Error","variables","prepare","name","names","updates","assign","source","query","single","cols","module","exports"],"sources":["/Users/luna/Library/Mobile Documents/com~apple~CloudDocs/GitHub/paucamcal.github.io/AESP/node_modules/pg-promise/lib/helpers/methods/update.js"],"sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {assert} = require('../../assert');\r\nconst {TableName} = require('../table-name');\r\nconst {ColumnSet} = require('../column-set');\r\n\r\nconst npm = {\r\n    formatting: require('../../formatting'),\r\n    utils: require('../../utils')\r\n};\r\n\r\n/**\r\n * @method helpers.update\r\n * @description\r\n * Generates a simplified `UPDATE` query for either one object or an array of objects.\r\n *\r\n * The resulting query needs a `WHERE` clause to be appended to it, to specify the update logic.\r\n * This is to allow for update conditions of any complexity that are easy to add.\r\n *\r\n * @param {object|object[]} data\r\n * An update object with properties for update values, or an array of such objects.\r\n *\r\n * When `data` is not a non-null object and not an array, it will throw {@link external:TypeError TypeError} = `Invalid parameter 'data' specified.`\r\n *\r\n * When `data` is an empty array, it will throw {@link external:TypeError TypeError} = `Cannot generate an UPDATE from an empty array.`\r\n *\r\n * When `data` is an array that contains a non-object value, the method will throw {@link external:Error Error} =\r\n * `Invalid update object at index N.`\r\n *\r\n * @param {array|helpers.Column|helpers.ColumnSet} [columns]\r\n * Set of columns to be updated.\r\n *\r\n * It is optional when `data` is a single object, and required when `data` is an array of objects. If not specified for an array\r\n * of objects, the method will throw {@link external:TypeError TypeError} = `Parameter 'columns' is required when updating multiple records.`\r\n *\r\n * When `columns` is not a {@link helpers.ColumnSet ColumnSet} object, a temporary {@link helpers.ColumnSet ColumnSet}\r\n * is created - from the value of `columns` (if it was specified), or from the value of `data` (if it is not an array).\r\n *\r\n * When the final {@link helpers.ColumnSet ColumnSet} is empty (no columns in it), the method will throw\r\n * {@link external:Error Error} = `Cannot generate an UPDATE without any columns.`, unless option `emptyUpdate` was specified.\r\n *\r\n * @param {helpers.TableName|string|{table,schema}} [table]\r\n * Table to be updated.\r\n *\r\n * It is normally a required parameter. But when `columns` is passed in as a {@link helpers.ColumnSet ColumnSet} object\r\n * with `table` set in it, that will be used when this parameter isn't specified. When neither is available, the method\r\n * will throw {@link external:Error Error} = `Table name is unknown.`\r\n *\r\n * @param {{}} [options]\r\n * An object with formatting options for multi-row `UPDATE` queries.\r\n *\r\n * @param {string} [options.tableAlias=t]\r\n * Name of the SQL variable that represents the destination table.\r\n *\r\n * @param {string} [options.valueAlias=v]\r\n * Name of the SQL variable that represents the values.\r\n *\r\n * @param {*} [options.emptyUpdate]\r\n * This is a convenience option, to avoid throwing an error when generating a conditional update results in no columns.\r\n *\r\n * When present, regardless of the value, this option overrides the method's behavior when applying `skip` logic results in no columns,\r\n * i.e. when every column is being skipped.\r\n *\r\n * By default, in that situation the method throws {@link external:Error Error} = `Cannot generate an UPDATE without any columns.`\r\n * But when this option is present, the method will instead return whatever value the option was passed.\r\n *\r\n * @returns {*}\r\n * An `UPDATE` query string that needs a `WHERE` condition appended.\r\n *\r\n * If it results in an empty update, and option `emptyUpdate` was passed in, then the method returns the value\r\n * to which the option was set.\r\n *\r\n * @see\r\n *  {@link helpers.Column Column},\r\n *  {@link helpers.ColumnSet ColumnSet},\r\n *  {@link helpers.TableName TableName}\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')({\r\n *    capSQL: true // if you want all generated SQL capitalized\r\n * });\r\n *\r\n * const dataSingle = {id: 1, val: 123, msg: 'hello'};\r\n * const dataMulti = [{id: 1, val: 123, msg: 'hello'}, {id: 2, val: 456, msg: 'world!'}];\r\n *\r\n * // Although column details can be taken from the data object, it is not\r\n * // a likely scenario for an update, unless updating the whole table:\r\n *\r\n * pgp.helpers.update(dataSingle, null, 'my-table');\r\n * //=> UPDATE \"my-table\" SET \"id\"=1,\"val\"=123,\"msg\"='hello'\r\n *\r\n * @example\r\n *\r\n * // A typical single-object update:\r\n *\r\n * // Dynamic conditions must be escaped/formatted properly:\r\n * const condition = pgp.as.format(' WHERE id = ${id}', dataSingle);\r\n *\r\n * pgp.helpers.update(dataSingle, ['val', 'msg'], 'my-table') + condition;\r\n * //=> UPDATE \"my-table\" SET \"val\"=123,\"msg\"='hello' WHERE id = 1\r\n *\r\n * @example\r\n *\r\n * // Column details are required for a multi-row `UPDATE`;\r\n * // Adding '?' in front of a column name means it is only for a WHERE condition:\r\n *\r\n * pgp.helpers.update(dataMulti, ['?id', 'val', 'msg'], 'my-table') + ' WHERE v.id = t.id';\r\n * //=> UPDATE \"my-table\" AS t SET \"val\"=v.\"val\",\"msg\"=v.\"msg\" FROM (VALUES(1,123,'hello'),(2,456,'world!'))\r\n * //   AS v(\"id\",\"val\",\"msg\") WHERE v.id = t.id\r\n *\r\n * @example\r\n *\r\n * // Column details from a reusable ColumnSet (recommended for performance):\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['?id', 'val', 'msg'], {table: 'my-table'});\r\n *\r\n * pgp.helpers.update(dataMulti, cs) + ' WHERE v.id = t.id';\r\n * //=> UPDATE \"my-table\" AS t SET \"val\"=v.\"val\",\"msg\"=v.\"msg\" FROM (VALUES(1,123,'hello'),(2,456,'world!'))\r\n * //   AS v(\"id\",\"val\",\"msg\") WHERE v.id = t.id\r\n *\r\n * @example\r\n *\r\n * // Using parameter `options` to change the default alias names:\r\n *\r\n * pgp.helpers.update(dataMulti, cs, null, {tableAlias: 'X', valueAlias: 'Y'}) + ' WHERE Y.id = X.id';\r\n * //=> UPDATE \"my-table\" AS X SET \"val\"=Y.\"val\",\"msg\"=Y.\"msg\" FROM (VALUES(1,123,'hello'),(2,456,'world!'))\r\n * //   AS Y(\"id\",\"val\",\"msg\") WHERE Y.id = X.id\r\n *\r\n * @example\r\n *\r\n * // Handling an empty update\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['?id', '?name'], {table: 'tt'}); // no actual update-able columns\r\n * const result = pgp.helpers.update(dataMulti, cs, null, {emptyUpdate: 123});\r\n * if(result === 123) {\r\n *    // We know the update is empty, i.e. no columns that can be updated;\r\n *    // And it didn't throw because we specified `emptyUpdate` option.\r\n * }\r\n */\r\nfunction update(data, columns, table, options, capSQL) {\r\n\r\n    if (!data || typeof data !== 'object') {\r\n        throw new TypeError('Invalid parameter \\'data\\' specified.');\r\n    }\r\n\r\n    const isArray = Array.isArray(data);\r\n\r\n    if (isArray && !data.length) {\r\n        throw new TypeError('Cannot generate an UPDATE from an empty array.');\r\n    }\r\n\r\n    if (columns instanceof ColumnSet) {\r\n        if (npm.utils.isNull(table)) {\r\n            table = columns.table;\r\n        }\r\n    } else {\r\n        if (isArray && npm.utils.isNull(columns)) {\r\n            throw new TypeError('Parameter \\'columns\\' is required when updating multiple records.');\r\n        }\r\n        columns = new ColumnSet(columns || data);\r\n    }\r\n\r\n    options = assert(options, ['tableAlias', 'valueAlias', 'emptyUpdate']);\r\n\r\n    const format = npm.formatting.as.format,\r\n        useEmptyUpdate = 'emptyUpdate' in options,\r\n        fmOptions = {capSQL};\r\n\r\n    if (isArray) {\r\n        const tableAlias = npm.formatting.as.alias(npm.utils.isNull(options.tableAlias) ? 't' : options.tableAlias);\r\n        const valueAlias = npm.formatting.as.alias(npm.utils.isNull(options.valueAlias) ? 'v' : options.valueAlias);\r\n\r\n        const q = capSQL ? sql.multi.capCase : sql.multi.lowCase;\r\n\r\n        const actualColumns = columns.columns.filter(c => !c.cnd);\r\n\r\n        if (checkColumns(actualColumns)) {\r\n            return options.emptyUpdate;\r\n        }\r\n\r\n        checkTable();\r\n\r\n        const targetCols = actualColumns.map(c => c.escapedName + '=' + valueAlias + '.' + c.escapedName).join();\r\n\r\n        const values = data.map((d, index) => {\r\n            if (!d || typeof d !== 'object') {\r\n                throw new Error(`Invalid update object at index ${index}.`);\r\n            }\r\n            return '(' + format(columns.variables, columns.prepare(d), fmOptions) + ')';\r\n        }).join();\r\n\r\n        return format(q, [table.name, tableAlias, targetCols, values, valueAlias, columns.names], fmOptions);\r\n    }\r\n\r\n    const updates = columns.assign({source: data});\r\n\r\n    if (checkColumns(updates)) {\r\n        return options.emptyUpdate;\r\n    }\r\n\r\n    checkTable();\r\n\r\n    const query = capSQL ? sql.single.capCase : sql.single.lowCase;\r\n\r\n    return format(query, table.name) + format(updates, columns.prepare(data), fmOptions);\r\n\r\n    function checkTable() {\r\n        if (table && !(table instanceof TableName)) {\r\n            table = new TableName(table);\r\n        }\r\n        if (!table) {\r\n            throw new Error('Table name is unknown.');\r\n        }\r\n    }\r\n\r\n    function checkColumns(cols) {\r\n        if (!cols.length) {\r\n            if (useEmptyUpdate) {\r\n                return true;\r\n            }\r\n            throw new Error('Cannot generate an UPDATE without any columns.');\r\n        }\r\n    }\r\n}\r\n\r\nconst sql = {\r\n    single: {\r\n        lowCase: 'update $1^ set ',\r\n        capCase: 'UPDATE $1^ SET '\r\n    },\r\n    multi: {\r\n        lowCase: 'update $1^ as $2^ set $3^ from (values$4^) as $5^($6^)',\r\n        capCase: 'UPDATE $1^ AS $2^ SET $3^ FROM (VALUES$4^) AS $5^($6^)'\r\n    }\r\n};\r\n\r\nmodule.exports = {update};\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM;EAACA;AAAM,CAAC,GAAGC,OAAO,CAAC,cAAc,CAAC;AACxC,MAAM;EAACC;AAAS,CAAC,GAAGD,OAAO,CAAC,eAAe,CAAC;AAC5C,MAAM;EAACE;AAAS,CAAC,GAAGF,OAAO,CAAC,eAAe,CAAC;AAE5C,MAAMG,GAAG,GAAG;EACRC,UAAU,EAAEJ,OAAO,CAAC,kBAAkB,CAAC;EACvCK,KAAK,EAAEL,OAAO,CAAC,aAAa;AAChC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASM,MAAMA,CAACC,IAAI,EAAEC,OAAO,EAAEC,KAAK,EAAEC,OAAO,EAAEC,MAAM,EAAE;EAEnD,IAAI,CAACJ,IAAI,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;IACnC,MAAM,IAAIK,SAAS,CAAC,uCAAuC,CAAC;EAChE;EAEA,MAAMC,OAAO,GAAGC,KAAK,CAACD,OAAO,CAACN,IAAI,CAAC;EAEnC,IAAIM,OAAO,IAAI,CAACN,IAAI,CAACQ,MAAM,EAAE;IACzB,MAAM,IAAIH,SAAS,CAAC,gDAAgD,CAAC;EACzE;EAEA,IAAIJ,OAAO,YAAYN,SAAS,EAAE;IAC9B,IAAIC,GAAG,CAACE,KAAK,CAACW,MAAM,CAACP,KAAK,CAAC,EAAE;MACzBA,KAAK,GAAGD,OAAO,CAACC,KAAK;IACzB;EACJ,CAAC,MAAM;IACH,IAAII,OAAO,IAAIV,GAAG,CAACE,KAAK,CAACW,MAAM,CAACR,OAAO,CAAC,EAAE;MACtC,MAAM,IAAII,SAAS,CAAC,mEAAmE,CAAC;IAC5F;IACAJ,OAAO,GAAG,IAAIN,SAAS,CAACM,OAAO,IAAID,IAAI,CAAC;EAC5C;EAEAG,OAAO,GAAGX,MAAM,CAACW,OAAO,EAAE,CAAC,YAAY,EAAE,YAAY,EAAE,aAAa,CAAC,CAAC;EAEtE,MAAMO,MAAM,GAAGd,GAAG,CAACC,UAAU,CAACc,EAAE,CAACD,MAAM;IACnCE,cAAc,IAAG,aAAa,IAAIT,OAAO;IACzCU,SAAS,GAAG;MAACT;IAAM,CAAC;EAExB,IAAIE,OAAO,EAAE;IACT,MAAMQ,UAAU,GAAGlB,GAAG,CAACC,UAAU,CAACc,EAAE,CAACI,KAAK,CAACnB,GAAG,CAACE,KAAK,CAACW,MAAM,CAACN,OAAO,CAACW,UAAU,CAAC,GAAG,GAAG,GAAGX,OAAO,CAACW,UAAU,CAAC;IAC3G,MAAME,UAAU,GAAGpB,GAAG,CAACC,UAAU,CAACc,EAAE,CAACI,KAAK,CAACnB,GAAG,CAACE,KAAK,CAACW,MAAM,CAACN,OAAO,CAACa,UAAU,CAAC,GAAG,GAAG,GAAGb,OAAO,CAACa,UAAU,CAAC;IAE3G,MAAMC,CAAC,GAAGb,MAAM,GAAGc,GAAG,CAACC,KAAK,CAACC,OAAO,GAAGF,GAAG,CAACC,KAAK,CAACE,OAAO;IAExD,MAAMC,aAAa,GAAGrB,OAAO,CAACA,OAAO,CAACsB,MAAM,CAACC,CAAC,IAAI,CAACA,CAAC,CAACC,GAAG,CAAC;IAEzD,IAAIC,YAAY,CAACJ,aAAa,CAAC,EAAE;MAC7B,OAAOnB,OAAO,CAACwB,WAAW;IAC9B;IAEAC,UAAU,CAAC,CAAC;IAEZ,MAAMC,UAAU,GAAGP,aAAa,CAACQ,GAAG,CAACN,CAAC,IAAIA,CAAC,CAACO,WAAW,GAAG,GAAG,GAAGf,UAAU,GAAG,GAAG,GAAGQ,CAAC,CAACO,WAAW,CAAC,CAACC,IAAI,CAAC,CAAC;IAExG,MAAMC,MAAM,GAAGjC,IAAI,CAAC8B,GAAG,CAAC,CAACI,CAAC,EAAEC,KAAK,KAAK;MAClC,IAAI,CAACD,CAAC,IAAI,OAAOA,CAAC,KAAK,QAAQ,EAAE;QAC7B,MAAM,IAAIE,KAAK,CAAE,kCAAiCD,KAAM,GAAE,CAAC;MAC/D;MACA,OAAO,GAAG,GAAGzB,MAAM,CAACT,OAAO,CAACoC,SAAS,EAAEpC,OAAO,CAACqC,OAAO,CAACJ,CAAC,CAAC,EAAErB,SAAS,CAAC,GAAG,GAAG;IAC/E,CAAC,CAAC,CAACmB,IAAI,CAAC,CAAC;IAET,OAAOtB,MAAM,CAACO,CAAC,EAAE,CAACf,KAAK,CAACqC,IAAI,EAAEzB,UAAU,EAAEe,UAAU,EAAEI,MAAM,EAAEjB,UAAU,EAAEf,OAAO,CAACuC,KAAK,CAAC,EAAE3B,SAAS,CAAC;EACxG;EAEA,MAAM4B,OAAO,GAAGxC,OAAO,CAACyC,MAAM,CAAC;IAACC,MAAM,EAAE3C;EAAI,CAAC,CAAC;EAE9C,IAAI0B,YAAY,CAACe,OAAO,CAAC,EAAE;IACvB,OAAOtC,OAAO,CAACwB,WAAW;EAC9B;EAEAC,UAAU,CAAC,CAAC;EAEZ,MAAMgB,KAAK,GAAGxC,MAAM,GAAGc,GAAG,CAAC2B,MAAM,CAACzB,OAAO,GAAGF,GAAG,CAAC2B,MAAM,CAACxB,OAAO;EAE9D,OAAOX,MAAM,CAACkC,KAAK,EAAE1C,KAAK,CAACqC,IAAI,CAAC,GAAG7B,MAAM,CAAC+B,OAAO,EAAExC,OAAO,CAACqC,OAAO,CAACtC,IAAI,CAAC,EAAEa,SAAS,CAAC;EAEpF,SAASe,UAAUA,CAAA,EAAG;IAClB,IAAI1B,KAAK,IAAI,EAAEA,KAAK,YAAYR,SAAS,CAAC,EAAE;MACxCQ,KAAK,GAAG,IAAIR,SAAS,CAACQ,KAAK,CAAC;IAChC;IACA,IAAI,CAACA,KAAK,EAAE;MACR,MAAM,IAAIkC,KAAK,CAAC,wBAAwB,CAAC;IAC7C;EACJ;EAEA,SAASV,YAAYA,CAACoB,IAAI,EAAE;IACxB,IAAI,CAACA,IAAI,CAACtC,MAAM,EAAE;MACd,IAAII,cAAc,EAAE;QAChB,OAAO,IAAI;MACf;MACA,MAAM,IAAIwB,KAAK,CAAC,gDAAgD,CAAC;IACrE;EACJ;AACJ;AAEA,MAAMlB,GAAG,GAAG;EACR2B,MAAM,EAAE;IACJxB,OAAO,EAAE,iBAAiB;IAC1BD,OAAO,EAAE;EACb,CAAC;EACDD,KAAK,EAAE;IACHE,OAAO,EAAE,wDAAwD;IACjED,OAAO,EAAE;EACb;AACJ,CAAC;AAED2B,MAAM,CAACC,OAAO,GAAG;EAACjD;AAAM,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}