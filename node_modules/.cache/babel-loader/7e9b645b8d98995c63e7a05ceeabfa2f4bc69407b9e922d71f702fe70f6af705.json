{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\n\nconst {\n  ColorConsole\n} = require('./utils/color');\nconst npm = {\n  main: require('./'),\n  utils: require('./utils')\n};\n\n/////////////////////////////////\n// Client notification helpers;\nclass Events {\n  /**\r\n   * @event connect\r\n   * @description\r\n   * Global notification of acquiring a new database connection from the connection pool, i.e. a virtual connection.\r\n   *\r\n   * However, for direct calls to method {@link Database#connect Database.connect} with parameter `{direct: true}`,\r\n   * this event represents a physical connection.\r\n   *\r\n   * The library will suppress any error thrown by the handler and write it into the console.\r\n   *\r\n   * @param {{}} e Event Properties\r\n   *\r\n   * @param {external:Client} e.client\r\n   * $[pg.Client] object that represents the connection.\r\n   *\r\n   * @param {*} e.dc\r\n   * Database Context that was used when creating the database object (see {@link Database}).\r\n   *\r\n   * @param {number} e.useCount\r\n   * Number of times the connection has been previously used, starting with 0, for a freshly\r\n   * allocated physical connection.\r\n   *\r\n   * This parameter is always 0 for direct connections (created by calling {@link Database#connect Database.connect}\r\n   * with parameter `{direct: true}`).\r\n   *\r\n   * @example\r\n   *\r\n   * const initOptions = {\r\n   *\r\n   *     // pg-promise initialization options...\r\n   *\r\n   *     connect(e) {\r\n   *         const cp = e.client.connectionParameters;\r\n   *         console.log('Connected to database:', cp.database);\r\n   *     }\r\n   *\r\n   * };\r\n   */\n  static connect(ctx, client, useCount) {\n    if (typeof ctx.options.connect === 'function') {\n      try {\n        ctx.options.connect({\n          client,\n          dc: ctx.dc,\n          useCount\n        });\n      } catch (e) {\n        // have to silence errors here;\n        // cannot allow unhandled errors while connecting to the database,\n        // as it will break the connection logic;\n        Events.unexpected('connect', e);\n      }\n    }\n  }\n\n  /**\r\n   * @event disconnect\r\n   * @description\r\n   * Global notification of releasing a database connection back to the connection pool, i.e. releasing the virtual connection.\r\n   *\r\n   * However, when releasing a direct connection (created by calling {@link Database#connect Database.connect} with parameter\r\n   * `{direct: true}`), this event represents a physical disconnection.\r\n   *\r\n   * The library will suppress any error thrown by the handler and write it into the console.\r\n   *\r\n   * @param {{}} e Event Properties\r\n   *\r\n   * @param {external:Client} e.client - $[pg.Client] object that represents connection with the database.\r\n   *\r\n   * @param {*} e.dc - Database Context that was used when creating the database object (see {@link Database}).\r\n   *\r\n   * @example\r\n   *\r\n   * const initOptions = {\r\n   *\r\n   *     // pg-promise initialization options...\r\n   *\r\n   *     disconnect(e) {\r\n   *        const cp = e.client.connectionParameters;\r\n   *        console.log('Disconnecting from database:', cp.database);\r\n   *     }\r\n   *\r\n   * };\r\n   */\n  static disconnect(ctx, client) {\n    if (typeof ctx.options.disconnect === 'function') {\n      try {\n        ctx.options.disconnect({\n          client,\n          dc: ctx.dc\n        });\n      } catch (e) {\n        // have to silence errors here;\n        // cannot allow unhandled errors while disconnecting from the database,\n        // as it will break the disconnection logic;\n        Events.unexpected('disconnect', e);\n      }\n    }\n  }\n\n  /**\r\n   * @event query\r\n   * @description\r\n   *\r\n   * Global notification of a query that's about to execute.\r\n   *\r\n   * Notification happens just before the query execution. And if the handler throws an error, the query execution\r\n   * will be rejected with that error.\r\n   *\r\n   * @param {EventContext} e\r\n   * Event Context Object.\r\n   *\r\n   * @example\r\n   *\r\n   * const initOptions = {\r\n   *\r\n   *     // pg-promise initialization options...\r\n   *\r\n   *     query(e) {\r\n   *         console.log('QUERY:', e.query);\r\n   *     }\r\n   * };\r\n   */\n  static query(options, context) {\n    if (typeof options.query === 'function') {\n      try {\n        options.query(context);\n      } catch (e) {\n        // throwing an error during event 'query'\n        // will result in a reject for the request.\n        return e instanceof Error ? e : new npm.utils.InternalError(e);\n      }\n    }\n  }\n\n  /**\r\n   * @event receive\r\n   * @description\r\n   * Global notification of any data received from the database, coming from a regular query or from a stream.\r\n   *\r\n   * The event is fired before the data reaches the client, and it serves two purposes:\r\n   *  - Providing selective data logging for debugging;\r\n   *  - Pre-processing data before it reaches the client.\r\n   *\r\n   * **NOTES:**\r\n   * - If you alter the size of `data` directly or through the `result` object, it may affect `QueryResultMask`\r\n   *   validation for regular queries, which is executed right after.\r\n   * - Any data pre-processing needs to be fast here, to avoid performance penalties.\r\n   * - If the event handler throws an error, the original request will be rejected with that error.\r\n   *\r\n   * For methods {@link Database#multi Database.multi} and {@link Database#multiResult Database.multiResult},\r\n   * this event is called for every result that's returned. And for method {@link Database#stream Database.stream},\r\n   * the event occurs for every record.\r\n   *\r\n   * @param {{}} e Event Properties\r\n   *\r\n   * @param {Array<Object>} e.data\r\n   * Array of received objects/rows.\r\n   *\r\n   * If any of those objects are modified during notification, the client will receive the modified data.\r\n   *\r\n   * @param {external:Result} e.result\r\n   * - Original $[Result] object, if the data is from a non-stream query, in which case `data = result.rows`.\r\n   *   For single-query requests, $[Result] object is extended with property `duration` - number of milliseconds\r\n   *   it took to send the query, execute it and get the result back.\r\n   * - It is `undefined` when the data comes from a stream (method {@link Database#stream Database.stream}).\r\n   *\r\n   * @param {EventContext} e.ctx\r\n   * Event Context Object.\r\n   *\r\n   * @example\r\n   *\r\n   * // Example below shows the fastest way to camelize all column names.\r\n   * // NOTE: The example does not do processing for nested JSON objects.\r\n   *\r\n   * const initOptions = {\r\n   *\r\n   *     // pg-promise initialization options...\r\n   *\r\n   *     receive(e) {\r\n   *         camelizeColumns(e.data);\r\n   *     }\r\n   * };\r\n   *\r\n   * function camelizeColumns(data) {\r\n   *     const tmp = data[0];\r\n   *     for (const prop in tmp) {\r\n   *         const camel = pgp.utils.camelize(prop);\r\n   *         if (!(camel in tmp)) {\r\n   *             for (let i = 0; i < data.length; i++) {\r\n   *                 const d = data[i];\r\n   *                 d[camel] = d[prop];\r\n   *                 delete d[prop];\r\n   *             }\r\n   *         }\r\n   *     }\r\n   * }\r\n   */\n  static receive(options, data, result, ctx) {\n    if (typeof options.receive === 'function') {\n      try {\n        options.receive({\n          data,\n          result,\n          ctx\n        });\n      } catch (e) {\n        // throwing an error during event 'receive'\n        // will result in a reject for the request.\n        return e instanceof Error ? e : new npm.utils.InternalError(e);\n      }\n    }\n  }\n\n  /**\r\n   * @event task\r\n   * @description\r\n   * Global notification of a task start / finish events, as executed via\r\n   * {@link Database#task Database.task} or {@link Database#taskIf Database.taskIf}.\r\n   *\r\n   * The library will suppress any error thrown by the handler and write it into the console.\r\n   *\r\n   * @param {EventContext} e\r\n   * Event Context Object.\r\n   *\r\n   * @example\r\n   *\r\n   * const initOptions = {\r\n   *\r\n   *     // pg-promise initialization options...\r\n   *\r\n   *     task(e) {\r\n   *         if (e.ctx.finish) {\r\n   *             // this is a task->finish event;\r\n   *             console.log('Duration:', e.ctx.duration);\r\n   *             if (e.ctx.success) {\r\n   *                 // e.ctx.result = resolved data;\r\n   *             } else {\r\n   *                 // e.ctx.result = error/rejection reason;\r\n   *             }\r\n   *         } else {\r\n   *             // this is a task->start event;\r\n   *             console.log('Start Time:', e.ctx.start);\r\n   *         }\r\n   *     }\r\n   * };\r\n   *\r\n   */\n  static task(options, context) {\n    if (typeof options.task === 'function') {\n      try {\n        options.task(context);\n      } catch (e) {\n        // silencing the error, to avoid breaking the task;\n        Events.unexpected('task', e);\n      }\n    }\n  }\n\n  /**\r\n   * @event transact\r\n   * @description\r\n   * Global notification of a transaction start / finish events, as executed via {@link Database#tx Database.tx}\r\n   * or {@link Database#txIf Database.txIf}.\r\n   *\r\n   * The library will suppress any error thrown by the handler and write it into the console.\r\n   *\r\n   * @param {EventContext} e\r\n   * Event Context Object.\r\n   *\r\n   * @example\r\n   *\r\n   * const initOptions = {\r\n   *\r\n   *     // pg-promise initialization options...\r\n   *\r\n   *     transact(e) {\r\n   *         if (e.ctx.finish) {\r\n   *             // this is a transaction->finish event;\r\n   *             console.log('Duration:', e.ctx.duration);\r\n   *             if (e.ctx.success) {\r\n   *                 // e.ctx.result = resolved data;\r\n   *             } else {\r\n   *                 // e.ctx.result = error/rejection reason;\r\n   *             }\r\n   *         } else {\r\n   *             // this is a transaction->start event;\r\n   *             console.log('Start Time:', e.ctx.start);\r\n   *         }\r\n   *     }\r\n   * };\r\n   *\r\n   */\n  static transact(options, context) {\n    if (typeof options.transact === 'function') {\n      try {\n        options.transact(context);\n      } catch (e) {\n        // silencing the error, to avoid breaking the transaction;\n        Events.unexpected('transact', e);\n      }\n    }\n  }\n\n  /**\r\n   * @event error\r\n   * @description\r\n   * Global notification of every error encountered by this library.\r\n   *\r\n   * The library will suppress any error thrown by the handler and write it into the console.\r\n   *\r\n   * @param {*} err\r\n   * The error encountered, of the same value and type as it was reported.\r\n   *\r\n   * @param {EventContext} e\r\n   * Event Context Object.\r\n   *\r\n   * @example\r\n   * const initOptions = {\r\n   *\r\n   *     // pg-promise initialization options...\r\n   *\r\n   *     error(err, e) {\r\n   *\r\n   *         if (e.cn) {\r\n   *             // this is a connection-related error\r\n   *             // cn = safe connection details passed into the library:\r\n   *             //      if password is present, it is masked by #\r\n   *         }\r\n   *\r\n   *         if (e.query) {\r\n   *             // query string is available\r\n   *             if (e.params) {\r\n   *                 // query parameters are available\r\n   *             }\r\n   *         }\r\n   *\r\n   *         if (e.ctx) {\r\n   *             // occurred inside a task or transaction\r\n   *         }\r\n   *       }\r\n   * };\r\n   *\r\n   */\n  static error(options, err, context) {\n    if (typeof options.error === 'function') {\n      try {\n        options.error(err, context);\n      } catch (e) {\n        // have to silence errors here;\n        // throwing unhandled errors while handling an error\n        // notification is simply not acceptable.\n        Events.unexpected('error', e);\n      }\n    }\n  }\n\n  /**\r\n   * @event extend\r\n   * @description\r\n   * Extends {@link Database} protocol with custom methods and properties.\r\n   *\r\n   * Override this event to extend the existing access layer with your own functions and\r\n   * properties best suited for your application.\r\n   *\r\n   * The extension thus becomes available across all access layers:\r\n   *\r\n   * - Within the root/default database protocol;\r\n   * - Inside transactions, including nested ones;\r\n   * - Inside tasks, including nested ones.\r\n   *\r\n   * All pre-defined methods and properties are read-only, so you will get an error,\r\n   * if you try overriding them.\r\n   *\r\n   * The library will suppress any error thrown by the handler and write it into the console.\r\n   *\r\n   * @param {object} obj - Protocol object to be extended.\r\n   *\r\n   * @param {*} dc - Database Context that was used when creating the {@link Database} object.\r\n   *\r\n   * @see $[pg-promise-demo]\r\n   *\r\n   * @example\r\n   *\r\n   * // In the example below we extend the protocol with function `addImage`\r\n   * // that will insert one binary image and resolve with the new record id.\r\n   *\r\n   * const initOptions = {\r\n   *\r\n   *     // pg-promise initialization options...\r\n   *\r\n   *     extend(obj, dc) {\r\n   *         // dc = database context;\r\n   *         obj.addImage = data => {\r\n   *             // adds a new image and resolves with its record id:\r\n   *             return obj.one('INSERT INTO images(data) VALUES($1) RETURNING id', data, a => a.id);\r\n   *         }\r\n   *     }\r\n   * };\r\n   *\r\n   * @example\r\n   *\r\n   * // It is best to extend the protocol by adding whole entity repositories to it as shown in the following example.\r\n   * // For a comprehensive example see https://github.com/vitaly-t/pg-promise-demo\r\n   *\r\n   * class UsersRepository {\r\n   *     constructor(rep, pgp) {\r\n   *         this.rep = rep;\r\n   *         this.pgp = pgp;\r\n   *     }\r\n   *\r\n   *     add(name) {\r\n   *         return this.rep.one('INSERT INTO users(name) VALUES($1) RETURNING id', name, a => a.id);\r\n   *     }\r\n   *\r\n   *     remove(id) {\r\n   *         return this.rep.none('DELETE FROM users WHERE id = $1', id);\r\n   *     }\r\n   * }\r\n   *\r\n   * // Overriding 'extend' event;\r\n   * const initOptions = {\r\n   *\r\n   *     // pg-promise initialization options...\r\n   *\r\n   *     extend(obj, dc) {\r\n   *         // dc = database context;\r\n   *         obj.users = new UsersRepository(obj, pgp);\r\n   *         // You can set different repositories based on `dc`\r\n   *     }\r\n   * };\r\n   *\r\n   * // Usage example:\r\n   * db.users.add('John', true)\r\n   *     .then(id => {\r\n   *         // user added successfully, id = new user's id\r\n   *     })\r\n   *     .catch(error => {\r\n   *         // failed to add the user;\r\n   *     });\r\n   *\r\n   */\n  static extend(options, obj, dc) {\n    if (typeof options.extend === 'function') {\n      try {\n        options.extend.call(obj, obj, dc);\n      } catch (e) {\n        // have to silence errors here;\n        // the result of throwing unhandled errors while\n        // extending the protocol would be unpredictable.\n        Events.unexpected('extend', e);\n      }\n    }\n  }\n\n  /**\r\n   * @event unexpected\r\n   * @param {string} event - unhandled event name.\r\n   * @param {string|Error} e - unhandled error.\r\n   * @private\r\n   */\n  static unexpected(event, e) {\n    // If you should ever get here, your app is definitely broken, and you need to fix\n    // your event handler to prevent unhandled errors during event notifications.\n    //\n    // Console output is suppressed when running tests, to avoid polluting test output\n    // with error messages that are intentional and of no value to the test.\n\n    /* istanbul ignore if */\n    if (!npm.main.suppressErrors) {\n      const stack = e instanceof Error ? e.stack : new Error().stack;\n      ColorConsole.error(`Unexpected error in '${event}' event handler.\\n${stack}\\n`);\n    }\n  }\n}\nmodule.exports = {\n  Events\n};\n\n/**\r\n * @typedef EventContext\r\n * @description\r\n * This common type is used for the following events: {@link event:query query}, {@link event:receive receive},\r\n * {@link event:error error}, {@link event:task task} and {@link event:transact transact}.\r\n *\r\n * @property {string|object} cn\r\n *\r\n * Set only for event {@link event:error error}, and only when the error is connection-related.\r\n *\r\n * It is a safe copy of the connection string/object that was used when initializing `db` - the database instance.\r\n *\r\n * If the original connection contains a password, the safe copy contains it masked with symbol `#`, so the connection\r\n * can be logged safely, without exposing the password.\r\n *\r\n * @property {*} dc\r\n * Database Context that was used when creating the database object (see {@link Database}). It is set for all events.\r\n *\r\n * @property {string|object} query\r\n *\r\n * Query string/object that was passed into the query method. This property is only set during events {@link event:query query},\r\n * {@link event:receive receive} and {@link event:error error} (only when the error is query-related).\r\n *\r\n * @property {external:Client} client\r\n *\r\n * $[pg.Client] object that represents the connection. It is set for all events, except for event {@link event:error error}\r\n * when it is connection-related. Note that sometimes the value may be unset when the connection is lost.\r\n *\r\n * @property {*} params - Formatting parameters for the query.\r\n *\r\n * It is set only for events {@link event:query query}, {@link event:receive receive} and {@link event:error error}, and only\r\n * when it is needed for logging. This library takes an extra step in figuring out when formatting parameters are of any value\r\n * to the event logging:\r\n * - when an error occurs related to the query formatting, event {@link event:error error} is sent with the property set.\r\n * - when initialization parameter `pgFormat` is used, and all query formatting is done within the $[PG] library, events\r\n * {@link event:query query} and {@link event:receive receive} will have this property set also, since this library no longer\r\n * handles the query formatting.\r\n *\r\n * When this parameter is not set, it means one of the two things:\r\n * - there were no parameters passed into the query method;\r\n * - property `query` of this object already contains all the formatting values in it, so logging only the query is sufficient.\r\n *\r\n * @property {TaskContext} ctx\r\n * _Task/Transaction Context_ object.\r\n *\r\n * This property is always set for events {@link event:task task} and {@link event:transact transact}, while for events\r\n * {@link event:query query}, {@link event:receive receive} and {@link event:error error} it is only set when they occur\r\n * inside a task or transaction.\r\n */","map":{"version":3,"names":["ColorConsole","require","npm","main","utils","Events","connect","ctx","client","useCount","options","dc","e","unexpected","disconnect","query","context","Error","InternalError","receive","data","result","task","transact","error","err","extend","obj","call","event","suppressErrors","stack","module","exports"],"sources":["/Users/luna/Library/Mobile Documents/com~apple~CloudDocs/GitHub/paucamcal.github.io/AESP/node_modules/pg-promise/lib/events.js"],"sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {ColorConsole} = require('./utils/color');\r\n\r\nconst npm = {\r\n    main: require('./'),\r\n    utils: require('./utils')\r\n};\r\n\r\n/////////////////////////////////\r\n// Client notification helpers;\r\nclass Events {\r\n\r\n    /**\r\n     * @event connect\r\n     * @description\r\n     * Global notification of acquiring a new database connection from the connection pool, i.e. a virtual connection.\r\n     *\r\n     * However, for direct calls to method {@link Database#connect Database.connect} with parameter `{direct: true}`,\r\n     * this event represents a physical connection.\r\n     *\r\n     * The library will suppress any error thrown by the handler and write it into the console.\r\n     *\r\n     * @param {{}} e Event Properties\r\n     *\r\n     * @param {external:Client} e.client\r\n     * $[pg.Client] object that represents the connection.\r\n     *\r\n     * @param {*} e.dc\r\n     * Database Context that was used when creating the database object (see {@link Database}).\r\n     *\r\n     * @param {number} e.useCount\r\n     * Number of times the connection has been previously used, starting with 0, for a freshly\r\n     * allocated physical connection.\r\n     *\r\n     * This parameter is always 0 for direct connections (created by calling {@link Database#connect Database.connect}\r\n     * with parameter `{direct: true}`).\r\n     *\r\n     * @example\r\n     *\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     connect(e) {\r\n     *         const cp = e.client.connectionParameters;\r\n     *         console.log('Connected to database:', cp.database);\r\n     *     }\r\n     *\r\n     * };\r\n     */\r\n    static connect(ctx, client, useCount) {\r\n        if (typeof ctx.options.connect === 'function') {\r\n            try {\r\n                ctx.options.connect({client, dc: ctx.dc, useCount});\r\n            } catch (e) {\r\n                // have to silence errors here;\r\n                // cannot allow unhandled errors while connecting to the database,\r\n                // as it will break the connection logic;\r\n                Events.unexpected('connect', e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @event disconnect\r\n     * @description\r\n     * Global notification of releasing a database connection back to the connection pool, i.e. releasing the virtual connection.\r\n     *\r\n     * However, when releasing a direct connection (created by calling {@link Database#connect Database.connect} with parameter\r\n     * `{direct: true}`), this event represents a physical disconnection.\r\n     *\r\n     * The library will suppress any error thrown by the handler and write it into the console.\r\n     *\r\n     * @param {{}} e Event Properties\r\n     *\r\n     * @param {external:Client} e.client - $[pg.Client] object that represents connection with the database.\r\n     *\r\n     * @param {*} e.dc - Database Context that was used when creating the database object (see {@link Database}).\r\n     *\r\n     * @example\r\n     *\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     disconnect(e) {\r\n     *        const cp = e.client.connectionParameters;\r\n     *        console.log('Disconnecting from database:', cp.database);\r\n     *     }\r\n     *\r\n     * };\r\n     */\r\n    static disconnect(ctx, client) {\r\n        if (typeof ctx.options.disconnect === 'function') {\r\n            try {\r\n                ctx.options.disconnect({client, dc: ctx.dc});\r\n            } catch (e) {\r\n                // have to silence errors here;\r\n                // cannot allow unhandled errors while disconnecting from the database,\r\n                // as it will break the disconnection logic;\r\n                Events.unexpected('disconnect', e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @event query\r\n     * @description\r\n     *\r\n     * Global notification of a query that's about to execute.\r\n     *\r\n     * Notification happens just before the query execution. And if the handler throws an error, the query execution\r\n     * will be rejected with that error.\r\n     *\r\n     * @param {EventContext} e\r\n     * Event Context Object.\r\n     *\r\n     * @example\r\n     *\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     query(e) {\r\n     *         console.log('QUERY:', e.query);\r\n     *     }\r\n     * };\r\n     */\r\n    static query(options, context) {\r\n        if (typeof options.query === 'function') {\r\n            try {\r\n                options.query(context);\r\n            } catch (e) {\r\n                // throwing an error during event 'query'\r\n                // will result in a reject for the request.\r\n                return e instanceof Error ? e : new npm.utils.InternalError(e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @event receive\r\n     * @description\r\n     * Global notification of any data received from the database, coming from a regular query or from a stream.\r\n     *\r\n     * The event is fired before the data reaches the client, and it serves two purposes:\r\n     *  - Providing selective data logging for debugging;\r\n     *  - Pre-processing data before it reaches the client.\r\n     *\r\n     * **NOTES:**\r\n     * - If you alter the size of `data` directly or through the `result` object, it may affect `QueryResultMask`\r\n     *   validation for regular queries, which is executed right after.\r\n     * - Any data pre-processing needs to be fast here, to avoid performance penalties.\r\n     * - If the event handler throws an error, the original request will be rejected with that error.\r\n     *\r\n     * For methods {@link Database#multi Database.multi} and {@link Database#multiResult Database.multiResult},\r\n     * this event is called for every result that's returned. And for method {@link Database#stream Database.stream},\r\n     * the event occurs for every record.\r\n     *\r\n     * @param {{}} e Event Properties\r\n     *\r\n     * @param {Array<Object>} e.data\r\n     * Array of received objects/rows.\r\n     *\r\n     * If any of those objects are modified during notification, the client will receive the modified data.\r\n     *\r\n     * @param {external:Result} e.result\r\n     * - Original $[Result] object, if the data is from a non-stream query, in which case `data = result.rows`.\r\n     *   For single-query requests, $[Result] object is extended with property `duration` - number of milliseconds\r\n     *   it took to send the query, execute it and get the result back.\r\n     * - It is `undefined` when the data comes from a stream (method {@link Database#stream Database.stream}).\r\n     *\r\n     * @param {EventContext} e.ctx\r\n     * Event Context Object.\r\n     *\r\n     * @example\r\n     *\r\n     * // Example below shows the fastest way to camelize all column names.\r\n     * // NOTE: The example does not do processing for nested JSON objects.\r\n     *\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     receive(e) {\r\n     *         camelizeColumns(e.data);\r\n     *     }\r\n     * };\r\n     *\r\n     * function camelizeColumns(data) {\r\n     *     const tmp = data[0];\r\n     *     for (const prop in tmp) {\r\n     *         const camel = pgp.utils.camelize(prop);\r\n     *         if (!(camel in tmp)) {\r\n     *             for (let i = 0; i < data.length; i++) {\r\n     *                 const d = data[i];\r\n     *                 d[camel] = d[prop];\r\n     *                 delete d[prop];\r\n     *             }\r\n     *         }\r\n     *     }\r\n     * }\r\n     */\r\n    static receive(options, data, result, ctx) {\r\n        if (typeof options.receive === 'function') {\r\n            try {\r\n                options.receive({data, result, ctx});\r\n            } catch (e) {\r\n                // throwing an error during event 'receive'\r\n                // will result in a reject for the request.\r\n                return e instanceof Error ? e : new npm.utils.InternalError(e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @event task\r\n     * @description\r\n     * Global notification of a task start / finish events, as executed via\r\n     * {@link Database#task Database.task} or {@link Database#taskIf Database.taskIf}.\r\n     *\r\n     * The library will suppress any error thrown by the handler and write it into the console.\r\n     *\r\n     * @param {EventContext} e\r\n     * Event Context Object.\r\n     *\r\n     * @example\r\n     *\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     task(e) {\r\n     *         if (e.ctx.finish) {\r\n     *             // this is a task->finish event;\r\n     *             console.log('Duration:', e.ctx.duration);\r\n     *             if (e.ctx.success) {\r\n     *                 // e.ctx.result = resolved data;\r\n     *             } else {\r\n     *                 // e.ctx.result = error/rejection reason;\r\n     *             }\r\n     *         } else {\r\n     *             // this is a task->start event;\r\n     *             console.log('Start Time:', e.ctx.start);\r\n     *         }\r\n     *     }\r\n     * };\r\n     *\r\n     */\r\n    static task(options, context) {\r\n        if (typeof options.task === 'function') {\r\n            try {\r\n                options.task(context);\r\n            } catch (e) {\r\n                // silencing the error, to avoid breaking the task;\r\n                Events.unexpected('task', e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @event transact\r\n     * @description\r\n     * Global notification of a transaction start / finish events, as executed via {@link Database#tx Database.tx}\r\n     * or {@link Database#txIf Database.txIf}.\r\n     *\r\n     * The library will suppress any error thrown by the handler and write it into the console.\r\n     *\r\n     * @param {EventContext} e\r\n     * Event Context Object.\r\n     *\r\n     * @example\r\n     *\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     transact(e) {\r\n     *         if (e.ctx.finish) {\r\n     *             // this is a transaction->finish event;\r\n     *             console.log('Duration:', e.ctx.duration);\r\n     *             if (e.ctx.success) {\r\n     *                 // e.ctx.result = resolved data;\r\n     *             } else {\r\n     *                 // e.ctx.result = error/rejection reason;\r\n     *             }\r\n     *         } else {\r\n     *             // this is a transaction->start event;\r\n     *             console.log('Start Time:', e.ctx.start);\r\n     *         }\r\n     *     }\r\n     * };\r\n     *\r\n     */\r\n    static transact(options, context) {\r\n        if (typeof options.transact === 'function') {\r\n            try {\r\n                options.transact(context);\r\n            } catch (e) {\r\n                // silencing the error, to avoid breaking the transaction;\r\n                Events.unexpected('transact', e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @event error\r\n     * @description\r\n     * Global notification of every error encountered by this library.\r\n     *\r\n     * The library will suppress any error thrown by the handler and write it into the console.\r\n     *\r\n     * @param {*} err\r\n     * The error encountered, of the same value and type as it was reported.\r\n     *\r\n     * @param {EventContext} e\r\n     * Event Context Object.\r\n     *\r\n     * @example\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     error(err, e) {\r\n     *\r\n     *         if (e.cn) {\r\n     *             // this is a connection-related error\r\n     *             // cn = safe connection details passed into the library:\r\n     *             //      if password is present, it is masked by #\r\n     *         }\r\n     *\r\n     *         if (e.query) {\r\n     *             // query string is available\r\n     *             if (e.params) {\r\n     *                 // query parameters are available\r\n     *             }\r\n     *         }\r\n     *\r\n     *         if (e.ctx) {\r\n     *             // occurred inside a task or transaction\r\n     *         }\r\n     *       }\r\n     * };\r\n     *\r\n     */\r\n    static error(options, err, context) {\r\n        if (typeof options.error === 'function') {\r\n            try {\r\n                options.error(err, context);\r\n            } catch (e) {\r\n                // have to silence errors here;\r\n                // throwing unhandled errors while handling an error\r\n                // notification is simply not acceptable.\r\n                Events.unexpected('error', e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @event extend\r\n     * @description\r\n     * Extends {@link Database} protocol with custom methods and properties.\r\n     *\r\n     * Override this event to extend the existing access layer with your own functions and\r\n     * properties best suited for your application.\r\n     *\r\n     * The extension thus becomes available across all access layers:\r\n     *\r\n     * - Within the root/default database protocol;\r\n     * - Inside transactions, including nested ones;\r\n     * - Inside tasks, including nested ones.\r\n     *\r\n     * All pre-defined methods and properties are read-only, so you will get an error,\r\n     * if you try overriding them.\r\n     *\r\n     * The library will suppress any error thrown by the handler and write it into the console.\r\n     *\r\n     * @param {object} obj - Protocol object to be extended.\r\n     *\r\n     * @param {*} dc - Database Context that was used when creating the {@link Database} object.\r\n     *\r\n     * @see $[pg-promise-demo]\r\n     *\r\n     * @example\r\n     *\r\n     * // In the example below we extend the protocol with function `addImage`\r\n     * // that will insert one binary image and resolve with the new record id.\r\n     *\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     extend(obj, dc) {\r\n     *         // dc = database context;\r\n     *         obj.addImage = data => {\r\n     *             // adds a new image and resolves with its record id:\r\n     *             return obj.one('INSERT INTO images(data) VALUES($1) RETURNING id', data, a => a.id);\r\n     *         }\r\n     *     }\r\n     * };\r\n     *\r\n     * @example\r\n     *\r\n     * // It is best to extend the protocol by adding whole entity repositories to it as shown in the following example.\r\n     * // For a comprehensive example see https://github.com/vitaly-t/pg-promise-demo\r\n     *\r\n     * class UsersRepository {\r\n     *     constructor(rep, pgp) {\r\n     *         this.rep = rep;\r\n     *         this.pgp = pgp;\r\n     *     }\r\n     *\r\n     *     add(name) {\r\n     *         return this.rep.one('INSERT INTO users(name) VALUES($1) RETURNING id', name, a => a.id);\r\n     *     }\r\n     *\r\n     *     remove(id) {\r\n     *         return this.rep.none('DELETE FROM users WHERE id = $1', id);\r\n     *     }\r\n     * }\r\n     *\r\n     * // Overriding 'extend' event;\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     extend(obj, dc) {\r\n     *         // dc = database context;\r\n     *         obj.users = new UsersRepository(obj, pgp);\r\n     *         // You can set different repositories based on `dc`\r\n     *     }\r\n     * };\r\n     *\r\n     * // Usage example:\r\n     * db.users.add('John', true)\r\n     *     .then(id => {\r\n     *         // user added successfully, id = new user's id\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // failed to add the user;\r\n     *     });\r\n     *\r\n     */\r\n    static extend(options, obj, dc) {\r\n        if (typeof options.extend === 'function') {\r\n            try {\r\n                options.extend.call(obj, obj, dc);\r\n            } catch (e) {\r\n                // have to silence errors here;\r\n                // the result of throwing unhandled errors while\r\n                // extending the protocol would be unpredictable.\r\n                Events.unexpected('extend', e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @event unexpected\r\n     * @param {string} event - unhandled event name.\r\n     * @param {string|Error} e - unhandled error.\r\n     * @private\r\n     */\r\n    static unexpected(event, e) {\r\n        // If you should ever get here, your app is definitely broken, and you need to fix\r\n        // your event handler to prevent unhandled errors during event notifications.\r\n        //\r\n        // Console output is suppressed when running tests, to avoid polluting test output\r\n        // with error messages that are intentional and of no value to the test.\r\n\r\n        /* istanbul ignore if */\r\n        if (!npm.main.suppressErrors) {\r\n            const stack = e instanceof Error ? e.stack : new Error().stack;\r\n            ColorConsole.error(`Unexpected error in '${event}' event handler.\\n${stack}\\n`);\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = {Events};\r\n\r\n/**\r\n * @typedef EventContext\r\n * @description\r\n * This common type is used for the following events: {@link event:query query}, {@link event:receive receive},\r\n * {@link event:error error}, {@link event:task task} and {@link event:transact transact}.\r\n *\r\n * @property {string|object} cn\r\n *\r\n * Set only for event {@link event:error error}, and only when the error is connection-related.\r\n *\r\n * It is a safe copy of the connection string/object that was used when initializing `db` - the database instance.\r\n *\r\n * If the original connection contains a password, the safe copy contains it masked with symbol `#`, so the connection\r\n * can be logged safely, without exposing the password.\r\n *\r\n * @property {*} dc\r\n * Database Context that was used when creating the database object (see {@link Database}). It is set for all events.\r\n *\r\n * @property {string|object} query\r\n *\r\n * Query string/object that was passed into the query method. This property is only set during events {@link event:query query},\r\n * {@link event:receive receive} and {@link event:error error} (only when the error is query-related).\r\n *\r\n * @property {external:Client} client\r\n *\r\n * $[pg.Client] object that represents the connection. It is set for all events, except for event {@link event:error error}\r\n * when it is connection-related. Note that sometimes the value may be unset when the connection is lost.\r\n *\r\n * @property {*} params - Formatting parameters for the query.\r\n *\r\n * It is set only for events {@link event:query query}, {@link event:receive receive} and {@link event:error error}, and only\r\n * when it is needed for logging. This library takes an extra step in figuring out when formatting parameters are of any value\r\n * to the event logging:\r\n * - when an error occurs related to the query formatting, event {@link event:error error} is sent with the property set.\r\n * - when initialization parameter `pgFormat` is used, and all query formatting is done within the $[PG] library, events\r\n * {@link event:query query} and {@link event:receive receive} will have this property set also, since this library no longer\r\n * handles the query formatting.\r\n *\r\n * When this parameter is not set, it means one of the two things:\r\n * - there were no parameters passed into the query method;\r\n * - property `query` of this object already contains all the formatting values in it, so logging only the query is sufficient.\r\n *\r\n * @property {TaskContext} ctx\r\n * _Task/Transaction Context_ object.\r\n *\r\n * This property is always set for events {@link event:task task} and {@link event:transact transact}, while for events\r\n * {@link event:query query}, {@link event:receive receive} and {@link event:error error} it is only set when they occur\r\n * inside a task or transaction.\r\n */\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM;EAACA;AAAY,CAAC,GAAGC,OAAO,CAAC,eAAe,CAAC;AAE/C,MAAMC,GAAG,GAAG;EACRC,IAAI,EAAEF,OAAO,CAAC,IAAI,CAAC;EACnBG,KAAK,EAAEH,OAAO,CAAC,SAAS;AAC5B,CAAC;;AAED;AACA;AACA,MAAMI,MAAM,CAAC;EAET;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOC,OAAOA,CAACC,GAAG,EAAEC,MAAM,EAAEC,QAAQ,EAAE;IAClC,IAAI,OAAOF,GAAG,CAACG,OAAO,CAACJ,OAAO,KAAK,UAAU,EAAE;MAC3C,IAAI;QACAC,GAAG,CAACG,OAAO,CAACJ,OAAO,CAAC;UAACE,MAAM;UAAEG,EAAE,EAAEJ,GAAG,CAACI,EAAE;UAAEF;QAAQ,CAAC,CAAC;MACvD,CAAC,CAAC,OAAOG,CAAC,EAAE;QACR;QACA;QACA;QACAP,MAAM,CAACQ,UAAU,CAAC,SAAS,EAAED,CAAC,CAAC;MACnC;IACJ;EACJ;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOE,UAAUA,CAACP,GAAG,EAAEC,MAAM,EAAE;IAC3B,IAAI,OAAOD,GAAG,CAACG,OAAO,CAACI,UAAU,KAAK,UAAU,EAAE;MAC9C,IAAI;QACAP,GAAG,CAACG,OAAO,CAACI,UAAU,CAAC;UAACN,MAAM;UAAEG,EAAE,EAAEJ,GAAG,CAACI;QAAE,CAAC,CAAC;MAChD,CAAC,CAAC,OAAOC,CAAC,EAAE;QACR;QACA;QACA;QACAP,MAAM,CAACQ,UAAU,CAAC,YAAY,EAAED,CAAC,CAAC;MACtC;IACJ;EACJ;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOG,KAAKA,CAACL,OAAO,EAAEM,OAAO,EAAE;IAC3B,IAAI,OAAON,OAAO,CAACK,KAAK,KAAK,UAAU,EAAE;MACrC,IAAI;QACAL,OAAO,CAACK,KAAK,CAACC,OAAO,CAAC;MAC1B,CAAC,CAAC,OAAOJ,CAAC,EAAE;QACR;QACA;QACA,OAAOA,CAAC,YAAYK,KAAK,GAAGL,CAAC,GAAG,IAAIV,GAAG,CAACE,KAAK,CAACc,aAAa,CAACN,CAAC,CAAC;MAClE;IACJ;EACJ;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOO,OAAOA,CAACT,OAAO,EAAEU,IAAI,EAAEC,MAAM,EAAEd,GAAG,EAAE;IACvC,IAAI,OAAOG,OAAO,CAACS,OAAO,KAAK,UAAU,EAAE;MACvC,IAAI;QACAT,OAAO,CAACS,OAAO,CAAC;UAACC,IAAI;UAAEC,MAAM;UAAEd;QAAG,CAAC,CAAC;MACxC,CAAC,CAAC,OAAOK,CAAC,EAAE;QACR;QACA;QACA,OAAOA,CAAC,YAAYK,KAAK,GAAGL,CAAC,GAAG,IAAIV,GAAG,CAACE,KAAK,CAACc,aAAa,CAACN,CAAC,CAAC;MAClE;IACJ;EACJ;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOU,IAAIA,CAACZ,OAAO,EAAEM,OAAO,EAAE;IAC1B,IAAI,OAAON,OAAO,CAACY,IAAI,KAAK,UAAU,EAAE;MACpC,IAAI;QACAZ,OAAO,CAACY,IAAI,CAACN,OAAO,CAAC;MACzB,CAAC,CAAC,OAAOJ,CAAC,EAAE;QACR;QACAP,MAAM,CAACQ,UAAU,CAAC,MAAM,EAAED,CAAC,CAAC;MAChC;IACJ;EACJ;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOW,QAAQA,CAACb,OAAO,EAAEM,OAAO,EAAE;IAC9B,IAAI,OAAON,OAAO,CAACa,QAAQ,KAAK,UAAU,EAAE;MACxC,IAAI;QACAb,OAAO,CAACa,QAAQ,CAACP,OAAO,CAAC;MAC7B,CAAC,CAAC,OAAOJ,CAAC,EAAE;QACR;QACAP,MAAM,CAACQ,UAAU,CAAC,UAAU,EAAED,CAAC,CAAC;MACpC;IACJ;EACJ;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOY,KAAKA,CAACd,OAAO,EAAEe,GAAG,EAAET,OAAO,EAAE;IAChC,IAAI,OAAON,OAAO,CAACc,KAAK,KAAK,UAAU,EAAE;MACrC,IAAI;QACAd,OAAO,CAACc,KAAK,CAACC,GAAG,EAAET,OAAO,CAAC;MAC/B,CAAC,CAAC,OAAOJ,CAAC,EAAE;QACR;QACA;QACA;QACAP,MAAM,CAACQ,UAAU,CAAC,OAAO,EAAED,CAAC,CAAC;MACjC;IACJ;EACJ;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOc,MAAMA,CAAChB,OAAO,EAAEiB,GAAG,EAAEhB,EAAE,EAAE;IAC5B,IAAI,OAAOD,OAAO,CAACgB,MAAM,KAAK,UAAU,EAAE;MACtC,IAAI;QACAhB,OAAO,CAACgB,MAAM,CAACE,IAAI,CAACD,GAAG,EAAEA,GAAG,EAAEhB,EAAE,CAAC;MACrC,CAAC,CAAC,OAAOC,CAAC,EAAE;QACR;QACA;QACA;QACAP,MAAM,CAACQ,UAAU,CAAC,QAAQ,EAAED,CAAC,CAAC;MAClC;IACJ;EACJ;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACI,OAAOC,UAAUA,CAACgB,KAAK,EAAEjB,CAAC,EAAE;IACxB;IACA;IACA;IACA;IACA;;IAEA;IACA,IAAI,CAACV,GAAG,CAACC,IAAI,CAAC2B,cAAc,EAAE;MAC1B,MAAMC,KAAK,GAAGnB,CAAC,YAAYK,KAAK,GAAGL,CAAC,CAACmB,KAAK,GAAG,IAAId,KAAK,CAAC,CAAC,CAACc,KAAK;MAC9D/B,YAAY,CAACwB,KAAK,CAAE,wBAAuBK,KAAM,qBAAoBE,KAAM,IAAG,CAAC;IACnF;EACJ;AACJ;AAEAC,MAAM,CAACC,OAAO,GAAG;EAAC5B;AAAM,CAAC;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"script","externalDependencies":[]}