{"ast":null,"code":"const npm = {\n  stat: require('./static')\n};\nmodule.exports = function ($p) {\n  const exp = {\n    formatError: npm.stat.formatError,\n    isPromise: npm.stat.isPromise,\n    isReadableStream: npm.stat.isReadableStream,\n    messageGap: npm.stat.messageGap,\n    extend: npm.stat.extend,\n    resolve: resolve,\n    wrap: wrap\n  };\n  return exp;\n\n  //////////////////////////////////////////\n  // Checks if the function is a generator,\n  // and if so - wraps it up into a promise;\n  function wrap(func) {\n    if (typeof func === 'function') {\n      if (func.constructor.name === 'GeneratorFunction') {\n        return asyncAdapter(func);\n      }\n      return func;\n    }\n    return null;\n  }\n\n  /////////////////////////////////////////////////////\n  // Resolves a mixed value into the actual value,\n  // consistent with the way mixed values are defined:\n  // https://github.com/vitaly-t/spex/wiki/Mixed-Values\n  function resolve(value, params, onSuccess, onError) {\n    const self = this;\n    let delayed = false;\n    function loop() {\n      while (typeof value === 'function') {\n        if (value.constructor.name === 'GeneratorFunction') {\n          value = asyncAdapter(value);\n        }\n        try {\n          value = params ? value.apply(self, params) : value.call(self);\n        } catch (e) {\n          onError(e, false); // false means 'threw an error'\n          return;\n        }\n      }\n      if (exp.isPromise(value)) {\n        value.then(data => {\n          delayed = true;\n          value = data;\n          loop();\n          return null; // this dummy return is just to prevent Bluebird warnings;\n        }).catch(error => {\n          onError(error, true); // true means 'rejected'\n        });\n      } else {\n        onSuccess(value, delayed);\n      }\n    }\n    loop();\n  }\n\n  // Generator-to-Promise adapter;\n  // Based on: https://www.promisejs.org/generators/#both\n  function asyncAdapter(generator) {\n    return function () {\n      const g = generator.apply(this, arguments);\n      function handle(result) {\n        if (result.done) {\n          return $p.resolve(result.value);\n        }\n        return $p.resolve(result.value).then(res => handle(g.next(res)), err => handle(g.throw(err)));\n      }\n      return handle(g.next());\n    };\n  }\n};","map":{"version":3,"names":["npm","stat","require","module","exports","$p","exp","formatError","isPromise","isReadableStream","messageGap","extend","resolve","wrap","func","constructor","name","asyncAdapter","value","params","onSuccess","onError","self","delayed","loop","apply","call","e","then","data","catch","error","generator","g","arguments","handle","result","done","res","next","err","throw"],"sources":["/Users/luna/Library/Mobile Documents/com~apple~CloudDocs/GitHub/paucamcal.github.io/AESP/node_modules/spex/lib/utils/index.js"],"sourcesContent":["const npm = {\r\n    stat: require('./static')\r\n};\r\n\r\nmodule.exports = function ($p) {\r\n\r\n    const exp = {\r\n        formatError: npm.stat.formatError,\r\n        isPromise: npm.stat.isPromise,\r\n        isReadableStream: npm.stat.isReadableStream,\r\n        messageGap: npm.stat.messageGap,\r\n        extend: npm.stat.extend,\r\n        resolve: resolve,\r\n        wrap: wrap\r\n    };\r\n\r\n    return exp;\r\n\r\n    //////////////////////////////////////////\r\n    // Checks if the function is a generator,\r\n    // and if so - wraps it up into a promise;\r\n    function wrap(func) {\r\n        if (typeof func === 'function') {\r\n            if (func.constructor.name === 'GeneratorFunction') {\r\n                return asyncAdapter(func);\r\n            }\r\n            return func;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /////////////////////////////////////////////////////\r\n    // Resolves a mixed value into the actual value,\r\n    // consistent with the way mixed values are defined:\r\n    // https://github.com/vitaly-t/spex/wiki/Mixed-Values\r\n    function resolve(value, params, onSuccess, onError) {\r\n\r\n        const self = this;\r\n        let delayed = false;\r\n\r\n        function loop() {\r\n            while (typeof value === 'function') {\r\n                if (value.constructor.name === 'GeneratorFunction') {\r\n                    value = asyncAdapter(value);\r\n                }\r\n                try {\r\n                    value = params ? value.apply(self, params) : value.call(self);\r\n                } catch (e) {\r\n                    onError(e, false); // false means 'threw an error'\r\n                    return;\r\n                }\r\n            }\r\n            if (exp.isPromise(value)) {\r\n                value\r\n                    .then(data => {\r\n                        delayed = true;\r\n                        value = data;\r\n                        loop();\r\n                        return null; // this dummy return is just to prevent Bluebird warnings;\r\n                    })\r\n                    .catch(error => {\r\n                        onError(error, true); // true means 'rejected'\r\n                    });\r\n            } else {\r\n                onSuccess(value, delayed);\r\n            }\r\n        }\r\n\r\n        loop();\r\n    }\r\n\r\n    // Generator-to-Promise adapter;\r\n    // Based on: https://www.promisejs.org/generators/#both\r\n    function asyncAdapter(generator) {\r\n        return function () {\r\n            const g = generator.apply(this, arguments);\r\n\r\n            function handle(result) {\r\n                if (result.done) {\r\n                    return $p.resolve(result.value);\r\n                }\r\n                return $p.resolve(result.value)\r\n                    .then(res => handle(g.next(res)), err => handle(g.throw(err)));\r\n            }\r\n\r\n            return handle(g.next());\r\n        };\r\n    }\r\n\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}