{"ast":null,"code":"const {\n  parsingErrorCode,\n  SQLParsingError\n} = require('./error');\nconst {\n  getIndexPos\n} = require('./utils');\n\n// symbols that need no spaces around them:\nconst compressors = '.,;:()[]=<>+-*/|!?@#';\n\n////////////////////////////////////////////\n// Parses and minimizes a PostgreSQL script.\nfunction minify(sql, options) {\n  if (typeof sql !== 'string') {\n    throw new TypeError('Input SQL must be a text string.');\n  }\n  if (!sql.length) {\n    return '';\n  }\n  sql = sql.replace(/\\r\\n/g, '\\n');\n  options = options || {};\n  let idx = 0,\n    // current index\n    result = '',\n    // resulting sql\n    space = false; // add a space on the next step\n\n  const len = sql.length;\n  do {\n    const s = sql[idx],\n      // current symbol;\n      s1 = sql[idx + 1]; // next symbol;\n\n    if (isGap(s)) {\n      while (++idx < len && isGap(sql[idx]));\n      if (idx < len) {\n        space = true;\n      }\n      idx--;\n      continue;\n    }\n    if (s === '-' && s1 === '-') {\n      const lb = sql.indexOf('\\n', idx + 2);\n      if (lb < 0) {\n        break;\n      }\n      idx = lb - 1;\n      skipGaps();\n      continue;\n    }\n    if (s === '/' && s1 === '*') {\n      let c = idx + 1,\n        open = 0,\n        close = 0,\n        lastOpen,\n        lastClose;\n      while (++c < len - 1 && close <= open) {\n        if (sql[c] === '/' && sql[c + 1] === '*') {\n          lastOpen = c;\n          open++;\n          c++;\n        } else {\n          if (sql[c] === '*' && sql[c + 1] === '/') {\n            lastClose = c;\n            close++;\n            c++;\n          }\n        }\n      }\n      if (close <= open) {\n        idx = lastOpen;\n        throwError(parsingErrorCode.unclosedMLC);\n      }\n      if (sql[idx + 2] === '!' && !options.removeAll) {\n        if (options.compress) {\n          space = false;\n        }\n        addSpace();\n        result += sql.substring(idx, lastClose + 2).replace(/\\n/g, '\\r\\n');\n      }\n      idx = lastClose + 1;\n      skipGaps();\n      continue;\n    }\n    let closeIdx, text;\n    if (s === '\"') {\n      closeIdx = sql.indexOf('\"', idx + 1);\n      if (closeIdx < 0) {\n        throwError(parsingErrorCode.unclosedQI);\n      }\n      text = sql.substring(idx, closeIdx + 1);\n      if (text.indexOf('\\n') > 0) {\n        throwError(parsingErrorCode.multiLineQI);\n      }\n      if (options.compress) {\n        space = false;\n      }\n      addSpace();\n      result += text;\n      idx = closeIdx;\n      skipGaps();\n      continue;\n    }\n    if (s === `'`) {\n      closeIdx = idx;\n      do {\n        closeIdx = sql.indexOf(`'`, closeIdx + 1);\n        if (closeIdx > 0) {\n          let i = closeIdx;\n          while (sql[--i] === '\\\\');\n          if ((closeIdx - i) % 2) {\n            let step = closeIdx;\n            while (++step < len && sql[step] === `'`);\n            if ((step - closeIdx) % 2) {\n              closeIdx = step - 1;\n              break;\n            }\n            closeIdx = step === len ? -1 : step;\n          }\n        }\n      } while (closeIdx > 0);\n      if (closeIdx < 0) {\n        throwError(parsingErrorCode.unclosedText);\n      }\n      if (options.compress) {\n        space = false;\n      }\n      addSpace();\n      text = sql.substring(idx, closeIdx + 1);\n      const hasLB = text.indexOf('\\n') > 0;\n      if (hasLB) {\n        text = text.split('\\n').map(m => {\n          return m.replace(/^\\s+|\\s+$/g, '');\n        }).join('\\\\n');\n      }\n      const hasTabs = text.indexOf('\\t') > 0;\n      if (hasLB || hasTabs) {\n        const prev = idx ? sql[idx - 1] : '';\n        if (prev !== 'E' && prev !== 'e') {\n          const r = result ? result[result.length - 1] : '';\n          if (r && r !== ' ' && compressors.indexOf(r) < 0) {\n            result += ' ';\n          }\n          result += 'E';\n        }\n        if (hasTabs) {\n          text = text.replace(/\\t/g, '\\\\t');\n        }\n      }\n      result += text;\n      idx = closeIdx;\n      skipGaps();\n      continue;\n    }\n    if (options.compress && compressors.indexOf(s) >= 0) {\n      space = false;\n      skipGaps();\n    }\n    addSpace();\n    result += s;\n  } while (++idx < len);\n  return result;\n  function skipGaps() {\n    if (options.compress) {\n      while (idx < len - 1 && isGap(sql[idx + 1]) && idx++);\n    }\n  }\n  function addSpace() {\n    if (space) {\n      if (result.length) {\n        result += ' ';\n      }\n      space = false;\n    }\n  }\n  function throwError(code) {\n    const position = getIndexPos(sql, idx);\n    throw new SQLParsingError(code, position);\n  }\n}\n\n////////////////////////////////////\n// Identifies a gap / empty symbol.\nfunction isGap(s) {\n  return s === ' ' || s === '\\t' || s === '\\r' || s === '\\n';\n}\nmodule.exports = minify;","map":{"version":3,"names":["parsingErrorCode","SQLParsingError","require","getIndexPos","compressors","minify","sql","options","TypeError","length","replace","idx","result","space","len","s","s1","isGap","lb","indexOf","skipGaps","c","open","close","lastOpen","lastClose","throwError","unclosedMLC","removeAll","compress","addSpace","substring","closeIdx","text","unclosedQI","multiLineQI","i","step","unclosedText","hasLB","split","map","m","join","hasTabs","prev","r","code","position","module","exports"],"sources":["/Users/luna/Library/Mobile Documents/com~apple~CloudDocs/GitHub/paucamcal.github.io/AESP/node_modules/pg-minify/lib/parser.js"],"sourcesContent":["const {parsingErrorCode, SQLParsingError} = require('./error');\r\nconst {getIndexPos} = require('./utils');\r\n\r\n// symbols that need no spaces around them:\r\nconst compressors = '.,;:()[]=<>+-*/|!?@#';\r\n\r\n////////////////////////////////////////////\r\n// Parses and minimizes a PostgreSQL script.\r\nfunction minify(sql, options) {\r\n\r\n    if (typeof sql !== 'string') {\r\n        throw new TypeError('Input SQL must be a text string.');\r\n    }\r\n\r\n    if (!sql.length) {\r\n        return '';\r\n    }\r\n\r\n    sql = sql.replace(/\\r\\n/g, '\\n');\r\n\r\n    options = options || {};\r\n\r\n    let idx = 0, // current index\r\n        result = '', // resulting sql\r\n        space = false; // add a space on the next step\r\n\r\n    const len = sql.length;\r\n\r\n    do {\r\n        const s = sql[idx], // current symbol;\r\n            s1 = sql[idx + 1]; // next symbol;\r\n\r\n        if (isGap(s)) {\r\n            while (++idx < len && isGap(sql[idx])) ;\r\n            if (idx < len) {\r\n                space = true;\r\n            }\r\n            idx--;\r\n            continue;\r\n        }\r\n\r\n        if (s === '-' && s1 === '-') {\r\n            const lb = sql.indexOf('\\n', idx + 2);\r\n            if (lb < 0) {\r\n                break;\r\n            }\r\n            idx = lb - 1;\r\n            skipGaps();\r\n            continue;\r\n        }\r\n\r\n        if (s === '/' && s1 === '*') {\r\n            let c = idx + 1, open = 0, close = 0, lastOpen, lastClose;\r\n            while (++c < len - 1 && close <= open) {\r\n                if (sql[c] === '/' && sql[c + 1] === '*') {\r\n                    lastOpen = c;\r\n                    open++;\r\n                    c++;\r\n                } else {\r\n                    if (sql[c] === '*' && sql[c + 1] === '/') {\r\n                        lastClose = c;\r\n                        close++;\r\n                        c++;\r\n                    }\r\n                }\r\n            }\r\n            if (close <= open) {\r\n                idx = lastOpen;\r\n                throwError(parsingErrorCode.unclosedMLC);\r\n            }\r\n            if (sql[idx + 2] === '!' && !options.removeAll) {\r\n                if (options.compress) {\r\n                    space = false;\r\n                }\r\n                addSpace();\r\n                result += sql.substring(idx, lastClose + 2)\r\n                    .replace(/\\n/g, '\\r\\n');\r\n            }\r\n            idx = lastClose + 1;\r\n            skipGaps();\r\n            continue;\r\n        }\r\n\r\n        let closeIdx, text;\r\n\r\n        if (s === '\"') {\r\n            closeIdx = sql.indexOf('\"', idx + 1);\r\n            if (closeIdx < 0) {\r\n                throwError(parsingErrorCode.unclosedQI);\r\n            }\r\n            text = sql.substring(idx, closeIdx + 1);\r\n            if (text.indexOf('\\n') > 0) {\r\n                throwError(parsingErrorCode.multiLineQI);\r\n            }\r\n            if (options.compress) {\r\n                space = false;\r\n            }\r\n            addSpace();\r\n            result += text;\r\n            idx = closeIdx;\r\n            skipGaps();\r\n            continue;\r\n        }\r\n\r\n        if (s === `'`) {\r\n            closeIdx = idx;\r\n            do {\r\n                closeIdx = sql.indexOf(`'`, closeIdx + 1);\r\n                if (closeIdx > 0) {\r\n                    let i = closeIdx;\r\n                    while (sql[--i] === '\\\\') ;\r\n                    if ((closeIdx - i) % 2) {\r\n                        let step = closeIdx;\r\n                        while (++step < len && sql[step] === `'`) ;\r\n                        if ((step - closeIdx) % 2) {\r\n                            closeIdx = step - 1;\r\n                            break;\r\n                        }\r\n                        closeIdx = step === len ? -1 : step;\r\n                    }\r\n                }\r\n            } while (closeIdx > 0);\r\n            if (closeIdx < 0) {\r\n                throwError(parsingErrorCode.unclosedText);\r\n            }\r\n            if (options.compress) {\r\n                space = false;\r\n            }\r\n            addSpace();\r\n            text = sql.substring(idx, closeIdx + 1);\r\n            const hasLB = text.indexOf('\\n') > 0;\r\n            if (hasLB) {\r\n                text = text.split('\\n').map(m => {\r\n                    return m.replace(/^\\s+|\\s+$/g, '');\r\n                }).join('\\\\n');\r\n            }\r\n            const hasTabs = text.indexOf('\\t') > 0;\r\n            if (hasLB || hasTabs) {\r\n                const prev = idx ? sql[idx - 1] : '';\r\n                if (prev !== 'E' && prev !== 'e') {\r\n                    const r = result ? result[result.length - 1] : '';\r\n                    if (r && r !== ' ' && compressors.indexOf(r) < 0) {\r\n                        result += ' ';\r\n                    }\r\n                    result += 'E';\r\n                }\r\n                if (hasTabs) {\r\n                    text = text.replace(/\\t/g, '\\\\t');\r\n                }\r\n            }\r\n            result += text;\r\n            idx = closeIdx;\r\n            skipGaps();\r\n            continue;\r\n        }\r\n\r\n        if (options.compress && compressors.indexOf(s) >= 0) {\r\n            space = false;\r\n            skipGaps();\r\n        }\r\n\r\n        addSpace();\r\n        result += s;\r\n\r\n    } while (++idx < len);\r\n\r\n    return result;\r\n\r\n    function skipGaps() {\r\n        if (options.compress) {\r\n            while (idx < len - 1 && isGap(sql[idx + 1]) && idx++) ;\r\n        }\r\n    }\r\n\r\n    function addSpace() {\r\n        if (space) {\r\n            if (result.length) {\r\n                result += ' ';\r\n            }\r\n            space = false;\r\n        }\r\n    }\r\n\r\n    function throwError(code) {\r\n        const position = getIndexPos(sql, idx);\r\n        throw new SQLParsingError(code, position);\r\n    }\r\n}\r\n\r\n////////////////////////////////////\r\n// Identifies a gap / empty symbol.\r\nfunction isGap(s) {\r\n    return s === ' ' || s === '\\t' || s === '\\r' || s === '\\n';\r\n}\r\n\r\nmodule.exports = minify;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}