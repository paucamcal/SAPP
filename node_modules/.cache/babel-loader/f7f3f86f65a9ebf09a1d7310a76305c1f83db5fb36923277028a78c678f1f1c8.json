{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\n\nconst {\n  Events\n} = require('./events');\nconst {\n  assert\n} = require('./assert');\nconst {\n  resultQuery,\n  multiResultQuery,\n  streamQuery\n} = require('./special-query');\nconst {\n  ConnectionContext\n} = require('./context');\nconst {\n  DatabasePool\n} = require('./database-pool');\nconst {\n  queryResult\n} = require('./query-result');\nconst npm = {\n  utils: require('./utils'),\n  pubUtils: require('./utils/public'),\n  connect: require('./connect'),\n  query: require('./query'),\n  task: require('./task'),\n  text: require('./text')\n};\n\n/**\r\n * @class Database\r\n * @description\r\n *\r\n * Represents the database protocol, extensible via event {@link event:extend extend}.\r\n * This type is not available directly, it can only be created via the library's base call.\r\n *\r\n * **IMPORTANT:**\r\n *\r\n * For any given connection, you should only create a single {@link Database} object in a separate module,\r\n * to be shared in your application (see the code example below). If instead you keep creating the {@link Database}\r\n * object dynamically, your application will suffer from loss in performance, and will be getting a warning in a\r\n * development environment (when `NODE_ENV` = `development`):\r\n *\r\n * `WARNING: Creating a duplicate database object for the same connection.`\r\n *\r\n * If you ever see this warning, rectify your {@link Database} object initialization, so there is only one object\r\n * per connection details. See the example provided below.\r\n *\r\n * See also: property `noWarnings` in {@link module:pg-promise Initialization Options}.\r\n *\r\n * Note however, that in special cases you may need to re-create the database object, if its connection pool has been\r\n * shut-down externally. And in this case the library won't be showing any warning.\r\n *\r\n * @param {string|object} cn\r\n * Database connection details, which can be:\r\n *\r\n * - a configuration object\r\n * - a connection string\r\n *\r\n * For details see {@link https://github.com/vitaly-t/pg-promise/wiki/Connection-Syntax Connection Syntax}.\r\n *\r\n * The value can be accessed from the database object via property {@link Database.$cn $cn}.\r\n *\r\n * @param {*} [dc]\r\n * Database Context.\r\n *\r\n * Any object or value to be propagated through the protocol, to allow implementations and event handling\r\n * that depend on the database context.\r\n *\r\n * This is mainly to facilitate the use of multiple databases which may need separate protocol extensions,\r\n * or different implementations within a single task / transaction callback, depending on the database context.\r\n *\r\n * This parameter also adds uniqueness to the connection context that's used in combination with the connection\r\n * parameters, i.e. use of unique database context will prevent getting the warning about creating a duplicate\r\n * Database object.\r\n *\r\n * The value can be accessed from the database object via property {@link Database#$dc $dc}.\r\n *\r\n * @returns {Database}\r\n *\r\n * @see\r\n *\r\n * {@link Database#query query},\r\n * {@link Database#none none},\r\n * {@link Database#one one},\r\n * {@link Database#oneOrNone oneOrNone},\r\n * {@link Database#many many},\r\n * {@link Database#manyOrNone manyOrNone},\r\n * {@link Database#any any},\r\n * {@link Database#func func},\r\n * {@link Database#proc proc},\r\n * {@link Database#result result},\r\n * {@link Database#multiResult multiResult},\r\n * {@link Database#multi multi},\r\n * {@link Database#map map},\r\n * {@link Database#each each},\r\n * {@link Database#stream stream},\r\n * {@link Database#task task},\r\n * {@link Database#taskIf taskIf},\r\n * {@link Database#tx tx},\r\n * {@link Database#txIf txIf},\r\n * {@link Database#connect connect},\r\n * {@link Database#$config $config},\r\n * {@link Database#$cn $cn},\r\n * {@link Database#$dc $dc},\r\n * {@link Database#$pool $pool},\r\n * {@link event:extend extend}\r\n *\r\n * @example\r\n * // Proper way to initialize and share the Database object\r\n *\r\n * // Loading and initializing the library:\r\n * const pgp = require('pg-promise')({\r\n *     // Initialization Options\r\n * });\r\n *\r\n * // Preparing the connection details:\r\n * const cn = 'postgres://username:password@host:port/database';\r\n *\r\n * // Creating a new database instance from the connection details:\r\n * const db = pgp(cn);\r\n *\r\n * // Exporting the database object for shared use:\r\n * module.exports = db;\r\n */\nfunction Database(cn, dc, config) {\n  const dbThis = this,\n    $p = config.promise,\n    poolConnection = typeof cn === 'string' ? {\n      connectionString: cn\n    } : cn,\n    pool = new config.pgp.pg.Pool(poolConnection),\n    endMethod = pool.end;\n  let destroyed;\n  pool.end = cb => {\n    const res = endMethod.call(pool, cb);\n    dbThis.$destroy();\n    return res;\n  };\n  pool.on('error', onError);\n\n  /**\r\n   * @method Database#connect\r\n   *\r\n   * @description\r\n   * Acquires a new or existing connection, depending on the current state of the connection pool, and parameter `direct`.\r\n   *\r\n   * This method creates a shared connection for executing a chain of queries against it. The connection must be released\r\n   * in the end of the chain by calling `done()` on the connection object.\r\n   *\r\n   * Method `done` takes one optional parameter - boolean `kill` flag, to signal the connection pool that you want it to kill\r\n   * the physical connection. This flag is ignored for direct connections, as they always close when released.\r\n   *\r\n   * It should not be used just for chaining queries on the same connection, methods {@link Database#task task} and\r\n   * {@link Database#tx tx} (for transactions) are to be used for that. This method is primarily for special cases, like\r\n   * `LISTEN` notifications.\r\n   *\r\n   * **NOTE:** Even though this method exposes a {@link external:Client Client} object via property `client`,\r\n   * you cannot call `client.end()` directly, or it will print an error into the console:\r\n   * `Abnormal client.end() call, due to invalid code or failed server connection.`\r\n   * You should only call method `done()` to release the connection.\r\n   *\r\n   * @param {object} [options]\r\n   * Connection Options.\r\n   *\r\n   * @param {boolean} [options.direct=false]\r\n   * Creates a new connection directly, as a stand-alone {@link external:Client Client} object, bypassing the connection pool.\r\n   *\r\n   * By default, all connections are acquired from the connection pool. But if you set this option, the library will instead\r\n   * create a new {@link external:Client Client} object directly (separately from the pool), and then call its `connect` method.\r\n   *\r\n   * Note that specifically for direct connections, method `done` returns a {@link external:Promise Promise}, because those connections\r\n   * are closed physically, which may take time.\r\n   *\r\n   * **WARNING:**\r\n   *\r\n   * Do not use this option for regular query execution, because it exclusively occupies one physical channel, and it cannot scale.\r\n   * This option is only suitable for global connection usage, such as event listeners.\r\n   *\r\n   * @param {function} [options.onLost]\r\n   * Notification callback of the lost/broken connection, called with the following parameters:\r\n   *  - `err` - the original connectivity error\r\n   *  - `e` - error context object, which contains:\r\n   *    - `cn` - safe connection string/config (with the password hashed);\r\n   *    - `dc` - Database Context, as was used during {@link Database} construction;\r\n   *    - `start` - Date/Time (`Date` type) when the connection was established;\r\n   *    - `client` - {@link external:Client Client} object that has lost the connection.\r\n   *\r\n   * The notification is mostly valuable with `direct: true`, to be able to re-connect direct/permanent connections by calling\r\n   * method {@link Database#connect connect} again.\r\n   *\r\n   * You do not need to call `done` on lost connections, as it happens automatically. However, if you had event listeners\r\n   * set up on the connection's `client` object, you should remove them to avoid leaks:\r\n   *\r\n   * ```js\r\n   * function onLostConnection(err, e) {\r\n   *     e.client.removeListener('my-event', myHandler);\r\n   * }\r\n   * ```\r\n   *\r\n   * For a complete example see $[Robust Listeners].\r\n   *\r\n   * @returns {external:Promise}\r\n   * A promise object that represents the connection result:\r\n   *  - resolves with the complete {@link Database} protocol, extended with:\r\n   *    - property `client` of type {@link external:Client Client} that represents the open connection\r\n   *    - method `done` that must be called in the end, in order to release the connection (returns a {@link external:Promise Promise}\r\n   *      in case of direct connections)\r\n   *    - methods `batch`, `page` and `sequence`, same as inside a {@link Task}\r\n   *  - rejects with a connection-related error when it fails to connect.\r\n   *\r\n   * @see\r\n   * {@link Database#task Database.task},\r\n   * {@link Database#taskIf Database.taskIf},\r\n   * {@link Database#tx Database.tx},\r\n   * {@link Database#txIf Database.txIf}\r\n   *\r\n   * @example\r\n   *\r\n   * let sco; // shared connection object;\r\n   *\r\n   * db.connect()\r\n   *     .then(obj => {\r\n   *         // obj.client = new connected Client object;\r\n   *\r\n   *         sco = obj; // save the connection object;\r\n   *\r\n   *         // execute all the queries you need:\r\n   *         return sco.any('SELECT * FROM Users');\r\n   *     })\r\n   *     .then(data => {\r\n   *         // success\r\n   *     })\r\n   *     .catch(error => {\r\n   *         // error\r\n   *     })\r\n   *     .finally(() => {\r\n   *         // release the connection, if it was successful:\r\n   *         if (sco) {\r\n   *             // if you pass `true` into method done, i.e. done(true),\r\n   *             // it will make the pool kill the physical connection.\r\n   *             sco.done();\r\n   *         }\r\n   *     });\r\n   *\r\n   */\n  this.connect = function (options) {\n    options = options || {};\n    const ctx = createContext();\n    ctx.cnOptions = options;\n    const self = {\n      query(query, values, qrm) {\n        if (!ctx.db) {\n          return $p.reject(new Error(npm.text.queryDisconnected));\n        }\n        return config.$npm.query.call(this, ctx, query, values, qrm);\n      },\n      done(kill) {\n        if (!ctx.db) {\n          throw new Error(npm.text.looseQuery);\n        }\n        return ctx.disconnect(kill);\n      },\n      batch(values, opt) {\n        return config.$npm.spex.batch.call(this, values, opt);\n      },\n      page(source, opt) {\n        return config.$npm.spex.page.call(this, source, opt);\n      },\n      sequence(source, opt) {\n        return config.$npm.spex.sequence.call(this, source, opt);\n      }\n    };\n    const connection = options.direct ? config.$npm.connect.direct(ctx) : config.$npm.connect.pool(ctx, dbThis);\n    return connection.then(db => {\n      ctx.connect(db);\n      self.client = db.client;\n      extend(ctx, self);\n      return self;\n    });\n  };\n\n  /**\r\n   * @method Database#query\r\n   *\r\n   * @description\r\n   * Base query method that executes a generic query, expecting the return data according to parameter `qrm`.\r\n   *\r\n   * It performs the following steps:\r\n   *\r\n   *  1. Validates and formats the query via {@link formatting.format as.format}, according to the `query` and `values` passed in;\r\n   *  2. For a root-level query (against the {@link Database} object), it requests a new connection from the pool;\r\n   *  3. Executes the query;\r\n   *  4. For a root-level query (against the {@link Database} object), it releases the connection back to the pool;\r\n   *  5. Resolves/rejects, according to the data returned from the query and the value of `qrm`.\r\n   *\r\n   * Direct use of this method is not suitable for chaining queries, for performance reasons. It should be done\r\n   * through either task or transaction context, see $[Chaining Queries].\r\n   *\r\n   * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n   *\r\n   * @param {string|function|object} query\r\n   * Query to be executed, which can be any of the following types:\r\n   * - A non-empty query string\r\n   * - A function that returns a query string or another function, i.e. recursive resolution\r\n   *   is supported, passing in `values` as `this`, and as the first parameter.\r\n   * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n   * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n   * - {@link QueryFile} object\r\n   *\r\n   * @param {array|value|function} [values]\r\n   * Query formatting parameter(s), or a function that returns it.\r\n   *\r\n   * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n   * - a single value - to replace all `$1` occurrences\r\n   * - an array of values - to replace all `$1`, `$2`, ... variables\r\n   * - an object - to apply $[Named Parameters] formatting\r\n   *\r\n   * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n   * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n   * as an override for its internal `values`.\r\n   *\r\n   * @param {queryResult} [qrm=queryResult.any]\r\n   * {@link queryResult Query Result Mask}\r\n   *\r\n   * @returns {external:Promise}\r\n   * A promise object that represents the query result according to `qrm`.\r\n   */\n  this.query = function (query, values, qrm) {\n    const self = this,\n      ctx = createContext();\n    return config.$npm.connect.pool(ctx, dbThis).then(db => {\n      ctx.connect(db);\n      return config.$npm.query.call(self, ctx, query, values, qrm);\n    }).then(data => {\n      ctx.disconnect();\n      return data;\n    }).catch(error => {\n      ctx.disconnect();\n      return $p.reject(error);\n    });\n  };\n\n  /**\r\n   * @member {object} Database#$config\r\n   * @readonly\r\n   * @description\r\n   * This is a hidden property, to help integrating type {@link Database} directly with third-party libraries.\r\n   *\r\n   * Properties available in the object:\r\n   * - `pgp` - instance of the entire library after initialization\r\n   * - `options` - the library's {@link module:pg-promise Initialization Options} object\r\n   * - `promiseLib` - instance of the promise library that's used\r\n   * - `promise` - generic promise interface that uses `promiseLib` via 4 basic methods:\r\n   *   - `promise((resolve, reject) => {})` - to create a new promise\r\n   *   - `promise.resolve(value)` - to resolve with a value\r\n   *   - `promise.reject(reason)` - to reject with a reason\r\n   *   - `promise.all(iterable)` - to resolve an iterable list of promises\r\n   * - `version` - this library's version\r\n   * - `$npm` _(hidden property)_ - internal module cache\r\n   *\r\n   * @example\r\n   *\r\n   * // Using the promise protocol as configured by pg-promise:\r\n   *\r\n   * const $p = db.$config.promise;\r\n   *\r\n   * const resolvedPromise = $p.resolve('some data');\r\n   * const rejectedPromise = $p.reject('some reason');\r\n   *\r\n   * const newPromise = $p((resolve, reject) => {\r\n   *     // call either resolve(data) or reject(reason) here\r\n   * });\r\n   */\n  npm.utils.addReadProp(this, '$config', config, true);\n\n  /**\r\n   * @member {string|object} Database#$cn\r\n   * @readonly\r\n   * @description\r\n   * Database connection, as was passed in during the object's construction.\r\n   *\r\n   * This is a hidden property, to help integrating type {@link Database} directly with third-party libraries.\r\n   *\r\n   * @see Database\r\n   */\n  npm.utils.addReadProp(this, '$cn', cn, true);\n\n  /**\r\n   * @member {*} Database#$dc\r\n   * @readonly\r\n   * @description\r\n   * Database Context, as was passed in during the object's construction.\r\n   *\r\n   * This is a hidden property, to help integrating type {@link Database} directly with third-party libraries.\r\n   *\r\n   * @see Database\r\n   */\n  npm.utils.addReadProp(this, '$dc', dc, true);\n\n  /**\r\n   * @member {external:pg-pool} Database#$pool\r\n   * @readonly\r\n   * @description\r\n   * A $[pg-pool] object associated with the database object, as each {@link Database} creates its own $[pg-pool] instance.\r\n   *\r\n   * This is a hidden property, primarily for integrating type {@link Database} with third-party libraries that support\r\n   * $[pg-pool] directly. Note however, that if you pass the pool object into a library that calls `pool.end()`, you will no longer be able\r\n   * to use this {@link Database} object, and each query method will be rejecting with {@link external:Error Error} =\r\n   * `Connection pool of the database object has been destroyed.`\r\n   *\r\n   * You can also use this object to shut down the pool, by calling `$pool.end()`.\r\n   *\r\n   * For more details see $[Library de-initialization].\r\n   *\r\n   * @see\r\n   * {@link Database}\r\n   * {@link module:pg-promise~end pgp.end}\r\n   *\r\n   * @example\r\n   *\r\n   * // Shutting down the connection pool of this database object,\r\n   * // after all queries have finished in a run-though process:\r\n   *\r\n   * .then(() => {}) // processing the data\r\n   * .catch() => {}) // handling the error\r\n   * .finally(db.$pool.end); // shutting down the pool\r\n   *\r\n   */\n  npm.utils.addReadProp(this, '$pool', pool, true);\n\n  /**\r\n   * @member {function} Database.$destroy\r\n   * @readonly\r\n   * @private\r\n   * @description\r\n   * Permanently shuts down the database object.\r\n   */\n  npm.utils.addReadProp(this, '$destroy', () => {\n    if (!destroyed) {\n      if (!pool.ending) {\n        endMethod.call(pool);\n      }\n      DatabasePool.unregister(dbThis);\n      pool.removeListener('error', onError);\n      destroyed = true;\n    }\n  }, true);\n  DatabasePool.register(this);\n  extend(createContext(), this); // extending root protocol;\n\n  function createContext() {\n    return new ConnectionContext({\n      cn,\n      dc,\n      options: config.options\n    });\n  }\n\n  // Optional value-transformation helper:\n  function transform(value, cb, thisArg) {\n    return typeof cb === 'function' ? value.then(data => cb.call(thisArg, data)) : value;\n  }\n\n  ////////////////////////////////////////////////////\n  // Injects additional methods into an access object,\n  // extending the protocol's base method 'query'.\n  function extend(ctx, obj) {\n    /**\r\n     * @method Database#none\r\n     * @description\r\n     * Executes a query that expects no data to be returned. If the query returns any data,\r\n     * the method rejects.\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Query formatting parameter(s), or a function that returns it.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @returns {external:Promise<null>}\r\n     * A promise object that represents the query result:\r\n     * - When no records are returned, it resolves with `null`.\r\n     * - When any data is returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n     *   - `.message` = `No return data was expected.`\r\n     *   - `.code` = {@link errors.queryResultErrorCode.notEmpty queryResultErrorCode.notEmpty}\r\n     */\n    obj.none = function (query, values) {\n      return obj.query.call(this, query, values, queryResult.none);\n    };\n\n    /**\r\n     * @method Database#one\r\n     * @description\r\n     * Executes a query that expects exactly 1 row to be returned. When 0 or more than 1 rows are returned,\r\n     * the method rejects.\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Query formatting parameter(s), or a function that returns it.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @param {function} [cb]\r\n     * Value-transformation callback, to allow in-line value change.\r\n     * When specified, the returned value replaces the original one.\r\n     *\r\n     * The function takes only one parameter - value resolved from the query.\r\n     *\r\n     * @param {*} [thisArg]\r\n     * Value to use as `this` when executing the transformation callback.\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object that represents the query result:\r\n     * - When 1 row is returned, it resolves with that row as a single object.\r\n     * - When no rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n     *   - `.message` = `No data returned from the query.`\r\n     *   - `.code` = {@link errors.queryResultErrorCode.noData queryResultErrorCode.noData}\r\n     * - When multiple rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n     *   - `.message` = `Multiple rows were not expected.`\r\n     *   - `.code` = {@link errors.queryResultErrorCode.multiple queryResultErrorCode.multiple}\r\n     * - Resolves with the new value, if transformation callback `cb` was specified.\r\n     *\r\n     * @see\r\n     * {@link Database#oneOrNone oneOrNone}\r\n     *\r\n     * @example\r\n     *\r\n     * // a query with in-line value transformation:\r\n     * db.one('INSERT INTO Events VALUES($1) RETURNING id', [123], event => event.id)\r\n     *     .then(data => {\r\n     *         // data = a new event id, rather than an object with it\r\n     *     });\r\n     *\r\n     * @example\r\n     *\r\n     * // a query with in-line value transformation + conversion:\r\n     * db.one('SELECT count(*) FROM Users', [], c => +c.count)\r\n     *     .then(count => {\r\n     *         // count = a proper integer value, rather than an object with a string\r\n     *     });\r\n     *\r\n     */\n    obj.one = function (query, values, cb, thisArg) {\n      const v = obj.query.call(this, query, values, queryResult.one);\n      return transform(v, cb, thisArg);\n    };\n\n    /**\r\n     * @method Database#many\r\n     * @description\r\n     * Executes a query that expects one or more rows to be returned. When the query returns no rows, the method rejects.\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Query formatting parameter(s), or a function that returns it.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object that represents the query result:\r\n     * - When 1 or more rows are returned, it resolves with the array of rows.\r\n     * - When no rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n     *   - `.message` = `No data returned from the query.`\r\n     *   - `.code` = {@link errors.queryResultErrorCode.noData queryResultErrorCode.noData}\r\n     */\n    obj.many = function (query, values) {\n      return obj.query.call(this, query, values, queryResult.many);\n    };\n\n    /**\r\n     * @method Database#oneOrNone\r\n     * @description\r\n     * Executes a query that expects 0 or 1 rows to be returned. It resolves with the row-object when 1 row is returned,\r\n     * or with `null` when nothing is returned. When the query returns more than 1 row, the method rejects.\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Query formatting parameter(s), or a function that returns it.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @param {function} [cb]\r\n     * Value-transformation callback, to allow in-line value change.\r\n     * When specified, the returned value replaces the original one.\r\n     *\r\n     * The function takes only one parameter - value resolved from the query.\r\n     *\r\n     * @param {*} [thisArg]\r\n     * Value to use as `this` when executing the transformation callback.\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object that represents the query result:\r\n     * - When no rows are returned, it resolves with `null`.\r\n     * - When 1 row is returned, it resolves with that row as a single object.\r\n     * - When multiple rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n     *   - `.message` = `Multiple rows were not expected.`\r\n     *   - `.code` = {@link errors.queryResultErrorCode.multiple queryResultErrorCode.multiple}\r\n     * - Resolves with the new value, if transformation callback `cb` was specified.\r\n     *\r\n     * @see\r\n     * {@link Database#one one},\r\n     * {@link Database#none none},\r\n     * {@link Database#manyOrNone manyOrNone}\r\n     *\r\n     * @example\r\n     *\r\n     * // a query with in-line value transformation:\r\n     * db.oneOrNone('SELECT id FROM Events WHERE type = $1', ['entry'], e => e && e.id)\r\n     *     .then(data => {\r\n     *         // data = the event id or null (rather than object or null)\r\n     *     });\r\n     *\r\n     */\n    obj.oneOrNone = function (query, values, cb, thisArg) {\n      const v = obj.query.call(this, query, values, queryResult.one | queryResult.none);\n      return transform(v, cb, thisArg);\n    };\n\n    /**\r\n     * @method Database#manyOrNone\r\n     * @description\r\n     * Executes a query that can return any number of rows.\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Query formatting parameter(s), or a function that returns it.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @returns {external:Promise<Array>}\r\n     * A promise object that represents the query result:\r\n     * - When no rows are returned, it resolves with an empty array.\r\n     * - When 1 or more rows are returned, it resolves with the array of rows.\r\n     *\r\n     * @see\r\n     * {@link Database#any any},\r\n     * {@link Database#many many},\r\n     * {@link Database#none none}\r\n     *\r\n     */\n    obj.manyOrNone = function (query, values) {\n      return obj.query.call(this, query, values, queryResult.many | queryResult.none);\n    };\n\n    /**\r\n     * @method Database#any\r\n     * @description\r\n     * Executes a query that can return any number of rows.\r\n     * This is simply a shorter alias for method {@link Database#manyOrNone manyOrNone}.\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Query formatting parameter(s), or a function that returns it.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @returns {external:Promise<Array>}\r\n     * A promise object that represents the query result:\r\n     * - When no rows are returned, it resolves with an empty array.\r\n     * - When 1 or more rows are returned, it resolves with the array of rows.\r\n     *\r\n     * @see\r\n     * {@link Database#manyOrNone manyOrNone},\r\n     * {@link Database#map map},\r\n     * {@link Database#each each}\r\n     *\r\n     */\n    obj.any = function (query, values) {\n      return obj.query.call(this, query, values, queryResult.any);\n    };\n\n    /**\r\n     * @method Database#result\r\n     * @description\r\n     * Executes a query without any expectation for the return data, and resolves with the\r\n     * original $[Result] object when successful.\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Query formatting parameter(s), or a function that returns it.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @param {function} [cb]\r\n     * Value-transformation callback, to allow in-line value change.\r\n     * When specified, the returned value replaces the original one.\r\n     *\r\n     * The function takes only one parameter - value resolved from the query.\r\n     *\r\n     * @param {*} [thisArg]\r\n     * Value to use as `this` when executing the transformation callback.\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object that represents the query result:\r\n     * - resolves with the original $[Result] object (by default);\r\n     * - resolves with the new value, if transformation callback `cb` was specified.\r\n     *\r\n     * @example\r\n     *\r\n     * // use of value transformation:\r\n     * // deleting rows and returning the number of rows deleted\r\n     * db.result('DELETE FROM Events WHERE id = $1', [123], r => r.rowCount)\r\n     *     .then(data => {\r\n     *         // data = number of rows that were deleted\r\n     *     });\r\n     *\r\n     * @example\r\n     *\r\n     * // use of value transformation:\r\n     * // getting only column details from a table\r\n     * db.result('SELECT * FROM Users LIMIT 0', null, r => r.fields)\r\n     *     .then(data => {\r\n     *         // data = array of column descriptors\r\n     *     });\r\n     *\r\n     */\n    obj.result = function (query, values, cb, thisArg) {\n      const v = obj.query.call(this, query, values, resultQuery);\n      return transform(v, cb, thisArg);\n    };\n\n    /**\r\n     * @method Database#multiResult\r\n     * @description\r\n     * Executes a multi-query string, without any expectation for the return data, and resolves with an array\r\n     * of the original $[Result] objects when successful.\r\n     *\r\n     * The operation is atomic, i.e. all queries are executed in a single transaction, unless there are explicit\r\n     * `BEGIN/COMMIT` commands included in the query string to divide it into multiple transactions.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Multi-query string to be executed, which can be any of the following types:\r\n     * - A non-empty string that can contain any number of queries\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Query formatting parameter(s), or a function that returns it.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @returns {external:Promise<external:Result[]>}\r\n     *\r\n     * @see {@link Database#multi multi}\r\n     *\r\n     */\n    obj.multiResult = function (query, values) {\n      return obj.query.call(this, query, values, multiResultQuery);\n    };\n\n    /**\r\n     * @method Database#multi\r\n     * @description\r\n     * Executes a multi-query string, without any expectation for the return data, and resolves with an array\r\n     * of arrays of rows when successful.\r\n     *\r\n     * The operation is atomic, i.e. all queries are executed in a single transaction, unless there are explicit\r\n     * `BEGIN/COMMIT` commands included in the query string to divide it into multiple transactions.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Multi-query string to be executed, which can be any of the following types:\r\n     * - A non-empty string that can contain any number of queries\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Query formatting parameter(s), or a function that returns it.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @returns {external:Promise<Array<Array>>}\r\n     *\r\n     * @see {@link Database#multiResult multiResult}\r\n     *\r\n     * @example\r\n     *\r\n     * // Get data from 2 tables in a single request:\r\n     * const [users, products] = await db.multi('SELECT * FROM users;SELECT * FROM products');\r\n     *\r\n     */\n    obj.multi = function (query, values) {\n      return obj.query.call(this, query, values, multiResultQuery).then(data => data.map(a => a.rows));\n    };\n\n    /**\r\n     * @method Database#stream\r\n     * @description\r\n     * Custom data streaming, with the help of $[pg-query-stream].\r\n     *\r\n     * This method doesn't work with the $[Native Bindings], and if option `pgNative`\r\n     * is set, it will reject with `Streaming doesn't work with Native Bindings.`\r\n     *\r\n     * @param {QueryStream} qs\r\n     * Stream object of type $[QueryStream].\r\n     *\r\n     * @param {Database.streamInitCB} initCB\r\n     * Stream initialization callback.\r\n     *\r\n     * It is invoked with the same `this` context as the calling method.\r\n     *\r\n     * @returns {external:Promise}\r\n     * Result of the streaming operation.\r\n     *\r\n     * Once the streaming has finished successfully, the method resolves with\r\n     * `{processed, duration}`:\r\n     * - `processed` - total number of rows processed;\r\n     * - `duration` - streaming duration, in milliseconds.\r\n     *\r\n     * Possible rejections messages:\r\n     * - `Invalid or missing stream object.`\r\n     * - `Invalid stream state.`\r\n     * - `Invalid or missing stream initialization callback.`\r\n     */\n    obj.stream = function (qs, init) {\n      return obj.query.call(this, qs, init, streamQuery);\n    };\n\n    /**\r\n     * @method Database#func\r\n     * @description\r\n     * Executes a database function that returns a table, abbreviating the full syntax\r\n     * of `query('SELECT * FROM $1:alias($2:csv)', [funcName, values], qrm)`.\r\n     *\r\n     * @param {string} funcName\r\n     * Name of the function to be executed.\r\n     * When it is not same-case, or contains extended symbols, it is double-quoted, as per the `:alias` filter,\r\n     * which also supports `.`, to auto-split into a composite name.\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Parameters for the function - one value | array of values | function returning value(s).\r\n     *\r\n     * @param {queryResult} [qrm=queryResult.any] - {@link queryResult Query Result Mask}.\r\n     *\r\n     * @returns {external:Promise}\r\n     *\r\n     * A promise object as returned from method {@link Database#query query}, according to parameter `qrm`.\r\n     *\r\n     * @see\r\n     * {@link Database#query query},\r\n     * {@link Database#proc proc}\r\n     */\n    obj.func = function (funcName, values, qrm) {\n      return obj.query.call(this, {\n        entity: funcName,\n        type: 'func'\n      }, values, qrm);\n    };\n\n    /**\r\n     * @method Database#proc\r\n     * @description\r\n     * Executes a stored procedure by name, abbreviating the full syntax of\r\n     * `oneOrNone('CALL $1:alias($2:csv)', [procName, values], cb, thisArg)`.\r\n     *\r\n     * **NOTE:** This method uses the new `CALL` syntax that requires PostgreSQL v11 or later.\r\n     *\r\n     * @param {string} procName\r\n     * Name of the stored procedure to be executed.\r\n     * When it is not same-case, or contains extended symbols, it is double-quoted, as per the `:alias` filter,\r\n     * which also supports `.`, to auto-split into a composite SQL name.\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Parameters for the procedure - one value | array of values | function returning value(s).\r\n     *\r\n     * @param {function} [cb]\r\n     * Value-transformation callback, to allow in-line value change.\r\n     * When specified, the returned value replaces the original one.\r\n     *\r\n     * The function takes only one parameter - value resolved from the query.\r\n     *\r\n     * @param {*} [thisArg]\r\n     * Value to use as `this` when executing the transformation callback.\r\n     *\r\n     * @returns {external:Promise}\r\n     * When the procedure takes output parameters, a single object is returned, with\r\n     * properties for the output values. Otherwise, the method resolves with `null`.\r\n     * And if the value-transformation callback is provided, it overrides the result.\r\n     *\r\n     * @see\r\n     * {@link Database#func func}\r\n     */\n    obj.proc = function (procName, values, cb, thisArg) {\n      const v = obj.query.call(this, {\n        entity: procName,\n        type: 'proc'\n      }, values, queryResult.one | queryResult.none);\n      return transform(v, cb, thisArg);\n    };\n\n    /**\r\n     * @method Database#map\r\n     * @description\r\n     * Creates a new array with the results of calling a provided function on every element in the array of rows\r\n     * resolved by method {@link Database#any any}.\r\n     *\r\n     * It is a convenience method, to reduce the following code:\r\n     *\r\n     * ```js\r\n     * db.any(query, values)\r\n     *     .then(data => {\r\n     *         return data.map((row, index, data) => {\r\n     *              // return a new element\r\n     *         });\r\n     *     });\r\n     * ```\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value|function} values\r\n     * Query formatting parameter(s), or a function that returns it.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @param {function} cb\r\n     * Function that produces an element of the new array, taking three arguments:\r\n     * - `row` - the current row object being processed in the array\r\n     * - `index` - the index of the current row being processed in the array\r\n     * - `data` - the original array of rows resolved by method {@link Database#any any}\r\n     *\r\n     * @param {*} [thisArg]\r\n     * Value to use as `this` when executing the callback.\r\n     *\r\n     * @returns {external:Promise<Array>}\r\n     * Resolves with the new array of values returned from the callback.\r\n     *\r\n     * @see\r\n     * {@link Database#any any},\r\n     * {@link Database#each each},\r\n     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map Array.map}\r\n     *\r\n     * @example\r\n     *\r\n     * db.map('SELECT id FROM Users WHERE status = $1', ['active'], row => row.id)\r\n     *     .then(data => {\r\n     *         // data = array of active user id-s\r\n     *     })\r\n     *     .catch(error => {\r\n     *        // error\r\n     *     });\r\n     *\r\n     * @example\r\n     *\r\n     * db.tx(t => {\r\n     *     return t.map('SELECT id FROM Users WHERE status = $1', ['active'], row => {\r\n     *        return t.none('UPDATE Events SET checked = $1 WHERE userId = $2', [true, row.id]);\r\n     *     }).then(t.batch);\r\n     * })\r\n     *     .then(data => {\r\n     *         // success\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // error\r\n     *     });\r\n     *\r\n     * @example\r\n     *\r\n     * // Build a list of active users, each with the list of user events:\r\n     * db.task(t => {\r\n     *     return t.map('SELECT id FROM Users WHERE status = $1', ['active'], user => {\r\n     *         return t.any('SELECT * FROM Events WHERE userId = $1', user.id)\r\n     *             .then(events=> {\r\n     *                 user.events = events;\r\n     *                 return user;\r\n     *             });\r\n     *     }).then(t.batch);\r\n     * })\r\n     *     .then(data => {\r\n     *         // success\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // error\r\n     *     });\r\n     *\r\n     */\n    obj.map = function (query, values, cb, thisArg) {\n      return obj.any.call(this, query, values).then(data => data.map(cb, thisArg));\n    };\n\n    /**\r\n     * @method Database#each\r\n     * @description\r\n     * Executes a provided function once per array element, for an array of rows resolved by method {@link Database#any any}.\r\n     *\r\n     * It is a convenience method to reduce the following code:\r\n     *\r\n     * ```js\r\n     * db.any(query, values)\r\n     *     .then(data => {\r\n     *         data.forEach((row, index, data) => {\r\n     *              // process the row\r\n     *         });\r\n     *         return data;\r\n     *     });\r\n     * ```\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Query formatting parameter(s), or a function that returns it.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @param {function} cb\r\n     * Function to execute for each row, taking three arguments:\r\n     * - `row` - the current row object being processed in the array\r\n     * - `index` - the index of the current row being processed in the array\r\n     * - `data` - the array of rows resolved by method {@link Database#any any}\r\n     *\r\n     * @param {*} [thisArg]\r\n     * Value to use as `this` when executing the callback.\r\n     *\r\n     * @returns {external:Promise<Array<Object>>}\r\n     * Resolves with the original array of rows.\r\n     *\r\n     * @see\r\n     * {@link Database#any any},\r\n     * {@link Database#map map},\r\n     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach Array.forEach}\r\n     *\r\n     * @example\r\n     *\r\n     * db.each('SELECT id, code, name FROM Events', [], row => {\r\n     *     row.code = parseInt(row.code);\r\n     * })\r\n     *     .then(data => {\r\n     *         // data = array of events, with 'code' converted into integer\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // error\r\n     *     });\r\n     *\r\n     */\n    obj.each = function (query, values, cb, thisArg) {\n      return obj.any.call(this, query, values).then(data => {\n        data.forEach(cb, thisArg);\n        return data;\n      });\n    };\n\n    /**\r\n     * @method Database#task\r\n     * @description\r\n     * Executes a callback function with automatically managed connection.\r\n     *\r\n     * When invoked on the root {@link Database} object, the method allocates the connection from the pool,\r\n     * executes the callback, and once finished - releases the connection back to the pool.\r\n     * However, when invoked inside another task or transaction, the method reuses the parent connection.\r\n     *\r\n     * This method should be used whenever executing more than one query at once, so the allocated connection\r\n     * is reused between all queries, and released only after the task has finished (see $[Chaining Queries]).\r\n     *\r\n     * The callback function is called with one parameter - database protocol (same as `this`), extended with methods\r\n     * {@link Task#batch batch}, {@link Task#page page}, {@link Task#sequence sequence}, plus property {@link Task#ctx ctx} -\r\n     * the task context object. See class {@link Task} for more details.\r\n     *\r\n     * @param {string|number|Object} [options]\r\n     * This parameter is optional, and presumed skipped when the first parameter is a function (`cb` parameter).\r\n     *\r\n     * When it is of type `string` or `number`, it is assumed to be option `tag` passed in directly. Otherwise,\r\n     * it is expected to be an object with options as listed below.\r\n     *\r\n     * @param {} [options.tag]\r\n     * Traceable context for the task (see $[tags]).\r\n     *\r\n     * @param {function} cb\r\n     * Task callback function, to return the result that will determine either success or failure for the operation.\r\n     *\r\n     * The function can be either the first of the second parameter passed into the method.\r\n     *\r\n     * It also can be an ES7 `async` function.\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object with the result from the callback function.\r\n     *\r\n     * @see\r\n     * {@link Task},\r\n     * {@link Database#taskIf taskIf},\r\n     * {@link Database#tx tx},\r\n     * $[tags],\r\n     * $[Chaining Queries]\r\n     *\r\n     * @example\r\n     *\r\n     * db.task('my-task', t => {\r\n     *         // t.ctx = task context object\r\n     *\r\n     *         return t.one('SELECT id FROM Users WHERE name = $1', 'John')\r\n     *             .then(user => {\r\n     *                 return t.any('SELECT * FROM Events WHERE userId = $1', user.id);\r\n     *             });\r\n     *     })\r\n     *     .then(data => {\r\n     *         // success\r\n     *         // data = as returned from the task's callback\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // error\r\n     *     });\r\n     *\r\n     * @example\r\n     *\r\n     * // using an ES7 syntax for the callback:\r\n     * db.task('my-task', async t {\r\n     *         // t.ctx = task context object\r\n     *\r\n     *         const user = await t.one('SELECT id FROM Users WHERE name = $1', 'John');\r\n     *         return t.any('SELECT * FROM Events WHERE userId = $1', user.id);\r\n     *     })\r\n     *     .then(data => {\r\n     *         // success\r\n     *         // data = as returned from the task's callback\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // error\r\n     *     });\r\n     *\r\n     */\n    obj.task = function () {\n      const args = npm.pubUtils.taskArgs(arguments);\n      assert(args.options, ['tag']);\n      return taskProcessor.call(this, args, false);\n    };\n\n    /**\r\n     * @method Database#taskIf\r\n     * @description\r\n     * Executes a conditional task that results in an actual new {@link Database#task task}, if either condition is met or\r\n     * when it is necessary (on the top level), or else it reuses the current connection context.\r\n     *\r\n     * The default condition is `not in task or transaction`, to start a task only if currently not inside another task or transaction,\r\n     * which is the same as calling the following:\r\n     *\r\n     * ```js\r\n     * db.taskIf({cnd: t => !t.ctx}, cb => {})\r\n     * ```\r\n     *\r\n     * It can be useful, if you want to simplify/reduce the task + log events footprint, by creating new tasks only when necessary.\r\n     *\r\n     * @param {string|number|Object} [options]\r\n     * This parameter is optional, and presumed skipped when the first parameter is a function (`cb` parameter).\r\n     *\r\n     * When it is of type `string` or `number`, it is assumed to be option `tag` passed in directly. Otherwise,\r\n     * it is expected to be an object with options as listed below.\r\n     *\r\n     * @param {} [options.tag]\r\n     * Traceable context for the task/transaction (see $[tags]).\r\n     *\r\n     * @param {boolean|function} [options.cnd]\r\n     * Condition for creating a ({@link Database#task task}), if it is met.\r\n     * It can be either a simple boolean, or a callback function that takes the task context as `this` and as the first parameter.\r\n     *\r\n     * Default condition (when it is not specified):\r\n     *\r\n     * ```js\r\n     * {cnd: t => !t.ctx}\r\n     * ```\r\n     *\r\n     * @param {function} cb\r\n     * Task callback function, to return the result that will determine either success or failure for the operation.\r\n     *\r\n     * The function can be either the first or the second parameter passed into the method.\r\n     *\r\n     * It also can be an ES7 `async` function.\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object with the result from the callback function.\r\n     *\r\n     * @see\r\n     * {@link Task},\r\n     * {@link Database#task Database.task},\r\n     * {@link Database#tx Database.tx},\r\n     * {@link Database#txIf Database.txIf},\r\n     * {@link TaskContext}\r\n     *\r\n     */\n    obj.taskIf = function () {\n      const args = npm.pubUtils.taskArgs(arguments);\n      assert(args.options, ['tag', 'cnd']);\n      try {\n        let cnd = args.options.cnd;\n        if ('cnd' in args.options) {\n          cnd = typeof cnd === 'function' ? cnd.call(obj, obj) : !!cnd;\n        } else {\n          cnd = !obj.ctx; // create task, if it is the top level\n        }\n        // reusable only if condition fails, and not top-level:\n        args.options.reusable = !cnd && !!obj.ctx;\n      } catch (e) {\n        return $p.reject(e);\n      }\n      return taskProcessor.call(this, args, false);\n    };\n\n    /**\r\n     * @method Database#tx\r\n     * @description\r\n     * Executes a callback function as a transaction, with automatically managed connection.\r\n     *\r\n     * When invoked on the root {@link Database} object, the method allocates the connection from the pool,\r\n     * executes the callback, and once finished - releases the connection back to the pool.\r\n     * However, when invoked inside another task or transaction, the method reuses the parent connection.\r\n     *\r\n     * A transaction wraps a regular {@link Database#task task} into additional queries:\r\n     * - it executes `BEGIN` just before invoking the callback function\r\n     * - it executes `COMMIT`, if the callback didn't throw any error or return a rejected promise\r\n     * - it executes `ROLLBACK`, if the callback did throw an error or return a rejected promise\r\n     * - it executes corresponding `SAVEPOINT` commands when the method is called recursively.\r\n     *\r\n     * The callback function is called with one parameter - database protocol (same as `this`), extended with methods\r\n     * {@link Task#batch batch}, {@link Task#page page}, {@link Task#sequence sequence}, plus property {@link Task#ctx ctx} -\r\n     * the transaction context object. See class {@link Task} for more details.\r\n     *\r\n     * Note that transactions should be chosen over tasks only where necessary, because unlike regular tasks,\r\n     * transactions are blocking operations.\r\n     *\r\n     * @param {string|number|Object} [options]\r\n     * This parameter is optional, and presumed skipped when the first parameter is a function (`cb` parameter).\r\n     *\r\n     * When it is of type `string` or `number`, it is assumed to be option `tag` passed in directly. Otherwise,\r\n     * it is expected to be an object with options as listed below.\r\n     *\r\n     * @param {} [options.tag]\r\n     * Traceable context for the transaction (see $[tags]).\r\n     *\r\n     * @param {txMode.TransactionMode} [options.mode]\r\n     * Transaction Configuration Mode - extends the transaction-opening command with additional configuration.\r\n     *\r\n     * @param {function} cb\r\n     * Transaction callback function, to return the result that will determine either success or failure for the operation.\r\n     *\r\n     * The function can be either the first of the second parameter passed into the method.\r\n     *\r\n     * It also can be an ES7 `async` function.\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object with the result from the callback function.\r\n     *\r\n     * @see\r\n     * {@link Task},\r\n     * {@link Database#task Database.task},\r\n     * {@link Database#taskIf Database.taskIf},\r\n     * {@link TaskContext},\r\n     * $[tags],\r\n     * $[Chaining Queries]\r\n     *\r\n     * @example\r\n     *\r\n     * db.tx('my-transaction', t => {\r\n     *         // t.ctx = transaction context object\r\n     *\r\n     *         return t.one('INSERT INTO Users(name, age) VALUES($1, $2) RETURNING id', ['Mike', 25])\r\n     *             .then(user => {\r\n     *                 return t.batch([\r\n     *                     t.none('INSERT INTO Events(userId, name) VALUES($1, $2)', [user.id, 'created']),\r\n     *                     t.none('INSERT INTO Events(userId, name) VALUES($1, $2)', [user.id, 'login'])\r\n     *                 ]);\r\n     *             });\r\n     *     })\r\n     *     .then(data => {\r\n     *         // success\r\n     *         // data = as returned from the transaction's callback\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // error\r\n     *     });\r\n     *\r\n     * @example\r\n     *\r\n     * // using an ES7 syntax for the callback:\r\n     * db.tx('my-transaction', async t {\r\n     *         // t.ctx = transaction context object\r\n     *\r\n     *         const user = await t.one('INSERT INTO Users(name, age) VALUES($1, $2) RETURNING id', ['Mike', 25]);\r\n     *         return t.none('INSERT INTO Events(userId, name) VALUES($1, $2)', [user.id, 'created']);\r\n     *     })\r\n     *     .then(data => {\r\n     *         // success\r\n     *         // data = as returned from the transaction's callback\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // error\r\n     *     });\r\n     *\r\n     */\n    obj.tx = function () {\n      const args = npm.pubUtils.taskArgs(arguments);\n      assert(args.options, ['tag', 'mode']);\n      return taskProcessor.call(this, args, true);\n    };\n\n    /**\r\n     * @method Database#txIf\r\n     * @description\r\n     * Executes a conditional transaction that results in an actual transaction ({@link Database#tx tx}), if the condition is met,\r\n     * or else it executes a regular {@link Database#task task}.\r\n     *\r\n     * The default condition is `not in transaction`, to start a transaction only if currently not in transaction,\r\n     * or else start a task, which is the same as calling the following:\r\n     *\r\n     * ```js\r\n     * db.txIf({cnd: t => !t.ctx || !t.ctx.inTransaction}, cb => {})\r\n     * ```\r\n     *\r\n     * It is useful when you want to avoid $[Nested Transactions] - savepoints.\r\n     *\r\n     * @param {string|number|Object} [options]\r\n     * This parameter is optional, and presumed skipped when the first parameter is a function (`cb` parameter).\r\n     *\r\n     * When it is of type `string` or `number`, it is assumed to be option `tag` passed in directly. Otherwise,\r\n     * it is expected to be an object with options as listed below.\r\n     *\r\n     * @param {} [options.tag]\r\n     * Traceable context for the task/transaction (see $[tags]).\r\n     *\r\n     * @param {txMode.TransactionMode} [options.mode]\r\n     * Transaction Configuration Mode - extends the transaction-opening command with additional configuration.\r\n     *\r\n     * @param {boolean|function} [options.cnd]\r\n     * Condition for opening a transaction ({@link Database#tx tx}), if it is met, or a {@link Database#task task} when the condition is not met.\r\n     * It can be either a simple boolean, or a callback function that takes the task/tx context as `this` and as the first parameter.\r\n     *\r\n     * Default condition (when it is not specified):\r\n     *\r\n     * ```js\r\n     * {cnd: t => !t.ctx || !t.ctx.inTransaction}\r\n     * ```\r\n     *\r\n     * @param {boolean|function} [options.reusable=false]\r\n     * When `cnd` is/returns false, reuse context of the current task/transaction, if one exists.\r\n     * It can be either a simple boolean, or a callback function that takes the task/tx context as `this`\r\n     * and as the first parameter.\r\n     *\r\n     * By default, when `cnd` is/returns false, the method creates a new task. This option tells\r\n     * the method to reuse the current task/transaction context, and not create a new task.\r\n     *\r\n     * This option is ignored when executing against the top level of the protocol, because on\r\n     * that level, if no transaction is suddenly needed, a new task becomes necessary.\r\n     *\r\n     * @param {function} cb\r\n     * Transaction/task callback function, to return the result that will determine either\r\n     * success or failure for the operation.\r\n     *\r\n     * The function can be either the first or the second parameter passed into the method.\r\n     *\r\n     * It also can be an ES7 `async` function.\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object with the result from the callback function.\r\n     *\r\n     * @see\r\n     * {@link Task},\r\n     * {@link Database#task Database.task},\r\n     * {@link Database#taskIf Database.taskIf},\r\n     * {@link Database#tx Database.tx},\r\n     * {@link TaskContext}\r\n     */\n    obj.txIf = function () {\n      const args = npm.pubUtils.taskArgs(arguments);\n      assert(args.options, ['tag', 'mode', 'cnd', 'reusable']);\n      try {\n        let cnd;\n        if ('cnd' in args.options) {\n          cnd = args.options.cnd;\n          cnd = typeof cnd === 'function' ? cnd.call(obj, obj) : !!cnd;\n        } else {\n          cnd = !obj.ctx || !obj.ctx.inTransaction;\n        }\n        args.options.cnd = cnd;\n        const reusable = args.options.reusable;\n        args.options.reusable = !cnd && obj.ctx && typeof reusable === 'function' ? reusable.call(obj, obj) : !!reusable;\n      } catch (e) {\n        return $p.reject(e);\n      }\n      return taskProcessor.call(this, args, args.options.cnd);\n    };\n\n    // Task method;\n    // Resolves with result from the callback function;\n    function taskProcessor(params, isTX) {\n      if (typeof params.cb !== 'function') {\n        return $p.reject(new TypeError('Callback function is required.'));\n      }\n      if (params.options.reusable) {\n        return config.$npm.task.callback(obj.ctx, obj, params.cb, config);\n      }\n      const taskCtx = ctx.clone(); // task context object;\n      if (isTX) {\n        taskCtx.txLevel = taskCtx.txLevel >= 0 ? taskCtx.txLevel + 1 : 0;\n      }\n      taskCtx.inTransaction = taskCtx.txLevel >= 0;\n      taskCtx.level = taskCtx.level >= 0 ? taskCtx.level + 1 : 0;\n      taskCtx.cb = params.cb; // callback function;\n      taskCtx.mode = params.options.mode; // transaction mode;\n      if (this !== obj) {\n        taskCtx.context = this; // calling context object;\n      }\n\n      const tsk = new config.$npm.task.Task(taskCtx, params.options.tag, isTX, config);\n      taskCtx.taskCtx = tsk.ctx;\n      extend(taskCtx, tsk);\n      if (taskCtx.db) {\n        // reuse existing connection;\n        npm.utils.addReadProp(tsk.ctx, 'useCount', taskCtx.db.useCount);\n        addServerVersion(tsk.ctx, taskCtx.db.client);\n        return config.$npm.task.execute(taskCtx, tsk, isTX, config);\n      }\n\n      // connection required;\n      return config.$npm.connect.pool(taskCtx, dbThis).then(db => {\n        taskCtx.connect(db);\n        npm.utils.addReadProp(tsk.ctx, 'useCount', db.useCount);\n        addServerVersion(tsk.ctx, db.client);\n        return config.$npm.task.execute(taskCtx, tsk, isTX, config);\n      }).then(data => {\n        taskCtx.disconnect();\n        return data;\n      }).catch(error => {\n        taskCtx.disconnect();\n        return $p.reject(error);\n      });\n    }\n    function addServerVersion(target, client) {\n      // Exclude else-case from coverage, because it can only occur with Native Bindings.\n      // istanbul ignore else\n      if (client.serverVersion) {\n        npm.utils.addReadProp(target, 'serverVersion', client.serverVersion);\n      }\n    }\n\n    // extending the protocol;\n    Events.extend(ctx.options, obj, ctx.dc);\n  }\n}\n\n// this event only happens when the connection is lost physically,\n// which cannot be tested automatically; removing from coverage:\n// istanbul ignore next\nfunction onError(err) {\n  // this client was never seen by pg-promise, which\n  // can happen if it failed to initialize\n  if (!err.client.$ctx) {\n    return;\n  }\n  const ctx = err.client.$ctx;\n  Events.error(ctx.options, err, {\n    cn: npm.utils.getSafeConnection(ctx.cn),\n    dc: ctx.dc\n  });\n}\nmodule.exports = config => {\n  const npmLocal = config.$npm;\n  npmLocal.connect = npmLocal.connect || npm.connect(config);\n  npmLocal.query = npmLocal.query || npm.query(config);\n  npmLocal.task = npmLocal.task || npm.task(config);\n  return Database;\n};\n\n/**\r\n * @callback Database.streamInitCB\r\n * @description\r\n * Stream initialization callback, used by {@link Database#stream Database.stream}.\r\n *\r\n * @param {external:Stream} stream\r\n * Stream object to initialize streaming.\r\n *\r\n * @example\r\n * const QueryStream = require('pg-query-stream');\r\n * const JSONStream = require('JSONStream');\r\n *\r\n * // you can also use pgp.as.format(query, values, options)\r\n * // to format queries properly, via pg-promise;\r\n * const qs = new QueryStream('SELECT * FROM users');\r\n *\r\n * db.stream(qs, stream => {\r\n *         // initiate streaming into the console:\r\n *         stream.pipe(JSONStream.stringify()).pipe(process.stdout);\r\n *     })\r\n *     .then(data => {\r\n *         console.log('Total rows processed:', data.processed,\r\n *           'Duration in milliseconds:', data.duration);\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n */\n\n/**\r\n * @external Stream\r\n * @see https://nodejs.org/api/stream.html\r\n */\n\n/**\r\n * @external pg-pool\r\n * @alias pg-pool\r\n * @see https://github.com/brianc/node-pg-pool\r\n */\n\n/**\r\n * @external Result\r\n * @see https://node-postgres.com/api/result\r\n */","map":{"version":3,"names":["Events","require","assert","resultQuery","multiResultQuery","streamQuery","ConnectionContext","DatabasePool","queryResult","npm","utils","pubUtils","connect","query","task","text","Database","cn","dc","config","dbThis","$p","promise","poolConnection","connectionString","pool","pgp","pg","Pool","endMethod","end","destroyed","cb","res","call","$destroy","on","onError","options","ctx","createContext","cnOptions","self","values","qrm","db","reject","Error","queryDisconnected","$npm","done","kill","looseQuery","disconnect","batch","opt","spex","page","source","sequence","connection","direct","then","client","extend","data","catch","error","addReadProp","ending","unregister","removeListener","register","transform","value","thisArg","obj","none","one","v","many","oneOrNone","manyOrNone","any","result","multiResult","multi","map","a","rows","stream","qs","init","func","funcName","entity","type","proc","procName","each","forEach","args","taskArgs","arguments","taskProcessor","taskIf","cnd","reusable","e","tx","txIf","inTransaction","params","isTX","TypeError","callback","taskCtx","clone","txLevel","level","mode","context","tsk","Task","tag","useCount","addServerVersion","execute","target","serverVersion","err","$ctx","getSafeConnection","module","exports","npmLocal"],"sources":["/Users/luna/Library/Mobile Documents/com~apple~CloudDocs/GitHub/paucamcal.github.io/AESP/node_modules/pg-promise/lib/database.js"],"sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {Events} = require('./events');\r\nconst {assert} = require('./assert');\r\nconst {resultQuery, multiResultQuery, streamQuery} = require('./special-query');\r\nconst {ConnectionContext} = require('./context');\r\nconst {DatabasePool} = require('./database-pool');\r\nconst {queryResult} = require('./query-result');\r\n\r\nconst npm = {\r\n    utils: require('./utils'),\r\n    pubUtils: require('./utils/public'),\r\n    connect: require('./connect'),\r\n    query: require('./query'),\r\n    task: require('./task'),\r\n    text: require('./text')\r\n};\r\n\r\n/**\r\n * @class Database\r\n * @description\r\n *\r\n * Represents the database protocol, extensible via event {@link event:extend extend}.\r\n * This type is not available directly, it can only be created via the library's base call.\r\n *\r\n * **IMPORTANT:**\r\n *\r\n * For any given connection, you should only create a single {@link Database} object in a separate module,\r\n * to be shared in your application (see the code example below). If instead you keep creating the {@link Database}\r\n * object dynamically, your application will suffer from loss in performance, and will be getting a warning in a\r\n * development environment (when `NODE_ENV` = `development`):\r\n *\r\n * `WARNING: Creating a duplicate database object for the same connection.`\r\n *\r\n * If you ever see this warning, rectify your {@link Database} object initialization, so there is only one object\r\n * per connection details. See the example provided below.\r\n *\r\n * See also: property `noWarnings` in {@link module:pg-promise Initialization Options}.\r\n *\r\n * Note however, that in special cases you may need to re-create the database object, if its connection pool has been\r\n * shut-down externally. And in this case the library won't be showing any warning.\r\n *\r\n * @param {string|object} cn\r\n * Database connection details, which can be:\r\n *\r\n * - a configuration object\r\n * - a connection string\r\n *\r\n * For details see {@link https://github.com/vitaly-t/pg-promise/wiki/Connection-Syntax Connection Syntax}.\r\n *\r\n * The value can be accessed from the database object via property {@link Database.$cn $cn}.\r\n *\r\n * @param {*} [dc]\r\n * Database Context.\r\n *\r\n * Any object or value to be propagated through the protocol, to allow implementations and event handling\r\n * that depend on the database context.\r\n *\r\n * This is mainly to facilitate the use of multiple databases which may need separate protocol extensions,\r\n * or different implementations within a single task / transaction callback, depending on the database context.\r\n *\r\n * This parameter also adds uniqueness to the connection context that's used in combination with the connection\r\n * parameters, i.e. use of unique database context will prevent getting the warning about creating a duplicate\r\n * Database object.\r\n *\r\n * The value can be accessed from the database object via property {@link Database#$dc $dc}.\r\n *\r\n * @returns {Database}\r\n *\r\n * @see\r\n *\r\n * {@link Database#query query},\r\n * {@link Database#none none},\r\n * {@link Database#one one},\r\n * {@link Database#oneOrNone oneOrNone},\r\n * {@link Database#many many},\r\n * {@link Database#manyOrNone manyOrNone},\r\n * {@link Database#any any},\r\n * {@link Database#func func},\r\n * {@link Database#proc proc},\r\n * {@link Database#result result},\r\n * {@link Database#multiResult multiResult},\r\n * {@link Database#multi multi},\r\n * {@link Database#map map},\r\n * {@link Database#each each},\r\n * {@link Database#stream stream},\r\n * {@link Database#task task},\r\n * {@link Database#taskIf taskIf},\r\n * {@link Database#tx tx},\r\n * {@link Database#txIf txIf},\r\n * {@link Database#connect connect},\r\n * {@link Database#$config $config},\r\n * {@link Database#$cn $cn},\r\n * {@link Database#$dc $dc},\r\n * {@link Database#$pool $pool},\r\n * {@link event:extend extend}\r\n *\r\n * @example\r\n * // Proper way to initialize and share the Database object\r\n *\r\n * // Loading and initializing the library:\r\n * const pgp = require('pg-promise')({\r\n *     // Initialization Options\r\n * });\r\n *\r\n * // Preparing the connection details:\r\n * const cn = 'postgres://username:password@host:port/database';\r\n *\r\n * // Creating a new database instance from the connection details:\r\n * const db = pgp(cn);\r\n *\r\n * // Exporting the database object for shared use:\r\n * module.exports = db;\r\n */\r\nfunction Database(cn, dc, config) {\r\n\r\n    const dbThis = this,\r\n        $p = config.promise,\r\n        poolConnection = typeof cn === 'string' ? {connectionString: cn} : cn,\r\n        pool = new config.pgp.pg.Pool(poolConnection),\r\n        endMethod = pool.end;\r\n\r\n    let destroyed;\r\n\r\n    pool.end = cb => {\r\n        const res = endMethod.call(pool, cb);\r\n        dbThis.$destroy();\r\n        return res;\r\n    };\r\n\r\n    pool.on('error', onError);\r\n\r\n    /**\r\n     * @method Database#connect\r\n     *\r\n     * @description\r\n     * Acquires a new or existing connection, depending on the current state of the connection pool, and parameter `direct`.\r\n     *\r\n     * This method creates a shared connection for executing a chain of queries against it. The connection must be released\r\n     * in the end of the chain by calling `done()` on the connection object.\r\n     *\r\n     * Method `done` takes one optional parameter - boolean `kill` flag, to signal the connection pool that you want it to kill\r\n     * the physical connection. This flag is ignored for direct connections, as they always close when released.\r\n     *\r\n     * It should not be used just for chaining queries on the same connection, methods {@link Database#task task} and\r\n     * {@link Database#tx tx} (for transactions) are to be used for that. This method is primarily for special cases, like\r\n     * `LISTEN` notifications.\r\n     *\r\n     * **NOTE:** Even though this method exposes a {@link external:Client Client} object via property `client`,\r\n     * you cannot call `client.end()` directly, or it will print an error into the console:\r\n     * `Abnormal client.end() call, due to invalid code or failed server connection.`\r\n     * You should only call method `done()` to release the connection.\r\n     *\r\n     * @param {object} [options]\r\n     * Connection Options.\r\n     *\r\n     * @param {boolean} [options.direct=false]\r\n     * Creates a new connection directly, as a stand-alone {@link external:Client Client} object, bypassing the connection pool.\r\n     *\r\n     * By default, all connections are acquired from the connection pool. But if you set this option, the library will instead\r\n     * create a new {@link external:Client Client} object directly (separately from the pool), and then call its `connect` method.\r\n     *\r\n     * Note that specifically for direct connections, method `done` returns a {@link external:Promise Promise}, because those connections\r\n     * are closed physically, which may take time.\r\n     *\r\n     * **WARNING:**\r\n     *\r\n     * Do not use this option for regular query execution, because it exclusively occupies one physical channel, and it cannot scale.\r\n     * This option is only suitable for global connection usage, such as event listeners.\r\n     *\r\n     * @param {function} [options.onLost]\r\n     * Notification callback of the lost/broken connection, called with the following parameters:\r\n     *  - `err` - the original connectivity error\r\n     *  - `e` - error context object, which contains:\r\n     *    - `cn` - safe connection string/config (with the password hashed);\r\n     *    - `dc` - Database Context, as was used during {@link Database} construction;\r\n     *    - `start` - Date/Time (`Date` type) when the connection was established;\r\n     *    - `client` - {@link external:Client Client} object that has lost the connection.\r\n     *\r\n     * The notification is mostly valuable with `direct: true`, to be able to re-connect direct/permanent connections by calling\r\n     * method {@link Database#connect connect} again.\r\n     *\r\n     * You do not need to call `done` on lost connections, as it happens automatically. However, if you had event listeners\r\n     * set up on the connection's `client` object, you should remove them to avoid leaks:\r\n     *\r\n     * ```js\r\n     * function onLostConnection(err, e) {\r\n     *     e.client.removeListener('my-event', myHandler);\r\n     * }\r\n     * ```\r\n     *\r\n     * For a complete example see $[Robust Listeners].\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object that represents the connection result:\r\n     *  - resolves with the complete {@link Database} protocol, extended with:\r\n     *    - property `client` of type {@link external:Client Client} that represents the open connection\r\n     *    - method `done` that must be called in the end, in order to release the connection (returns a {@link external:Promise Promise}\r\n     *      in case of direct connections)\r\n     *    - methods `batch`, `page` and `sequence`, same as inside a {@link Task}\r\n     *  - rejects with a connection-related error when it fails to connect.\r\n     *\r\n     * @see\r\n     * {@link Database#task Database.task},\r\n     * {@link Database#taskIf Database.taskIf},\r\n     * {@link Database#tx Database.tx},\r\n     * {@link Database#txIf Database.txIf}\r\n     *\r\n     * @example\r\n     *\r\n     * let sco; // shared connection object;\r\n     *\r\n     * db.connect()\r\n     *     .then(obj => {\r\n     *         // obj.client = new connected Client object;\r\n     *\r\n     *         sco = obj; // save the connection object;\r\n     *\r\n     *         // execute all the queries you need:\r\n     *         return sco.any('SELECT * FROM Users');\r\n     *     })\r\n     *     .then(data => {\r\n     *         // success\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // error\r\n     *     })\r\n     *     .finally(() => {\r\n     *         // release the connection, if it was successful:\r\n     *         if (sco) {\r\n     *             // if you pass `true` into method done, i.e. done(true),\r\n     *             // it will make the pool kill the physical connection.\r\n     *             sco.done();\r\n     *         }\r\n     *     });\r\n     *\r\n     */\r\n    this.connect = function (options) {\r\n        options = options || {};\r\n        const ctx = createContext();\r\n        ctx.cnOptions = options;\r\n        const self = {\r\n            query(query, values, qrm) {\r\n                if (!ctx.db) {\r\n                    return $p.reject(new Error(npm.text.queryDisconnected));\r\n                }\r\n                return config.$npm.query.call(this, ctx, query, values, qrm);\r\n            },\r\n            done(kill) {\r\n                if (!ctx.db) {\r\n                    throw new Error(npm.text.looseQuery);\r\n                }\r\n                return ctx.disconnect(kill);\r\n            },\r\n            batch(values, opt) {\r\n                return config.$npm.spex.batch.call(this, values, opt);\r\n            },\r\n            page(source, opt) {\r\n                return config.$npm.spex.page.call(this, source, opt);\r\n            },\r\n            sequence(source, opt) {\r\n                return config.$npm.spex.sequence.call(this, source, opt);\r\n            }\r\n        };\r\n        const connection = options.direct ? config.$npm.connect.direct(ctx) : config.$npm.connect.pool(ctx, dbThis);\r\n        return connection\r\n            .then(db => {\r\n                ctx.connect(db);\r\n                self.client = db.client;\r\n                extend(ctx, self);\r\n                return self;\r\n            });\r\n    };\r\n\r\n    /**\r\n     * @method Database#query\r\n     *\r\n     * @description\r\n     * Base query method that executes a generic query, expecting the return data according to parameter `qrm`.\r\n     *\r\n     * It performs the following steps:\r\n     *\r\n     *  1. Validates and formats the query via {@link formatting.format as.format}, according to the `query` and `values` passed in;\r\n     *  2. For a root-level query (against the {@link Database} object), it requests a new connection from the pool;\r\n     *  3. Executes the query;\r\n     *  4. For a root-level query (against the {@link Database} object), it releases the connection back to the pool;\r\n     *  5. Resolves/rejects, according to the data returned from the query and the value of `qrm`.\r\n     *\r\n     * Direct use of this method is not suitable for chaining queries, for performance reasons. It should be done\r\n     * through either task or transaction context, see $[Chaining Queries].\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Query formatting parameter(s), or a function that returns it.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @param {queryResult} [qrm=queryResult.any]\r\n     * {@link queryResult Query Result Mask}\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object that represents the query result according to `qrm`.\r\n     */\r\n    this.query = function (query, values, qrm) {\r\n        const self = this, ctx = createContext();\r\n        return config.$npm.connect.pool(ctx, dbThis)\r\n            .then(db => {\r\n                ctx.connect(db);\r\n                return config.$npm.query.call(self, ctx, query, values, qrm);\r\n            })\r\n            .then(data => {\r\n                ctx.disconnect();\r\n                return data;\r\n            })\r\n            .catch(error => {\r\n                ctx.disconnect();\r\n                return $p.reject(error);\r\n            });\r\n    };\r\n\r\n    /**\r\n     * @member {object} Database#$config\r\n     * @readonly\r\n     * @description\r\n     * This is a hidden property, to help integrating type {@link Database} directly with third-party libraries.\r\n     *\r\n     * Properties available in the object:\r\n     * - `pgp` - instance of the entire library after initialization\r\n     * - `options` - the library's {@link module:pg-promise Initialization Options} object\r\n     * - `promiseLib` - instance of the promise library that's used\r\n     * - `promise` - generic promise interface that uses `promiseLib` via 4 basic methods:\r\n     *   - `promise((resolve, reject) => {})` - to create a new promise\r\n     *   - `promise.resolve(value)` - to resolve with a value\r\n     *   - `promise.reject(reason)` - to reject with a reason\r\n     *   - `promise.all(iterable)` - to resolve an iterable list of promises\r\n     * - `version` - this library's version\r\n     * - `$npm` _(hidden property)_ - internal module cache\r\n     *\r\n     * @example\r\n     *\r\n     * // Using the promise protocol as configured by pg-promise:\r\n     *\r\n     * const $p = db.$config.promise;\r\n     *\r\n     * const resolvedPromise = $p.resolve('some data');\r\n     * const rejectedPromise = $p.reject('some reason');\r\n     *\r\n     * const newPromise = $p((resolve, reject) => {\r\n     *     // call either resolve(data) or reject(reason) here\r\n     * });\r\n     */\r\n    npm.utils.addReadProp(this, '$config', config, true);\r\n\r\n    /**\r\n     * @member {string|object} Database#$cn\r\n     * @readonly\r\n     * @description\r\n     * Database connection, as was passed in during the object's construction.\r\n     *\r\n     * This is a hidden property, to help integrating type {@link Database} directly with third-party libraries.\r\n     *\r\n     * @see Database\r\n     */\r\n    npm.utils.addReadProp(this, '$cn', cn, true);\r\n\r\n    /**\r\n     * @member {*} Database#$dc\r\n     * @readonly\r\n     * @description\r\n     * Database Context, as was passed in during the object's construction.\r\n     *\r\n     * This is a hidden property, to help integrating type {@link Database} directly with third-party libraries.\r\n     *\r\n     * @see Database\r\n     */\r\n    npm.utils.addReadProp(this, '$dc', dc, true);\r\n\r\n    /**\r\n     * @member {external:pg-pool} Database#$pool\r\n     * @readonly\r\n     * @description\r\n     * A $[pg-pool] object associated with the database object, as each {@link Database} creates its own $[pg-pool] instance.\r\n     *\r\n     * This is a hidden property, primarily for integrating type {@link Database} with third-party libraries that support\r\n     * $[pg-pool] directly. Note however, that if you pass the pool object into a library that calls `pool.end()`, you will no longer be able\r\n     * to use this {@link Database} object, and each query method will be rejecting with {@link external:Error Error} =\r\n     * `Connection pool of the database object has been destroyed.`\r\n     *\r\n     * You can also use this object to shut down the pool, by calling `$pool.end()`.\r\n     *\r\n     * For more details see $[Library de-initialization].\r\n     *\r\n     * @see\r\n     * {@link Database}\r\n     * {@link module:pg-promise~end pgp.end}\r\n     *\r\n     * @example\r\n     *\r\n     * // Shutting down the connection pool of this database object,\r\n     * // after all queries have finished in a run-though process:\r\n     *\r\n     * .then(() => {}) // processing the data\r\n     * .catch() => {}) // handling the error\r\n     * .finally(db.$pool.end); // shutting down the pool\r\n     *\r\n     */\r\n    npm.utils.addReadProp(this, '$pool', pool, true);\r\n\r\n    /**\r\n     * @member {function} Database.$destroy\r\n     * @readonly\r\n     * @private\r\n     * @description\r\n     * Permanently shuts down the database object.\r\n     */\r\n    npm.utils.addReadProp(this, '$destroy', () => {\r\n        if (!destroyed) {\r\n            if (!pool.ending) {\r\n                endMethod.call(pool);\r\n            }\r\n            DatabasePool.unregister(dbThis);\r\n            pool.removeListener('error', onError);\r\n            destroyed = true;\r\n        }\r\n    }, true);\r\n\r\n    DatabasePool.register(this);\r\n\r\n    extend(createContext(), this); // extending root protocol;\r\n\r\n    function createContext() {\r\n        return new ConnectionContext({cn, dc, options: config.options});\r\n    }\r\n\r\n    // Optional value-transformation helper:\r\n    function transform(value, cb, thisArg) {\r\n        return typeof cb === 'function' ? value.then(data => cb.call(thisArg, data)) : value;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////\r\n    // Injects additional methods into an access object,\r\n    // extending the protocol's base method 'query'.\r\n    function extend(ctx, obj) {\r\n\r\n        /**\r\n         * @method Database#none\r\n         * @description\r\n         * Executes a query that expects no data to be returned. If the query returns any data,\r\n         * the method rejects.\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @returns {external:Promise<null>}\r\n         * A promise object that represents the query result:\r\n         * - When no records are returned, it resolves with `null`.\r\n         * - When any data is returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n         *   - `.message` = `No return data was expected.`\r\n         *   - `.code` = {@link errors.queryResultErrorCode.notEmpty queryResultErrorCode.notEmpty}\r\n         */\r\n        obj.none = function (query, values) {\r\n            return obj.query.call(this, query, values, queryResult.none);\r\n        };\r\n\r\n        /**\r\n         * @method Database#one\r\n         * @description\r\n         * Executes a query that expects exactly 1 row to be returned. When 0 or more than 1 rows are returned,\r\n         * the method rejects.\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @param {function} [cb]\r\n         * Value-transformation callback, to allow in-line value change.\r\n         * When specified, the returned value replaces the original one.\r\n         *\r\n         * The function takes only one parameter - value resolved from the query.\r\n         *\r\n         * @param {*} [thisArg]\r\n         * Value to use as `this` when executing the transformation callback.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object that represents the query result:\r\n         * - When 1 row is returned, it resolves with that row as a single object.\r\n         * - When no rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n         *   - `.message` = `No data returned from the query.`\r\n         *   - `.code` = {@link errors.queryResultErrorCode.noData queryResultErrorCode.noData}\r\n         * - When multiple rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n         *   - `.message` = `Multiple rows were not expected.`\r\n         *   - `.code` = {@link errors.queryResultErrorCode.multiple queryResultErrorCode.multiple}\r\n         * - Resolves with the new value, if transformation callback `cb` was specified.\r\n         *\r\n         * @see\r\n         * {@link Database#oneOrNone oneOrNone}\r\n         *\r\n         * @example\r\n         *\r\n         * // a query with in-line value transformation:\r\n         * db.one('INSERT INTO Events VALUES($1) RETURNING id', [123], event => event.id)\r\n         *     .then(data => {\r\n         *         // data = a new event id, rather than an object with it\r\n         *     });\r\n         *\r\n         * @example\r\n         *\r\n         * // a query with in-line value transformation + conversion:\r\n         * db.one('SELECT count(*) FROM Users', [], c => +c.count)\r\n         *     .then(count => {\r\n         *         // count = a proper integer value, rather than an object with a string\r\n         *     });\r\n         *\r\n         */\r\n        obj.one = function (query, values, cb, thisArg) {\r\n            const v = obj.query.call(this, query, values, queryResult.one);\r\n            return transform(v, cb, thisArg);\r\n        };\r\n\r\n        /**\r\n         * @method Database#many\r\n         * @description\r\n         * Executes a query that expects one or more rows to be returned. When the query returns no rows, the method rejects.\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object that represents the query result:\r\n         * - When 1 or more rows are returned, it resolves with the array of rows.\r\n         * - When no rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n         *   - `.message` = `No data returned from the query.`\r\n         *   - `.code` = {@link errors.queryResultErrorCode.noData queryResultErrorCode.noData}\r\n         */\r\n        obj.many = function (query, values) {\r\n            return obj.query.call(this, query, values, queryResult.many);\r\n        };\r\n\r\n        /**\r\n         * @method Database#oneOrNone\r\n         * @description\r\n         * Executes a query that expects 0 or 1 rows to be returned. It resolves with the row-object when 1 row is returned,\r\n         * or with `null` when nothing is returned. When the query returns more than 1 row, the method rejects.\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @param {function} [cb]\r\n         * Value-transformation callback, to allow in-line value change.\r\n         * When specified, the returned value replaces the original one.\r\n         *\r\n         * The function takes only one parameter - value resolved from the query.\r\n         *\r\n         * @param {*} [thisArg]\r\n         * Value to use as `this` when executing the transformation callback.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object that represents the query result:\r\n         * - When no rows are returned, it resolves with `null`.\r\n         * - When 1 row is returned, it resolves with that row as a single object.\r\n         * - When multiple rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n         *   - `.message` = `Multiple rows were not expected.`\r\n         *   - `.code` = {@link errors.queryResultErrorCode.multiple queryResultErrorCode.multiple}\r\n         * - Resolves with the new value, if transformation callback `cb` was specified.\r\n         *\r\n         * @see\r\n         * {@link Database#one one},\r\n         * {@link Database#none none},\r\n         * {@link Database#manyOrNone manyOrNone}\r\n         *\r\n         * @example\r\n         *\r\n         * // a query with in-line value transformation:\r\n         * db.oneOrNone('SELECT id FROM Events WHERE type = $1', ['entry'], e => e && e.id)\r\n         *     .then(data => {\r\n         *         // data = the event id or null (rather than object or null)\r\n         *     });\r\n         *\r\n         */\r\n        obj.oneOrNone = function (query, values, cb, thisArg) {\r\n            const v = obj.query.call(this, query, values, queryResult.one | queryResult.none);\r\n            return transform(v, cb, thisArg);\r\n        };\r\n\r\n        /**\r\n         * @method Database#manyOrNone\r\n         * @description\r\n         * Executes a query that can return any number of rows.\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @returns {external:Promise<Array>}\r\n         * A promise object that represents the query result:\r\n         * - When no rows are returned, it resolves with an empty array.\r\n         * - When 1 or more rows are returned, it resolves with the array of rows.\r\n         *\r\n         * @see\r\n         * {@link Database#any any},\r\n         * {@link Database#many many},\r\n         * {@link Database#none none}\r\n         *\r\n         */\r\n        obj.manyOrNone = function (query, values) {\r\n            return obj.query.call(this, query, values, queryResult.many | queryResult.none);\r\n        };\r\n\r\n        /**\r\n         * @method Database#any\r\n         * @description\r\n         * Executes a query that can return any number of rows.\r\n         * This is simply a shorter alias for method {@link Database#manyOrNone manyOrNone}.\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @returns {external:Promise<Array>}\r\n         * A promise object that represents the query result:\r\n         * - When no rows are returned, it resolves with an empty array.\r\n         * - When 1 or more rows are returned, it resolves with the array of rows.\r\n         *\r\n         * @see\r\n         * {@link Database#manyOrNone manyOrNone},\r\n         * {@link Database#map map},\r\n         * {@link Database#each each}\r\n         *\r\n         */\r\n        obj.any = function (query, values) {\r\n            return obj.query.call(this, query, values, queryResult.any);\r\n        };\r\n\r\n        /**\r\n         * @method Database#result\r\n         * @description\r\n         * Executes a query without any expectation for the return data, and resolves with the\r\n         * original $[Result] object when successful.\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @param {function} [cb]\r\n         * Value-transformation callback, to allow in-line value change.\r\n         * When specified, the returned value replaces the original one.\r\n         *\r\n         * The function takes only one parameter - value resolved from the query.\r\n         *\r\n         * @param {*} [thisArg]\r\n         * Value to use as `this` when executing the transformation callback.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object that represents the query result:\r\n         * - resolves with the original $[Result] object (by default);\r\n         * - resolves with the new value, if transformation callback `cb` was specified.\r\n         *\r\n         * @example\r\n         *\r\n         * // use of value transformation:\r\n         * // deleting rows and returning the number of rows deleted\r\n         * db.result('DELETE FROM Events WHERE id = $1', [123], r => r.rowCount)\r\n         *     .then(data => {\r\n         *         // data = number of rows that were deleted\r\n         *     });\r\n         *\r\n         * @example\r\n         *\r\n         * // use of value transformation:\r\n         * // getting only column details from a table\r\n         * db.result('SELECT * FROM Users LIMIT 0', null, r => r.fields)\r\n         *     .then(data => {\r\n         *         // data = array of column descriptors\r\n         *     });\r\n         *\r\n         */\r\n        obj.result = function (query, values, cb, thisArg) {\r\n            const v = obj.query.call(this, query, values, resultQuery);\r\n            return transform(v, cb, thisArg);\r\n        };\r\n\r\n        /**\r\n         * @method Database#multiResult\r\n         * @description\r\n         * Executes a multi-query string, without any expectation for the return data, and resolves with an array\r\n         * of the original $[Result] objects when successful.\r\n         *\r\n         * The operation is atomic, i.e. all queries are executed in a single transaction, unless there are explicit\r\n         * `BEGIN/COMMIT` commands included in the query string to divide it into multiple transactions.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Multi-query string to be executed, which can be any of the following types:\r\n         * - A non-empty string that can contain any number of queries\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @returns {external:Promise<external:Result[]>}\r\n         *\r\n         * @see {@link Database#multi multi}\r\n         *\r\n         */\r\n        obj.multiResult = function (query, values) {\r\n            return obj.query.call(this, query, values, multiResultQuery);\r\n        };\r\n\r\n        /**\r\n         * @method Database#multi\r\n         * @description\r\n         * Executes a multi-query string, without any expectation for the return data, and resolves with an array\r\n         * of arrays of rows when successful.\r\n         *\r\n         * The operation is atomic, i.e. all queries are executed in a single transaction, unless there are explicit\r\n         * `BEGIN/COMMIT` commands included in the query string to divide it into multiple transactions.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Multi-query string to be executed, which can be any of the following types:\r\n         * - A non-empty string that can contain any number of queries\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @returns {external:Promise<Array<Array>>}\r\n         *\r\n         * @see {@link Database#multiResult multiResult}\r\n         *\r\n         * @example\r\n         *\r\n         * // Get data from 2 tables in a single request:\r\n         * const [users, products] = await db.multi('SELECT * FROM users;SELECT * FROM products');\r\n         *\r\n         */\r\n        obj.multi = function (query, values) {\r\n            return obj.query.call(this, query, values, multiResultQuery)\r\n                .then(data => data.map(a => a.rows));\r\n        };\r\n\r\n        /**\r\n         * @method Database#stream\r\n         * @description\r\n         * Custom data streaming, with the help of $[pg-query-stream].\r\n         *\r\n         * This method doesn't work with the $[Native Bindings], and if option `pgNative`\r\n         * is set, it will reject with `Streaming doesn't work with Native Bindings.`\r\n         *\r\n         * @param {QueryStream} qs\r\n         * Stream object of type $[QueryStream].\r\n         *\r\n         * @param {Database.streamInitCB} initCB\r\n         * Stream initialization callback.\r\n         *\r\n         * It is invoked with the same `this` context as the calling method.\r\n         *\r\n         * @returns {external:Promise}\r\n         * Result of the streaming operation.\r\n         *\r\n         * Once the streaming has finished successfully, the method resolves with\r\n         * `{processed, duration}`:\r\n         * - `processed` - total number of rows processed;\r\n         * - `duration` - streaming duration, in milliseconds.\r\n         *\r\n         * Possible rejections messages:\r\n         * - `Invalid or missing stream object.`\r\n         * - `Invalid stream state.`\r\n         * - `Invalid or missing stream initialization callback.`\r\n         */\r\n        obj.stream = function (qs, init) {\r\n            return obj.query.call(this, qs, init, streamQuery);\r\n        };\r\n\r\n        /**\r\n         * @method Database#func\r\n         * @description\r\n         * Executes a database function that returns a table, abbreviating the full syntax\r\n         * of `query('SELECT * FROM $1:alias($2:csv)', [funcName, values], qrm)`.\r\n         *\r\n         * @param {string} funcName\r\n         * Name of the function to be executed.\r\n         * When it is not same-case, or contains extended symbols, it is double-quoted, as per the `:alias` filter,\r\n         * which also supports `.`, to auto-split into a composite name.\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Parameters for the function - one value | array of values | function returning value(s).\r\n         *\r\n         * @param {queryResult} [qrm=queryResult.any] - {@link queryResult Query Result Mask}.\r\n         *\r\n         * @returns {external:Promise}\r\n         *\r\n         * A promise object as returned from method {@link Database#query query}, according to parameter `qrm`.\r\n         *\r\n         * @see\r\n         * {@link Database#query query},\r\n         * {@link Database#proc proc}\r\n         */\r\n        obj.func = function (funcName, values, qrm) {\r\n            return obj.query.call(this, {entity: funcName, type: 'func'}, values, qrm);\r\n        };\r\n\r\n        /**\r\n         * @method Database#proc\r\n         * @description\r\n         * Executes a stored procedure by name, abbreviating the full syntax of\r\n         * `oneOrNone('CALL $1:alias($2:csv)', [procName, values], cb, thisArg)`.\r\n         *\r\n         * **NOTE:** This method uses the new `CALL` syntax that requires PostgreSQL v11 or later.\r\n         *\r\n         * @param {string} procName\r\n         * Name of the stored procedure to be executed.\r\n         * When it is not same-case, or contains extended symbols, it is double-quoted, as per the `:alias` filter,\r\n         * which also supports `.`, to auto-split into a composite SQL name.\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Parameters for the procedure - one value | array of values | function returning value(s).\r\n         *\r\n         * @param {function} [cb]\r\n         * Value-transformation callback, to allow in-line value change.\r\n         * When specified, the returned value replaces the original one.\r\n         *\r\n         * The function takes only one parameter - value resolved from the query.\r\n         *\r\n         * @param {*} [thisArg]\r\n         * Value to use as `this` when executing the transformation callback.\r\n         *\r\n         * @returns {external:Promise}\r\n         * When the procedure takes output parameters, a single object is returned, with\r\n         * properties for the output values. Otherwise, the method resolves with `null`.\r\n         * And if the value-transformation callback is provided, it overrides the result.\r\n         *\r\n         * @see\r\n         * {@link Database#func func}\r\n         */\r\n        obj.proc = function (procName, values, cb, thisArg) {\r\n            const v = obj.query.call(this, {\r\n                entity: procName,\r\n                type: 'proc'\r\n            }, values, queryResult.one | queryResult.none);\r\n            return transform(v, cb, thisArg);\r\n        };\r\n\r\n        /**\r\n         * @method Database#map\r\n         * @description\r\n         * Creates a new array with the results of calling a provided function on every element in the array of rows\r\n         * resolved by method {@link Database#any any}.\r\n         *\r\n         * It is a convenience method, to reduce the following code:\r\n         *\r\n         * ```js\r\n         * db.any(query, values)\r\n         *     .then(data => {\r\n         *         return data.map((row, index, data) => {\r\n         *              // return a new element\r\n         *         });\r\n         *     });\r\n         * ```\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} values\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @param {function} cb\r\n         * Function that produces an element of the new array, taking three arguments:\r\n         * - `row` - the current row object being processed in the array\r\n         * - `index` - the index of the current row being processed in the array\r\n         * - `data` - the original array of rows resolved by method {@link Database#any any}\r\n         *\r\n         * @param {*} [thisArg]\r\n         * Value to use as `this` when executing the callback.\r\n         *\r\n         * @returns {external:Promise<Array>}\r\n         * Resolves with the new array of values returned from the callback.\r\n         *\r\n         * @see\r\n         * {@link Database#any any},\r\n         * {@link Database#each each},\r\n         * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map Array.map}\r\n         *\r\n         * @example\r\n         *\r\n         * db.map('SELECT id FROM Users WHERE status = $1', ['active'], row => row.id)\r\n         *     .then(data => {\r\n         *         // data = array of active user id-s\r\n         *     })\r\n         *     .catch(error => {\r\n         *        // error\r\n         *     });\r\n         *\r\n         * @example\r\n         *\r\n         * db.tx(t => {\r\n         *     return t.map('SELECT id FROM Users WHERE status = $1', ['active'], row => {\r\n         *        return t.none('UPDATE Events SET checked = $1 WHERE userId = $2', [true, row.id]);\r\n         *     }).then(t.batch);\r\n         * })\r\n         *     .then(data => {\r\n         *         // success\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         * @example\r\n         *\r\n         * // Build a list of active users, each with the list of user events:\r\n         * db.task(t => {\r\n         *     return t.map('SELECT id FROM Users WHERE status = $1', ['active'], user => {\r\n         *         return t.any('SELECT * FROM Events WHERE userId = $1', user.id)\r\n         *             .then(events=> {\r\n         *                 user.events = events;\r\n         *                 return user;\r\n         *             });\r\n         *     }).then(t.batch);\r\n         * })\r\n         *     .then(data => {\r\n         *         // success\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         */\r\n        obj.map = function (query, values, cb, thisArg) {\r\n            return obj.any.call(this, query, values)\r\n                .then(data => data.map(cb, thisArg));\r\n        };\r\n\r\n        /**\r\n         * @method Database#each\r\n         * @description\r\n         * Executes a provided function once per array element, for an array of rows resolved by method {@link Database#any any}.\r\n         *\r\n         * It is a convenience method to reduce the following code:\r\n         *\r\n         * ```js\r\n         * db.any(query, values)\r\n         *     .then(data => {\r\n         *         data.forEach((row, index, data) => {\r\n         *              // process the row\r\n         *         });\r\n         *         return data;\r\n         *     });\r\n         * ```\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @param {function} cb\r\n         * Function to execute for each row, taking three arguments:\r\n         * - `row` - the current row object being processed in the array\r\n         * - `index` - the index of the current row being processed in the array\r\n         * - `data` - the array of rows resolved by method {@link Database#any any}\r\n         *\r\n         * @param {*} [thisArg]\r\n         * Value to use as `this` when executing the callback.\r\n         *\r\n         * @returns {external:Promise<Array<Object>>}\r\n         * Resolves with the original array of rows.\r\n         *\r\n         * @see\r\n         * {@link Database#any any},\r\n         * {@link Database#map map},\r\n         * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach Array.forEach}\r\n         *\r\n         * @example\r\n         *\r\n         * db.each('SELECT id, code, name FROM Events', [], row => {\r\n         *     row.code = parseInt(row.code);\r\n         * })\r\n         *     .then(data => {\r\n         *         // data = array of events, with 'code' converted into integer\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         */\r\n        obj.each = function (query, values, cb, thisArg) {\r\n            return obj.any.call(this, query, values)\r\n                .then(data => {\r\n                    data.forEach(cb, thisArg);\r\n                    return data;\r\n                });\r\n        };\r\n\r\n        /**\r\n         * @method Database#task\r\n         * @description\r\n         * Executes a callback function with automatically managed connection.\r\n         *\r\n         * When invoked on the root {@link Database} object, the method allocates the connection from the pool,\r\n         * executes the callback, and once finished - releases the connection back to the pool.\r\n         * However, when invoked inside another task or transaction, the method reuses the parent connection.\r\n         *\r\n         * This method should be used whenever executing more than one query at once, so the allocated connection\r\n         * is reused between all queries, and released only after the task has finished (see $[Chaining Queries]).\r\n         *\r\n         * The callback function is called with one parameter - database protocol (same as `this`), extended with methods\r\n         * {@link Task#batch batch}, {@link Task#page page}, {@link Task#sequence sequence}, plus property {@link Task#ctx ctx} -\r\n         * the task context object. See class {@link Task} for more details.\r\n         *\r\n         * @param {string|number|Object} [options]\r\n         * This parameter is optional, and presumed skipped when the first parameter is a function (`cb` parameter).\r\n         *\r\n         * When it is of type `string` or `number`, it is assumed to be option `tag` passed in directly. Otherwise,\r\n         * it is expected to be an object with options as listed below.\r\n         *\r\n         * @param {} [options.tag]\r\n         * Traceable context for the task (see $[tags]).\r\n         *\r\n         * @param {function} cb\r\n         * Task callback function, to return the result that will determine either success or failure for the operation.\r\n         *\r\n         * The function can be either the first of the second parameter passed into the method.\r\n         *\r\n         * It also can be an ES7 `async` function.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object with the result from the callback function.\r\n         *\r\n         * @see\r\n         * {@link Task},\r\n         * {@link Database#taskIf taskIf},\r\n         * {@link Database#tx tx},\r\n         * $[tags],\r\n         * $[Chaining Queries]\r\n         *\r\n         * @example\r\n         *\r\n         * db.task('my-task', t => {\r\n         *         // t.ctx = task context object\r\n         *\r\n         *         return t.one('SELECT id FROM Users WHERE name = $1', 'John')\r\n         *             .then(user => {\r\n         *                 return t.any('SELECT * FROM Events WHERE userId = $1', user.id);\r\n         *             });\r\n         *     })\r\n         *     .then(data => {\r\n         *         // success\r\n         *         // data = as returned from the task's callback\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         * @example\r\n         *\r\n         * // using an ES7 syntax for the callback:\r\n         * db.task('my-task', async t {\r\n         *         // t.ctx = task context object\r\n         *\r\n         *         const user = await t.one('SELECT id FROM Users WHERE name = $1', 'John');\r\n         *         return t.any('SELECT * FROM Events WHERE userId = $1', user.id);\r\n         *     })\r\n         *     .then(data => {\r\n         *         // success\r\n         *         // data = as returned from the task's callback\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         */\r\n        obj.task = function () {\r\n            const args = npm.pubUtils.taskArgs(arguments);\r\n            assert(args.options, ['tag']);\r\n            return taskProcessor.call(this, args, false);\r\n        };\r\n\r\n        /**\r\n         * @method Database#taskIf\r\n         * @description\r\n         * Executes a conditional task that results in an actual new {@link Database#task task}, if either condition is met or\r\n         * when it is necessary (on the top level), or else it reuses the current connection context.\r\n         *\r\n         * The default condition is `not in task or transaction`, to start a task only if currently not inside another task or transaction,\r\n         * which is the same as calling the following:\r\n         *\r\n         * ```js\r\n         * db.taskIf({cnd: t => !t.ctx}, cb => {})\r\n         * ```\r\n         *\r\n         * It can be useful, if you want to simplify/reduce the task + log events footprint, by creating new tasks only when necessary.\r\n         *\r\n         * @param {string|number|Object} [options]\r\n         * This parameter is optional, and presumed skipped when the first parameter is a function (`cb` parameter).\r\n         *\r\n         * When it is of type `string` or `number`, it is assumed to be option `tag` passed in directly. Otherwise,\r\n         * it is expected to be an object with options as listed below.\r\n         *\r\n         * @param {} [options.tag]\r\n         * Traceable context for the task/transaction (see $[tags]).\r\n         *\r\n         * @param {boolean|function} [options.cnd]\r\n         * Condition for creating a ({@link Database#task task}), if it is met.\r\n         * It can be either a simple boolean, or a callback function that takes the task context as `this` and as the first parameter.\r\n         *\r\n         * Default condition (when it is not specified):\r\n         *\r\n         * ```js\r\n         * {cnd: t => !t.ctx}\r\n         * ```\r\n         *\r\n         * @param {function} cb\r\n         * Task callback function, to return the result that will determine either success or failure for the operation.\r\n         *\r\n         * The function can be either the first or the second parameter passed into the method.\r\n         *\r\n         * It also can be an ES7 `async` function.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object with the result from the callback function.\r\n         *\r\n         * @see\r\n         * {@link Task},\r\n         * {@link Database#task Database.task},\r\n         * {@link Database#tx Database.tx},\r\n         * {@link Database#txIf Database.txIf},\r\n         * {@link TaskContext}\r\n         *\r\n         */\r\n        obj.taskIf = function () {\r\n            const args = npm.pubUtils.taskArgs(arguments);\r\n            assert(args.options, ['tag', 'cnd']);\r\n            try {\r\n                let cnd = args.options.cnd;\r\n                if ('cnd' in args.options) {\r\n                    cnd = typeof cnd === 'function' ? cnd.call(obj, obj) : !!cnd;\r\n                } else {\r\n                    cnd = !obj.ctx; // create task, if it is the top level\r\n                }\r\n                // reusable only if condition fails, and not top-level:\r\n                args.options.reusable = !cnd && !!obj.ctx;\r\n            } catch (e) {\r\n                return $p.reject(e);\r\n            }\r\n            return taskProcessor.call(this, args, false);\r\n        };\r\n\r\n        /**\r\n         * @method Database#tx\r\n         * @description\r\n         * Executes a callback function as a transaction, with automatically managed connection.\r\n         *\r\n         * When invoked on the root {@link Database} object, the method allocates the connection from the pool,\r\n         * executes the callback, and once finished - releases the connection back to the pool.\r\n         * However, when invoked inside another task or transaction, the method reuses the parent connection.\r\n         *\r\n         * A transaction wraps a regular {@link Database#task task} into additional queries:\r\n         * - it executes `BEGIN` just before invoking the callback function\r\n         * - it executes `COMMIT`, if the callback didn't throw any error or return a rejected promise\r\n         * - it executes `ROLLBACK`, if the callback did throw an error or return a rejected promise\r\n         * - it executes corresponding `SAVEPOINT` commands when the method is called recursively.\r\n         *\r\n         * The callback function is called with one parameter - database protocol (same as `this`), extended with methods\r\n         * {@link Task#batch batch}, {@link Task#page page}, {@link Task#sequence sequence}, plus property {@link Task#ctx ctx} -\r\n         * the transaction context object. See class {@link Task} for more details.\r\n         *\r\n         * Note that transactions should be chosen over tasks only where necessary, because unlike regular tasks,\r\n         * transactions are blocking operations.\r\n         *\r\n         * @param {string|number|Object} [options]\r\n         * This parameter is optional, and presumed skipped when the first parameter is a function (`cb` parameter).\r\n         *\r\n         * When it is of type `string` or `number`, it is assumed to be option `tag` passed in directly. Otherwise,\r\n         * it is expected to be an object with options as listed below.\r\n         *\r\n         * @param {} [options.tag]\r\n         * Traceable context for the transaction (see $[tags]).\r\n         *\r\n         * @param {txMode.TransactionMode} [options.mode]\r\n         * Transaction Configuration Mode - extends the transaction-opening command with additional configuration.\r\n         *\r\n         * @param {function} cb\r\n         * Transaction callback function, to return the result that will determine either success or failure for the operation.\r\n         *\r\n         * The function can be either the first of the second parameter passed into the method.\r\n         *\r\n         * It also can be an ES7 `async` function.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object with the result from the callback function.\r\n         *\r\n         * @see\r\n         * {@link Task},\r\n         * {@link Database#task Database.task},\r\n         * {@link Database#taskIf Database.taskIf},\r\n         * {@link TaskContext},\r\n         * $[tags],\r\n         * $[Chaining Queries]\r\n         *\r\n         * @example\r\n         *\r\n         * db.tx('my-transaction', t => {\r\n         *         // t.ctx = transaction context object\r\n         *\r\n         *         return t.one('INSERT INTO Users(name, age) VALUES($1, $2) RETURNING id', ['Mike', 25])\r\n         *             .then(user => {\r\n         *                 return t.batch([\r\n         *                     t.none('INSERT INTO Events(userId, name) VALUES($1, $2)', [user.id, 'created']),\r\n         *                     t.none('INSERT INTO Events(userId, name) VALUES($1, $2)', [user.id, 'login'])\r\n         *                 ]);\r\n         *             });\r\n         *     })\r\n         *     .then(data => {\r\n         *         // success\r\n         *         // data = as returned from the transaction's callback\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         * @example\r\n         *\r\n         * // using an ES7 syntax for the callback:\r\n         * db.tx('my-transaction', async t {\r\n         *         // t.ctx = transaction context object\r\n         *\r\n         *         const user = await t.one('INSERT INTO Users(name, age) VALUES($1, $2) RETURNING id', ['Mike', 25]);\r\n         *         return t.none('INSERT INTO Events(userId, name) VALUES($1, $2)', [user.id, 'created']);\r\n         *     })\r\n         *     .then(data => {\r\n         *         // success\r\n         *         // data = as returned from the transaction's callback\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         */\r\n        obj.tx = function () {\r\n            const args = npm.pubUtils.taskArgs(arguments);\r\n            assert(args.options, ['tag', 'mode']);\r\n            return taskProcessor.call(this, args, true);\r\n        };\r\n\r\n        /**\r\n         * @method Database#txIf\r\n         * @description\r\n         * Executes a conditional transaction that results in an actual transaction ({@link Database#tx tx}), if the condition is met,\r\n         * or else it executes a regular {@link Database#task task}.\r\n         *\r\n         * The default condition is `not in transaction`, to start a transaction only if currently not in transaction,\r\n         * or else start a task, which is the same as calling the following:\r\n         *\r\n         * ```js\r\n         * db.txIf({cnd: t => !t.ctx || !t.ctx.inTransaction}, cb => {})\r\n         * ```\r\n         *\r\n         * It is useful when you want to avoid $[Nested Transactions] - savepoints.\r\n         *\r\n         * @param {string|number|Object} [options]\r\n         * This parameter is optional, and presumed skipped when the first parameter is a function (`cb` parameter).\r\n         *\r\n         * When it is of type `string` or `number`, it is assumed to be option `tag` passed in directly. Otherwise,\r\n         * it is expected to be an object with options as listed below.\r\n         *\r\n         * @param {} [options.tag]\r\n         * Traceable context for the task/transaction (see $[tags]).\r\n         *\r\n         * @param {txMode.TransactionMode} [options.mode]\r\n         * Transaction Configuration Mode - extends the transaction-opening command with additional configuration.\r\n         *\r\n         * @param {boolean|function} [options.cnd]\r\n         * Condition for opening a transaction ({@link Database#tx tx}), if it is met, or a {@link Database#task task} when the condition is not met.\r\n         * It can be either a simple boolean, or a callback function that takes the task/tx context as `this` and as the first parameter.\r\n         *\r\n         * Default condition (when it is not specified):\r\n         *\r\n         * ```js\r\n         * {cnd: t => !t.ctx || !t.ctx.inTransaction}\r\n         * ```\r\n         *\r\n         * @param {boolean|function} [options.reusable=false]\r\n         * When `cnd` is/returns false, reuse context of the current task/transaction, if one exists.\r\n         * It can be either a simple boolean, or a callback function that takes the task/tx context as `this`\r\n         * and as the first parameter.\r\n         *\r\n         * By default, when `cnd` is/returns false, the method creates a new task. This option tells\r\n         * the method to reuse the current task/transaction context, and not create a new task.\r\n         *\r\n         * This option is ignored when executing against the top level of the protocol, because on\r\n         * that level, if no transaction is suddenly needed, a new task becomes necessary.\r\n         *\r\n         * @param {function} cb\r\n         * Transaction/task callback function, to return the result that will determine either\r\n         * success or failure for the operation.\r\n         *\r\n         * The function can be either the first or the second parameter passed into the method.\r\n         *\r\n         * It also can be an ES7 `async` function.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object with the result from the callback function.\r\n         *\r\n         * @see\r\n         * {@link Task},\r\n         * {@link Database#task Database.task},\r\n         * {@link Database#taskIf Database.taskIf},\r\n         * {@link Database#tx Database.tx},\r\n         * {@link TaskContext}\r\n         */\r\n        obj.txIf = function () {\r\n            const args = npm.pubUtils.taskArgs(arguments);\r\n            assert(args.options, ['tag', 'mode', 'cnd', 'reusable']);\r\n            try {\r\n                let cnd;\r\n                if ('cnd' in args.options) {\r\n                    cnd = args.options.cnd;\r\n                    cnd = typeof cnd === 'function' ? cnd.call(obj, obj) : !!cnd;\r\n                } else {\r\n                    cnd = !obj.ctx || !obj.ctx.inTransaction;\r\n                }\r\n                args.options.cnd = cnd;\r\n                const reusable = args.options.reusable;\r\n                args.options.reusable = !cnd && obj.ctx && typeof reusable === 'function' ? reusable.call(obj, obj) : !!reusable;\r\n            } catch (e) {\r\n                return $p.reject(e);\r\n            }\r\n            return taskProcessor.call(this, args, args.options.cnd);\r\n        };\r\n\r\n        // Task method;\r\n        // Resolves with result from the callback function;\r\n        function taskProcessor(params, isTX) {\r\n\r\n            if (typeof params.cb !== 'function') {\r\n                return $p.reject(new TypeError('Callback function is required.'));\r\n            }\r\n\r\n            if (params.options.reusable) {\r\n                return config.$npm.task.callback(obj.ctx, obj, params.cb, config);\r\n            }\r\n\r\n            const taskCtx = ctx.clone(); // task context object;\r\n            if (isTX) {\r\n                taskCtx.txLevel = taskCtx.txLevel >= 0 ? (taskCtx.txLevel + 1) : 0;\r\n            }\r\n            taskCtx.inTransaction = taskCtx.txLevel >= 0;\r\n            taskCtx.level = taskCtx.level >= 0 ? (taskCtx.level + 1) : 0;\r\n            taskCtx.cb = params.cb; // callback function;\r\n            taskCtx.mode = params.options.mode; // transaction mode;\r\n            if (this !== obj) {\r\n                taskCtx.context = this; // calling context object;\r\n            }\r\n\r\n            const tsk = new config.$npm.task.Task(taskCtx, params.options.tag, isTX, config);\r\n            taskCtx.taskCtx = tsk.ctx;\r\n            extend(taskCtx, tsk);\r\n\r\n            if (taskCtx.db) {\r\n                // reuse existing connection;\r\n                npm.utils.addReadProp(tsk.ctx, 'useCount', taskCtx.db.useCount);\r\n                addServerVersion(tsk.ctx, taskCtx.db.client);\r\n                return config.$npm.task.execute(taskCtx, tsk, isTX, config);\r\n            }\r\n\r\n            // connection required;\r\n            return config.$npm.connect.pool(taskCtx, dbThis)\r\n                .then(db => {\r\n                    taskCtx.connect(db);\r\n                    npm.utils.addReadProp(tsk.ctx, 'useCount', db.useCount);\r\n                    addServerVersion(tsk.ctx, db.client);\r\n                    return config.$npm.task.execute(taskCtx, tsk, isTX, config);\r\n                })\r\n                .then(data => {\r\n                    taskCtx.disconnect();\r\n                    return data;\r\n                })\r\n                .catch(error => {\r\n                    taskCtx.disconnect();\r\n                    return $p.reject(error);\r\n                });\r\n        }\r\n\r\n        function addServerVersion(target, client) {\r\n            // Exclude else-case from coverage, because it can only occur with Native Bindings.\r\n            // istanbul ignore else\r\n            if (client.serverVersion) {\r\n                npm.utils.addReadProp(target, 'serverVersion', client.serverVersion);\r\n            }\r\n        }\r\n\r\n        // extending the protocol;\r\n        Events.extend(ctx.options, obj, ctx.dc);\r\n    }\r\n\r\n}\r\n\r\n// this event only happens when the connection is lost physically,\r\n// which cannot be tested automatically; removing from coverage:\r\n// istanbul ignore next\r\nfunction onError(err) {\r\n    // this client was never seen by pg-promise, which\r\n    // can happen if it failed to initialize\r\n    if (!err.client.$ctx) {\r\n        return;\r\n    }\r\n    const ctx = err.client.$ctx;\r\n    Events.error(ctx.options, err, {\r\n        cn: npm.utils.getSafeConnection(ctx.cn),\r\n        dc: ctx.dc\r\n    });\r\n}\r\n\r\nmodule.exports = config => {\r\n    const npmLocal = config.$npm;\r\n    npmLocal.connect = npmLocal.connect || npm.connect(config);\r\n    npmLocal.query = npmLocal.query || npm.query(config);\r\n    npmLocal.task = npmLocal.task || npm.task(config);\r\n    return Database;\r\n};\r\n\r\n/**\r\n * @callback Database.streamInitCB\r\n * @description\r\n * Stream initialization callback, used by {@link Database#stream Database.stream}.\r\n *\r\n * @param {external:Stream} stream\r\n * Stream object to initialize streaming.\r\n *\r\n * @example\r\n * const QueryStream = require('pg-query-stream');\r\n * const JSONStream = require('JSONStream');\r\n *\r\n * // you can also use pgp.as.format(query, values, options)\r\n * // to format queries properly, via pg-promise;\r\n * const qs = new QueryStream('SELECT * FROM users');\r\n *\r\n * db.stream(qs, stream => {\r\n *         // initiate streaming into the console:\r\n *         stream.pipe(JSONStream.stringify()).pipe(process.stdout);\r\n *     })\r\n *     .then(data => {\r\n *         console.log('Total rows processed:', data.processed,\r\n *           'Duration in milliseconds:', data.duration);\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n */\r\n\r\n/**\r\n * @external Stream\r\n * @see https://nodejs.org/api/stream.html\r\n */\r\n\r\n/**\r\n * @external pg-pool\r\n * @alias pg-pool\r\n * @see https://github.com/brianc/node-pg-pool\r\n */\r\n\r\n/**\r\n * @external Result\r\n * @see https://node-postgres.com/api/result\r\n */\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM;EAACA;AAAM,CAAC,GAAGC,OAAO,CAAC,UAAU,CAAC;AACpC,MAAM;EAACC;AAAM,CAAC,GAAGD,OAAO,CAAC,UAAU,CAAC;AACpC,MAAM;EAACE,WAAW;EAAEC,gBAAgB;EAAEC;AAAW,CAAC,GAAGJ,OAAO,CAAC,iBAAiB,CAAC;AAC/E,MAAM;EAACK;AAAiB,CAAC,GAAGL,OAAO,CAAC,WAAW,CAAC;AAChD,MAAM;EAACM;AAAY,CAAC,GAAGN,OAAO,CAAC,iBAAiB,CAAC;AACjD,MAAM;EAACO;AAAW,CAAC,GAAGP,OAAO,CAAC,gBAAgB,CAAC;AAE/C,MAAMQ,GAAG,GAAG;EACRC,KAAK,EAAET,OAAO,CAAC,SAAS,CAAC;EACzBU,QAAQ,EAAEV,OAAO,CAAC,gBAAgB,CAAC;EACnCW,OAAO,EAAEX,OAAO,CAAC,WAAW,CAAC;EAC7BY,KAAK,EAAEZ,OAAO,CAAC,SAAS,CAAC;EACzBa,IAAI,EAAEb,OAAO,CAAC,QAAQ,CAAC;EACvBc,IAAI,EAAEd,OAAO,CAAC,QAAQ;AAC1B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASe,QAAQA,CAACC,EAAE,EAAEC,EAAE,EAAEC,MAAM,EAAE;EAE9B,MAAMC,MAAM,GAAG,IAAI;IACfC,EAAE,GAAGF,MAAM,CAACG,OAAO;IACnBC,cAAc,GAAG,OAAON,EAAE,KAAK,QAAQ,GAAG;MAACO,gBAAgB,EAAEP;IAAE,CAAC,GAAGA,EAAE;IACrEQ,IAAI,GAAG,IAAIN,MAAM,CAACO,GAAG,CAACC,EAAE,CAACC,IAAI,CAACL,cAAc,CAAC;IAC7CM,SAAS,GAAGJ,IAAI,CAACK,GAAG;EAExB,IAAIC,SAAS;EAEbN,IAAI,CAACK,GAAG,GAAGE,EAAE,IAAI;IACb,MAAMC,GAAG,GAAGJ,SAAS,CAACK,IAAI,CAACT,IAAI,EAAEO,EAAE,CAAC;IACpCZ,MAAM,CAACe,QAAQ,CAAC,CAAC;IACjB,OAAOF,GAAG;EACd,CAAC;EAEDR,IAAI,CAACW,EAAE,CAAC,OAAO,EAAEC,OAAO,CAAC;;EAEzB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACzB,OAAO,GAAG,UAAU0B,OAAO,EAAE;IAC9BA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;IACvB,MAAMC,GAAG,GAAGC,aAAa,CAAC,CAAC;IAC3BD,GAAG,CAACE,SAAS,GAAGH,OAAO;IACvB,MAAMI,IAAI,GAAG;MACT7B,KAAKA,CAACA,KAAK,EAAE8B,MAAM,EAAEC,GAAG,EAAE;QACtB,IAAI,CAACL,GAAG,CAACM,EAAE,EAAE;UACT,OAAOxB,EAAE,CAACyB,MAAM,CAAC,IAAIC,KAAK,CAACtC,GAAG,CAACM,IAAI,CAACiC,iBAAiB,CAAC,CAAC;QAC3D;QACA,OAAO7B,MAAM,CAAC8B,IAAI,CAACpC,KAAK,CAACqB,IAAI,CAAC,IAAI,EAAEK,GAAG,EAAE1B,KAAK,EAAE8B,MAAM,EAAEC,GAAG,CAAC;MAChE,CAAC;MACDM,IAAIA,CAACC,IAAI,EAAE;QACP,IAAI,CAACZ,GAAG,CAACM,EAAE,EAAE;UACT,MAAM,IAAIE,KAAK,CAACtC,GAAG,CAACM,IAAI,CAACqC,UAAU,CAAC;QACxC;QACA,OAAOb,GAAG,CAACc,UAAU,CAACF,IAAI,CAAC;MAC/B,CAAC;MACDG,KAAKA,CAACX,MAAM,EAAEY,GAAG,EAAE;QACf,OAAOpC,MAAM,CAAC8B,IAAI,CAACO,IAAI,CAACF,KAAK,CAACpB,IAAI,CAAC,IAAI,EAAES,MAAM,EAAEY,GAAG,CAAC;MACzD,CAAC;MACDE,IAAIA,CAACC,MAAM,EAAEH,GAAG,EAAE;QACd,OAAOpC,MAAM,CAAC8B,IAAI,CAACO,IAAI,CAACC,IAAI,CAACvB,IAAI,CAAC,IAAI,EAAEwB,MAAM,EAAEH,GAAG,CAAC;MACxD,CAAC;MACDI,QAAQA,CAACD,MAAM,EAAEH,GAAG,EAAE;QAClB,OAAOpC,MAAM,CAAC8B,IAAI,CAACO,IAAI,CAACG,QAAQ,CAACzB,IAAI,CAAC,IAAI,EAAEwB,MAAM,EAAEH,GAAG,CAAC;MAC5D;IACJ,CAAC;IACD,MAAMK,UAAU,GAAGtB,OAAO,CAACuB,MAAM,GAAG1C,MAAM,CAAC8B,IAAI,CAACrC,OAAO,CAACiD,MAAM,CAACtB,GAAG,CAAC,GAAGpB,MAAM,CAAC8B,IAAI,CAACrC,OAAO,CAACa,IAAI,CAACc,GAAG,EAAEnB,MAAM,CAAC;IAC3G,OAAOwC,UAAU,CACZE,IAAI,CAACjB,EAAE,IAAI;MACRN,GAAG,CAAC3B,OAAO,CAACiC,EAAE,CAAC;MACfH,IAAI,CAACqB,MAAM,GAAGlB,EAAE,CAACkB,MAAM;MACvBC,MAAM,CAACzB,GAAG,EAAEG,IAAI,CAAC;MACjB,OAAOA,IAAI;IACf,CAAC,CAAC;EACV,CAAC;;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAC7B,KAAK,GAAG,UAAUA,KAAK,EAAE8B,MAAM,EAAEC,GAAG,EAAE;IACvC,MAAMF,IAAI,GAAG,IAAI;MAAEH,GAAG,GAAGC,aAAa,CAAC,CAAC;IACxC,OAAOrB,MAAM,CAAC8B,IAAI,CAACrC,OAAO,CAACa,IAAI,CAACc,GAAG,EAAEnB,MAAM,CAAC,CACvC0C,IAAI,CAACjB,EAAE,IAAI;MACRN,GAAG,CAAC3B,OAAO,CAACiC,EAAE,CAAC;MACf,OAAO1B,MAAM,CAAC8B,IAAI,CAACpC,KAAK,CAACqB,IAAI,CAACQ,IAAI,EAAEH,GAAG,EAAE1B,KAAK,EAAE8B,MAAM,EAAEC,GAAG,CAAC;IAChE,CAAC,CAAC,CACDkB,IAAI,CAACG,IAAI,IAAI;MACV1B,GAAG,CAACc,UAAU,CAAC,CAAC;MAChB,OAAOY,IAAI;IACf,CAAC,CAAC,CACDC,KAAK,CAACC,KAAK,IAAI;MACZ5B,GAAG,CAACc,UAAU,CAAC,CAAC;MAChB,OAAOhC,EAAE,CAACyB,MAAM,CAACqB,KAAK,CAAC;IAC3B,CAAC,CAAC;EACV,CAAC;;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI1D,GAAG,CAACC,KAAK,CAAC0D,WAAW,CAAC,IAAI,EAAE,SAAS,EAAEjD,MAAM,EAAE,IAAI,CAAC;;EAEpD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIV,GAAG,CAACC,KAAK,CAAC0D,WAAW,CAAC,IAAI,EAAE,KAAK,EAAEnD,EAAE,EAAE,IAAI,CAAC;;EAE5C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIR,GAAG,CAACC,KAAK,CAAC0D,WAAW,CAAC,IAAI,EAAE,KAAK,EAAElD,EAAE,EAAE,IAAI,CAAC;;EAE5C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIT,GAAG,CAACC,KAAK,CAAC0D,WAAW,CAAC,IAAI,EAAE,OAAO,EAAE3C,IAAI,EAAE,IAAI,CAAC;;EAEhD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIhB,GAAG,CAACC,KAAK,CAAC0D,WAAW,CAAC,IAAI,EAAE,UAAU,EAAE,MAAM;IAC1C,IAAI,CAACrC,SAAS,EAAE;MACZ,IAAI,CAACN,IAAI,CAAC4C,MAAM,EAAE;QACdxC,SAAS,CAACK,IAAI,CAACT,IAAI,CAAC;MACxB;MACAlB,YAAY,CAAC+D,UAAU,CAAClD,MAAM,CAAC;MAC/BK,IAAI,CAAC8C,cAAc,CAAC,OAAO,EAAElC,OAAO,CAAC;MACrCN,SAAS,GAAG,IAAI;IACpB;EACJ,CAAC,EAAE,IAAI,CAAC;EAERxB,YAAY,CAACiE,QAAQ,CAAC,IAAI,CAAC;EAE3BR,MAAM,CAACxB,aAAa,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;;EAE/B,SAASA,aAAaA,CAAA,EAAG;IACrB,OAAO,IAAIlC,iBAAiB,CAAC;MAACW,EAAE;MAAEC,EAAE;MAAEoB,OAAO,EAAEnB,MAAM,CAACmB;IAAO,CAAC,CAAC;EACnE;;EAEA;EACA,SAASmC,SAASA,CAACC,KAAK,EAAE1C,EAAE,EAAE2C,OAAO,EAAE;IACnC,OAAO,OAAO3C,EAAE,KAAK,UAAU,GAAG0C,KAAK,CAACZ,IAAI,CAACG,IAAI,IAAIjC,EAAE,CAACE,IAAI,CAACyC,OAAO,EAAEV,IAAI,CAAC,CAAC,GAAGS,KAAK;EACxF;;EAEA;EACA;EACA;EACA,SAASV,MAAMA,CAACzB,GAAG,EAAEqC,GAAG,EAAE;IAEtB;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQA,GAAG,CAACC,IAAI,GAAG,UAAUhE,KAAK,EAAE8B,MAAM,EAAE;MAChC,OAAOiC,GAAG,CAAC/D,KAAK,CAACqB,IAAI,CAAC,IAAI,EAAErB,KAAK,EAAE8B,MAAM,EAAEnC,WAAW,CAACqE,IAAI,CAAC;IAChE,CAAC;;IAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQD,GAAG,CAACE,GAAG,GAAG,UAAUjE,KAAK,EAAE8B,MAAM,EAAEX,EAAE,EAAE2C,OAAO,EAAE;MAC5C,MAAMI,CAAC,GAAGH,GAAG,CAAC/D,KAAK,CAACqB,IAAI,CAAC,IAAI,EAAErB,KAAK,EAAE8B,MAAM,EAAEnC,WAAW,CAACsE,GAAG,CAAC;MAC9D,OAAOL,SAAS,CAACM,CAAC,EAAE/C,EAAE,EAAE2C,OAAO,CAAC;IACpC,CAAC;;IAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQC,GAAG,CAACI,IAAI,GAAG,UAAUnE,KAAK,EAAE8B,MAAM,EAAE;MAChC,OAAOiC,GAAG,CAAC/D,KAAK,CAACqB,IAAI,CAAC,IAAI,EAAErB,KAAK,EAAE8B,MAAM,EAAEnC,WAAW,CAACwE,IAAI,CAAC;IAChE,CAAC;;IAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQJ,GAAG,CAACK,SAAS,GAAG,UAAUpE,KAAK,EAAE8B,MAAM,EAAEX,EAAE,EAAE2C,OAAO,EAAE;MAClD,MAAMI,CAAC,GAAGH,GAAG,CAAC/D,KAAK,CAACqB,IAAI,CAAC,IAAI,EAAErB,KAAK,EAAE8B,MAAM,EAAEnC,WAAW,CAACsE,GAAG,GAAGtE,WAAW,CAACqE,IAAI,CAAC;MACjF,OAAOJ,SAAS,CAACM,CAAC,EAAE/C,EAAE,EAAE2C,OAAO,CAAC;IACpC,CAAC;;IAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQC,GAAG,CAACM,UAAU,GAAG,UAAUrE,KAAK,EAAE8B,MAAM,EAAE;MACtC,OAAOiC,GAAG,CAAC/D,KAAK,CAACqB,IAAI,CAAC,IAAI,EAAErB,KAAK,EAAE8B,MAAM,EAAEnC,WAAW,CAACwE,IAAI,GAAGxE,WAAW,CAACqE,IAAI,CAAC;IACnF,CAAC;;IAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQD,GAAG,CAACO,GAAG,GAAG,UAAUtE,KAAK,EAAE8B,MAAM,EAAE;MAC/B,OAAOiC,GAAG,CAAC/D,KAAK,CAACqB,IAAI,CAAC,IAAI,EAAErB,KAAK,EAAE8B,MAAM,EAAEnC,WAAW,CAAC2E,GAAG,CAAC;IAC/D,CAAC;;IAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQP,GAAG,CAACQ,MAAM,GAAG,UAAUvE,KAAK,EAAE8B,MAAM,EAAEX,EAAE,EAAE2C,OAAO,EAAE;MAC/C,MAAMI,CAAC,GAAGH,GAAG,CAAC/D,KAAK,CAACqB,IAAI,CAAC,IAAI,EAAErB,KAAK,EAAE8B,MAAM,EAAExC,WAAW,CAAC;MAC1D,OAAOsE,SAAS,CAACM,CAAC,EAAE/C,EAAE,EAAE2C,OAAO,CAAC;IACpC,CAAC;;IAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQC,GAAG,CAACS,WAAW,GAAG,UAAUxE,KAAK,EAAE8B,MAAM,EAAE;MACvC,OAAOiC,GAAG,CAAC/D,KAAK,CAACqB,IAAI,CAAC,IAAI,EAAErB,KAAK,EAAE8B,MAAM,EAAEvC,gBAAgB,CAAC;IAChE,CAAC;;IAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQwE,GAAG,CAACU,KAAK,GAAG,UAAUzE,KAAK,EAAE8B,MAAM,EAAE;MACjC,OAAOiC,GAAG,CAAC/D,KAAK,CAACqB,IAAI,CAAC,IAAI,EAAErB,KAAK,EAAE8B,MAAM,EAAEvC,gBAAgB,CAAC,CACvD0D,IAAI,CAACG,IAAI,IAAIA,IAAI,CAACsB,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACC,IAAI,CAAC,CAAC;IAC5C,CAAC;;IAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQb,GAAG,CAACc,MAAM,GAAG,UAAUC,EAAE,EAAEC,IAAI,EAAE;MAC7B,OAAOhB,GAAG,CAAC/D,KAAK,CAACqB,IAAI,CAAC,IAAI,EAAEyD,EAAE,EAAEC,IAAI,EAAEvF,WAAW,CAAC;IACtD,CAAC;;IAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQuE,GAAG,CAACiB,IAAI,GAAG,UAAUC,QAAQ,EAAEnD,MAAM,EAAEC,GAAG,EAAE;MACxC,OAAOgC,GAAG,CAAC/D,KAAK,CAACqB,IAAI,CAAC,IAAI,EAAE;QAAC6D,MAAM,EAAED,QAAQ;QAAEE,IAAI,EAAE;MAAM,CAAC,EAAErD,MAAM,EAAEC,GAAG,CAAC;IAC9E,CAAC;;IAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQgC,GAAG,CAACqB,IAAI,GAAG,UAAUC,QAAQ,EAAEvD,MAAM,EAAEX,EAAE,EAAE2C,OAAO,EAAE;MAChD,MAAMI,CAAC,GAAGH,GAAG,CAAC/D,KAAK,CAACqB,IAAI,CAAC,IAAI,EAAE;QAC3B6D,MAAM,EAAEG,QAAQ;QAChBF,IAAI,EAAE;MACV,CAAC,EAAErD,MAAM,EAAEnC,WAAW,CAACsE,GAAG,GAAGtE,WAAW,CAACqE,IAAI,CAAC;MAC9C,OAAOJ,SAAS,CAACM,CAAC,EAAE/C,EAAE,EAAE2C,OAAO,CAAC;IACpC,CAAC;;IAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQC,GAAG,CAACW,GAAG,GAAG,UAAU1E,KAAK,EAAE8B,MAAM,EAAEX,EAAE,EAAE2C,OAAO,EAAE;MAC5C,OAAOC,GAAG,CAACO,GAAG,CAACjD,IAAI,CAAC,IAAI,EAAErB,KAAK,EAAE8B,MAAM,CAAC,CACnCmB,IAAI,CAACG,IAAI,IAAIA,IAAI,CAACsB,GAAG,CAACvD,EAAE,EAAE2C,OAAO,CAAC,CAAC;IAC5C,CAAC;;IAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQC,GAAG,CAACuB,IAAI,GAAG,UAAUtF,KAAK,EAAE8B,MAAM,EAAEX,EAAE,EAAE2C,OAAO,EAAE;MAC7C,OAAOC,GAAG,CAACO,GAAG,CAACjD,IAAI,CAAC,IAAI,EAAErB,KAAK,EAAE8B,MAAM,CAAC,CACnCmB,IAAI,CAACG,IAAI,IAAI;QACVA,IAAI,CAACmC,OAAO,CAACpE,EAAE,EAAE2C,OAAO,CAAC;QACzB,OAAOV,IAAI;MACf,CAAC,CAAC;IACV,CAAC;;IAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQW,GAAG,CAAC9D,IAAI,GAAG,YAAY;MACnB,MAAMuF,IAAI,GAAG5F,GAAG,CAACE,QAAQ,CAAC2F,QAAQ,CAACC,SAAS,CAAC;MAC7CrG,MAAM,CAACmG,IAAI,CAAC/D,OAAO,EAAE,CAAC,KAAK,CAAC,CAAC;MAC7B,OAAOkE,aAAa,CAACtE,IAAI,CAAC,IAAI,EAAEmE,IAAI,EAAE,KAAK,CAAC;IAChD,CAAC;;IAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQzB,GAAG,CAAC6B,MAAM,GAAG,YAAY;MACrB,MAAMJ,IAAI,GAAG5F,GAAG,CAACE,QAAQ,CAAC2F,QAAQ,CAACC,SAAS,CAAC;MAC7CrG,MAAM,CAACmG,IAAI,CAAC/D,OAAO,EAAE,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;MACpC,IAAI;QACA,IAAIoE,GAAG,GAAGL,IAAI,CAAC/D,OAAO,CAACoE,GAAG;QAC1B,IAAI,KAAK,IAAIL,IAAI,CAAC/D,OAAO,EAAE;UACvBoE,GAAG,GAAG,OAAOA,GAAG,KAAK,UAAU,GAAGA,GAAG,CAACxE,IAAI,CAAC0C,GAAG,EAAEA,GAAG,CAAC,GAAG,CAAC,CAAC8B,GAAG;QAChE,CAAC,MAAM;UACHA,GAAG,GAAG,CAAC9B,GAAG,CAACrC,GAAG,CAAC,CAAC;QACpB;QACA;QACA8D,IAAI,CAAC/D,OAAO,CAACqE,QAAQ,GAAG,CAACD,GAAG,IAAI,CAAC,CAAC9B,GAAG,CAACrC,GAAG;MAC7C,CAAC,CAAC,OAAOqE,CAAC,EAAE;QACR,OAAOvF,EAAE,CAACyB,MAAM,CAAC8D,CAAC,CAAC;MACvB;MACA,OAAOJ,aAAa,CAACtE,IAAI,CAAC,IAAI,EAAEmE,IAAI,EAAE,KAAK,CAAC;IAChD,CAAC;;IAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQzB,GAAG,CAACiC,EAAE,GAAG,YAAY;MACjB,MAAMR,IAAI,GAAG5F,GAAG,CAACE,QAAQ,CAAC2F,QAAQ,CAACC,SAAS,CAAC;MAC7CrG,MAAM,CAACmG,IAAI,CAAC/D,OAAO,EAAE,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;MACrC,OAAOkE,aAAa,CAACtE,IAAI,CAAC,IAAI,EAAEmE,IAAI,EAAE,IAAI,CAAC;IAC/C,CAAC;;IAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQzB,GAAG,CAACkC,IAAI,GAAG,YAAY;MACnB,MAAMT,IAAI,GAAG5F,GAAG,CAACE,QAAQ,CAAC2F,QAAQ,CAACC,SAAS,CAAC;MAC7CrG,MAAM,CAACmG,IAAI,CAAC/D,OAAO,EAAE,CAAC,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC;MACxD,IAAI;QACA,IAAIoE,GAAG;QACP,IAAI,KAAK,IAAIL,IAAI,CAAC/D,OAAO,EAAE;UACvBoE,GAAG,GAAGL,IAAI,CAAC/D,OAAO,CAACoE,GAAG;UACtBA,GAAG,GAAG,OAAOA,GAAG,KAAK,UAAU,GAAGA,GAAG,CAACxE,IAAI,CAAC0C,GAAG,EAAEA,GAAG,CAAC,GAAG,CAAC,CAAC8B,GAAG;QAChE,CAAC,MAAM;UACHA,GAAG,GAAG,CAAC9B,GAAG,CAACrC,GAAG,IAAI,CAACqC,GAAG,CAACrC,GAAG,CAACwE,aAAa;QAC5C;QACAV,IAAI,CAAC/D,OAAO,CAACoE,GAAG,GAAGA,GAAG;QACtB,MAAMC,QAAQ,GAAGN,IAAI,CAAC/D,OAAO,CAACqE,QAAQ;QACtCN,IAAI,CAAC/D,OAAO,CAACqE,QAAQ,GAAG,CAACD,GAAG,IAAI9B,GAAG,CAACrC,GAAG,IAAI,OAAOoE,QAAQ,KAAK,UAAU,GAAGA,QAAQ,CAACzE,IAAI,CAAC0C,GAAG,EAAEA,GAAG,CAAC,GAAG,CAAC,CAAC+B,QAAQ;MACpH,CAAC,CAAC,OAAOC,CAAC,EAAE;QACR,OAAOvF,EAAE,CAACyB,MAAM,CAAC8D,CAAC,CAAC;MACvB;MACA,OAAOJ,aAAa,CAACtE,IAAI,CAAC,IAAI,EAAEmE,IAAI,EAAEA,IAAI,CAAC/D,OAAO,CAACoE,GAAG,CAAC;IAC3D,CAAC;;IAED;IACA;IACA,SAASF,aAAaA,CAACQ,MAAM,EAAEC,IAAI,EAAE;MAEjC,IAAI,OAAOD,MAAM,CAAChF,EAAE,KAAK,UAAU,EAAE;QACjC,OAAOX,EAAE,CAACyB,MAAM,CAAC,IAAIoE,SAAS,CAAC,gCAAgC,CAAC,CAAC;MACrE;MAEA,IAAIF,MAAM,CAAC1E,OAAO,CAACqE,QAAQ,EAAE;QACzB,OAAOxF,MAAM,CAAC8B,IAAI,CAACnC,IAAI,CAACqG,QAAQ,CAACvC,GAAG,CAACrC,GAAG,EAAEqC,GAAG,EAAEoC,MAAM,CAAChF,EAAE,EAAEb,MAAM,CAAC;MACrE;MAEA,MAAMiG,OAAO,GAAG7E,GAAG,CAAC8E,KAAK,CAAC,CAAC,CAAC,CAAC;MAC7B,IAAIJ,IAAI,EAAE;QACNG,OAAO,CAACE,OAAO,GAAGF,OAAO,CAACE,OAAO,IAAI,CAAC,GAAIF,OAAO,CAACE,OAAO,GAAG,CAAC,GAAI,CAAC;MACtE;MACAF,OAAO,CAACL,aAAa,GAAGK,OAAO,CAACE,OAAO,IAAI,CAAC;MAC5CF,OAAO,CAACG,KAAK,GAAGH,OAAO,CAACG,KAAK,IAAI,CAAC,GAAIH,OAAO,CAACG,KAAK,GAAG,CAAC,GAAI,CAAC;MAC5DH,OAAO,CAACpF,EAAE,GAAGgF,MAAM,CAAChF,EAAE,CAAC,CAAC;MACxBoF,OAAO,CAACI,IAAI,GAAGR,MAAM,CAAC1E,OAAO,CAACkF,IAAI,CAAC,CAAC;MACpC,IAAI,IAAI,KAAK5C,GAAG,EAAE;QACdwC,OAAO,CAACK,OAAO,GAAG,IAAI,CAAC,CAAC;MAC5B;;MAEA,MAAMC,GAAG,GAAG,IAAIvG,MAAM,CAAC8B,IAAI,CAACnC,IAAI,CAAC6G,IAAI,CAACP,OAAO,EAAEJ,MAAM,CAAC1E,OAAO,CAACsF,GAAG,EAAEX,IAAI,EAAE9F,MAAM,CAAC;MAChFiG,OAAO,CAACA,OAAO,GAAGM,GAAG,CAACnF,GAAG;MACzByB,MAAM,CAACoD,OAAO,EAAEM,GAAG,CAAC;MAEpB,IAAIN,OAAO,CAACvE,EAAE,EAAE;QACZ;QACApC,GAAG,CAACC,KAAK,CAAC0D,WAAW,CAACsD,GAAG,CAACnF,GAAG,EAAE,UAAU,EAAE6E,OAAO,CAACvE,EAAE,CAACgF,QAAQ,CAAC;QAC/DC,gBAAgB,CAACJ,GAAG,CAACnF,GAAG,EAAE6E,OAAO,CAACvE,EAAE,CAACkB,MAAM,CAAC;QAC5C,OAAO5C,MAAM,CAAC8B,IAAI,CAACnC,IAAI,CAACiH,OAAO,CAACX,OAAO,EAAEM,GAAG,EAAET,IAAI,EAAE9F,MAAM,CAAC;MAC/D;;MAEA;MACA,OAAOA,MAAM,CAAC8B,IAAI,CAACrC,OAAO,CAACa,IAAI,CAAC2F,OAAO,EAAEhG,MAAM,CAAC,CAC3C0C,IAAI,CAACjB,EAAE,IAAI;QACRuE,OAAO,CAACxG,OAAO,CAACiC,EAAE,CAAC;QACnBpC,GAAG,CAACC,KAAK,CAAC0D,WAAW,CAACsD,GAAG,CAACnF,GAAG,EAAE,UAAU,EAAEM,EAAE,CAACgF,QAAQ,CAAC;QACvDC,gBAAgB,CAACJ,GAAG,CAACnF,GAAG,EAAEM,EAAE,CAACkB,MAAM,CAAC;QACpC,OAAO5C,MAAM,CAAC8B,IAAI,CAACnC,IAAI,CAACiH,OAAO,CAACX,OAAO,EAAEM,GAAG,EAAET,IAAI,EAAE9F,MAAM,CAAC;MAC/D,CAAC,CAAC,CACD2C,IAAI,CAACG,IAAI,IAAI;QACVmD,OAAO,CAAC/D,UAAU,CAAC,CAAC;QACpB,OAAOY,IAAI;MACf,CAAC,CAAC,CACDC,KAAK,CAACC,KAAK,IAAI;QACZiD,OAAO,CAAC/D,UAAU,CAAC,CAAC;QACpB,OAAOhC,EAAE,CAACyB,MAAM,CAACqB,KAAK,CAAC;MAC3B,CAAC,CAAC;IACV;IAEA,SAAS2D,gBAAgBA,CAACE,MAAM,EAAEjE,MAAM,EAAE;MACtC;MACA;MACA,IAAIA,MAAM,CAACkE,aAAa,EAAE;QACtBxH,GAAG,CAACC,KAAK,CAAC0D,WAAW,CAAC4D,MAAM,EAAE,eAAe,EAAEjE,MAAM,CAACkE,aAAa,CAAC;MACxE;IACJ;;IAEA;IACAjI,MAAM,CAACgE,MAAM,CAACzB,GAAG,CAACD,OAAO,EAAEsC,GAAG,EAAErC,GAAG,CAACrB,EAAE,CAAC;EAC3C;AAEJ;;AAEA;AACA;AACA;AACA,SAASmB,OAAOA,CAAC6F,GAAG,EAAE;EAClB;EACA;EACA,IAAI,CAACA,GAAG,CAACnE,MAAM,CAACoE,IAAI,EAAE;IAClB;EACJ;EACA,MAAM5F,GAAG,GAAG2F,GAAG,CAACnE,MAAM,CAACoE,IAAI;EAC3BnI,MAAM,CAACmE,KAAK,CAAC5B,GAAG,CAACD,OAAO,EAAE4F,GAAG,EAAE;IAC3BjH,EAAE,EAAER,GAAG,CAACC,KAAK,CAAC0H,iBAAiB,CAAC7F,GAAG,CAACtB,EAAE,CAAC;IACvCC,EAAE,EAAEqB,GAAG,CAACrB;EACZ,CAAC,CAAC;AACN;AAEAmH,MAAM,CAACC,OAAO,GAAGnH,MAAM,IAAI;EACvB,MAAMoH,QAAQ,GAAGpH,MAAM,CAAC8B,IAAI;EAC5BsF,QAAQ,CAAC3H,OAAO,GAAG2H,QAAQ,CAAC3H,OAAO,IAAIH,GAAG,CAACG,OAAO,CAACO,MAAM,CAAC;EAC1DoH,QAAQ,CAAC1H,KAAK,GAAG0H,QAAQ,CAAC1H,KAAK,IAAIJ,GAAG,CAACI,KAAK,CAACM,MAAM,CAAC;EACpDoH,QAAQ,CAACzH,IAAI,GAAGyH,QAAQ,CAACzH,IAAI,IAAIL,GAAG,CAACK,IAAI,CAACK,MAAM,CAAC;EACjD,OAAOH,QAAQ;AACnB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA"},"metadata":{},"sourceType":"script","externalDependencies":[]}