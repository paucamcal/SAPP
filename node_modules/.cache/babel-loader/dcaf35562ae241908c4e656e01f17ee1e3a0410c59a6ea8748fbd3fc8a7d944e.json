{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\n\nconst {\n  InnerState\n} = require('../inner-state');\nconst {\n  assert\n} = require('../assert');\nconst {\n  TableName\n} = require('./table-name');\nconst {\n  Column\n} = require('./column');\nconst npm = {\n  os: require('os'),\n  utils: require('../utils'),\n  formatting: require('../formatting')\n};\n\n/**\r\n * @class helpers.ColumnSet\r\n * @description\r\n * Performance-optimized, read-only structure with query-formatting columns.\r\n *\r\n * In order to avail from performance optimization provided by this class, it should be created\r\n * only once, statically, and then reused.\r\n *\r\n * @param {object|helpers.Column|array} columns\r\n * Columns information object, depending on the type:\r\n *\r\n * - When it is a simple object, its properties are enumerated to represent both column names and property names\r\n *   within the source objects. See also option `inherit` that's applicable in this case.\r\n *\r\n * - When it is a single {@link helpers.Column Column} object, property {@link helpers.ColumnSet#columns columns} is initialized with\r\n *   just a single column. It is not a unique situation when only a single column is required for an update operation.\r\n *\r\n * - When it is an array, each element is assumed to represent details for a column. If the element is already of type {@link helpers.Column Column},\r\n *   it is used directly; otherwise the element is passed into {@link helpers.Column Column} constructor for initialization.\r\n *   On any duplicate column name (case-sensitive) it will throw {@link external:Error Error} = `Duplicate column name \"name\".`\r\n *\r\n * - When it is none of the above, it will throw {@link external:TypeError TypeError} = `Invalid parameter 'columns' specified.`\r\n *\r\n * @param {object} [options]\r\n *\r\n * @param {helpers.TableName|string|{table,schema}} [options.table]\r\n * Table details.\r\n *\r\n * When it is a non-null value, and not a {@link helpers.TableName TableName} object, a new {@link helpers.TableName TableName} is constructed from the value.\r\n *\r\n * It can be used as the default for methods {@link helpers.insert insert} and {@link helpers.update update} when their parameter\r\n * `table` is omitted, and for logging purposes.\r\n *\r\n * @param {boolean} [options.inherit = false]\r\n * Use inherited properties in addition to the object's own properties.\r\n *\r\n * By default, only the object's own properties are enumerated for column names.\r\n *\r\n * @returns {helpers.ColumnSet}\r\n *\r\n * @see\r\n *\r\n * {@link helpers.ColumnSet#columns columns},\r\n * {@link helpers.ColumnSet#names names},\r\n * {@link helpers.ColumnSet#table table},\r\n * {@link helpers.ColumnSet#variables variables} |\r\n * {@link helpers.ColumnSet#assign assign},\r\n * {@link helpers.ColumnSet#assignColumns assignColumns},\r\n * {@link helpers.ColumnSet#extend extend},\r\n * {@link helpers.ColumnSet#merge merge},\r\n * {@link helpers.ColumnSet#prepare prepare}\r\n *\r\n * @example\r\n *\r\n * // A complex insert/update object scenario for table 'purchases' in schema 'fiscal'.\r\n * // For a good performance, you should declare such objects once and then reuse them.\r\n * //\r\n * // Column Requirements:\r\n * //\r\n * // 1. Property 'id' is only to be used for a WHERE condition in updates\r\n * // 2. Property 'list' needs to be formatted as a csv\r\n * // 3. Property 'code' is to be used as raw text, and to be defaulted to 0 when the\r\n * //    property is missing in the source object\r\n * // 4. Property 'log' is a JSON object with 'log-entry' for the column name\r\n * // 5. Property 'data' requires SQL type casting '::int[]'\r\n * // 6. Property 'amount' needs to be set to 100, if it is 0\r\n * // 7. Property 'total' must be skipped during updates, if 'amount' was 0, plus its\r\n * //    column name is 'total-val'\r\n *\r\n * const cs = new pgp.helpers.ColumnSet([\r\n *     '?id', // ColumnConfig equivalent: {name: 'id', cnd: true}\r\n *     'list:csv', // ColumnConfig equivalent: {name: 'list', mod: ':csv'}\r\n *     {\r\n *         name: 'code',\r\n *         mod: '^', // format as raw text\r\n *         def: 0 // default to 0 when the property doesn't exist\r\n *     },\r\n *     {\r\n *         name: 'log-entry',\r\n *         prop: 'log',\r\n *         mod: ':json' // format as JSON\r\n *     },\r\n *     {\r\n *         name: 'data',\r\n *         cast: 'int[]' // use SQL type casting '::int[]'\r\n *     },\r\n *     {\r\n *         name: 'amount',\r\n *         init(col) {\r\n *             // set to 100, if the value is 0:\r\n *             return col.value === 0 ? 100 : col.value;\r\n *         }\r\n *     },\r\n *     {\r\n *         name: 'total-val',\r\n *         prop: 'total',\r\n *         skip(col) {\r\n *             // skip from updates, if 'amount' is 0:\r\n *             return col.source.amount === 0;\r\n *         }\r\n *     }\r\n * ], {table: {table: 'purchases', schema: 'fiscal'}});\r\n *\r\n * // Alternatively, you could take the table declaration out:\r\n * // const table = new pgp.helpers.TableName('purchases', 'fiscal');\r\n *\r\n * console.log(cs); // console output for the object:\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"fiscal\".\"purchases\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"id\"\r\n * //            cnd: true\r\n * //        }\r\n * //        Column {\r\n * //            name: \"list\"\r\n * //            mod: \":csv\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"code\"\r\n * //            mod: \"^\"\r\n * //            def: 0\r\n * //        }\r\n * //        Column {\r\n * //            name: \"log-entry\"\r\n * //            prop: \"log\"\r\n * //            mod: \":json\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"data\"\r\n * //            cast: \"int[]\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"amount\"\r\n * //            init: [Function]\r\n * //        }\r\n * //        Column {\r\n * //            name: \"total-val\"\r\n * //            prop: \"total\"\r\n * //            skip: [Function]\r\n * //        }\r\n * //    ]\r\n * // }\r\n */\nclass ColumnSet extends InnerState {\n  constructor(columns, opt) {\n    super();\n    if (!columns || typeof columns !== 'object') {\n      throw new TypeError('Invalid parameter \\'columns\\' specified.');\n    }\n    opt = assert(opt, ['table', 'inherit']);\n    if (!npm.utils.isNull(opt.table)) {\n      this.table = opt.table instanceof TableName ? opt.table : new TableName(opt.table);\n    }\n\n    /**\r\n     * @name helpers.ColumnSet#table\r\n     * @type {helpers.TableName}\r\n     * @readonly\r\n     * @description\r\n     * Destination table. It can be specified for two purposes:\r\n     *\r\n     * - **primary:** to be used as the default table when it is omitted during a call into methods {@link helpers.insert insert} and {@link helpers.update update}\r\n     * - **secondary:** to be automatically written into the console (for logging purposes).\r\n     */\n\n    /**\r\n     * @name helpers.ColumnSet#columns\r\n     * @type helpers.Column[]\r\n     * @readonly\r\n     * @description\r\n     * Array of {@link helpers.Column Column} objects.\r\n     */\n    if (Array.isArray(columns)) {\n      const colNames = {};\n      this.columns = columns.map(c => {\n        const col = c instanceof Column ? c : new Column(c);\n        if (col.name in colNames) {\n          throw new Error(`Duplicate column name \"${col.name}\".`);\n        }\n        colNames[col.name] = true;\n        return col;\n      });\n    } else {\n      if (columns instanceof Column) {\n        this.columns = [columns];\n      } else {\n        this.columns = [];\n        for (const name in columns) {\n          if (opt.inherit || Object.prototype.hasOwnProperty.call(columns, name)) {\n            this.columns.push(new Column(name));\n          }\n        }\n      }\n    }\n    Object.freeze(this.columns);\n    Object.freeze(this);\n    this.extendState({\n      names: undefined,\n      variables: undefined,\n      updates: undefined,\n      isSimple: true\n    });\n    for (let i = 0; i < this.columns.length; i++) {\n      const c = this.columns[i];\n      // ColumnSet is simple when the source objects require no preparation,\n      // and should be used directly:\n      if (c.prop || c.init || 'def' in c) {\n        this._inner.isSimple = false;\n        break;\n      }\n    }\n  }\n\n  /**\r\n   * @name helpers.ColumnSet#names\r\n   * @type string\r\n   * @readonly\r\n   * @description\r\n   * Returns a string - comma-separated list of all column names, properly escaped.\r\n   *\r\n   * @example\r\n   * const cs = new ColumnSet(['id^', {name: 'cells', cast: 'int[]'}, 'doc:json']);\r\n   * console.log(cs.names);\r\n   * //=> \"id\",\"cells\",\"doc\"\r\n   */\n  get names() {\n    const _i = this._inner;\n    if (!_i.names) {\n      _i.names = this.columns.map(c => c.escapedName).join();\n    }\n    return _i.names;\n  }\n\n  /**\r\n   * @name helpers.ColumnSet#variables\r\n   * @type string\r\n   * @readonly\r\n   * @description\r\n   * Returns a string - formatting template for all column values.\r\n   *\r\n   * @see {@link helpers.ColumnSet#assign assign}\r\n   *\r\n   * @example\r\n   * const cs = new ColumnSet(['id^', {name: 'cells', cast: 'int[]'}, 'doc:json']);\r\n   * console.log(cs.variables);\r\n   * //=> ${id^},${cells}::int[],${doc:json}\r\n   */\n  get variables() {\n    const _i = this._inner;\n    if (!_i.variables) {\n      _i.variables = this.columns.map(c => c.variable + c.castText).join();\n    }\n    return _i.variables;\n  }\n}\n\n/**\r\n * @method helpers.ColumnSet#assign\r\n * @description\r\n * Returns a formatting template of SET assignments, either generic or for a single object.\r\n *\r\n * The method is optimized to cache the output string when there are no columns that can be skipped dynamically.\r\n *\r\n * This method is primarily for internal use, that's why it does not validate the input.\r\n *\r\n * @param {object} [options]\r\n * Assignment/formatting options.\r\n *\r\n * @param {object} [options.source]\r\n * Source - a single object that contains values for columns.\r\n *\r\n * The object is only necessary to correctly apply the logic of skipping columns dynamically, based on the source data\r\n * and the rules defined in the {@link helpers.ColumnSet ColumnSet}. If, however, you do not care about that, then you do not need to specify any object.\r\n *\r\n * Note that even if you do not specify the object, the columns marked as conditional (`cnd: true`) will always be skipped.\r\n *\r\n * @param {string} [options.prefix]\r\n * In cases where needed, an alias prefix to be added before each column.\r\n *\r\n * @returns {string}\r\n * Comma-separated list of variable-to-column assignments.\r\n *\r\n * @see {@link helpers.ColumnSet#variables variables}\r\n *\r\n * @example\r\n *\r\n * const cs = new pgp.helpers.ColumnSet([\r\n *     '?first', // = {name: 'first', cnd: true}\r\n *     'second:json',\r\n *     {name: 'third', mod: ':raw', cast: 'text'}\r\n * ]);\r\n *\r\n * cs.assign();\r\n * //=> \"second\"=${second:json},\"third\"=${third:raw}::text\r\n *\r\n * cs.assign({prefix: 'a b c'});\r\n * //=> \"a b c\".\"second\"=${second:json},\"a b c\".\"third\"=${third:raw}::text\r\n */\nColumnSet.prototype.assign = function (options) {\n  const _i = this._inner;\n  const hasPrefix = options && options.prefix && typeof options.prefix === 'string';\n  if (_i.updates && !hasPrefix) {\n    return _i.updates;\n  }\n  let dynamic = hasPrefix;\n  const hasSource = options && options.source && typeof options.source === 'object';\n  let list = this.columns.filter(c => {\n    if (c.cnd) {\n      return false;\n    }\n    if (c.skip) {\n      dynamic = true;\n      if (hasSource) {\n        const a = colDesc(c, options.source);\n        if (c.skip.call(options.source, a)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  });\n  const prefix = hasPrefix ? npm.formatting.as.alias(options.prefix) + '.' : '';\n  list = list.map(c => prefix + c.escapedName + '=' + c.variable + c.castText).join();\n  if (!dynamic) {\n    _i.updates = list;\n  }\n  return list;\n};\n\n/**\r\n * @method helpers.ColumnSet#assignColumns\r\n * @description\r\n * Generates assignments for all columns in the set, with support for aliases and column-skipping logic.\r\n * Aliases are set by using method {@link formatting.alias as.alias}.\r\n *\r\n * @param {{}} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {string} [options.from]\r\n * Alias for the source columns.\r\n *\r\n * @param {string} [options.to]\r\n * Alias for the destination columns.\r\n *\r\n * @param {string | Array<string> | function} [options.skip]\r\n * Name(s) of the column(s) to be skipped (case-sensitive). It can be either a single string or an array of strings.\r\n *\r\n * It can also be a function - iterator, to be called for every column, passing in {@link helpers.Column Column} as\r\n * `this` context, and plus as a single parameter. The function would return a truthy value for every column that needs to be skipped.\r\n *\r\n * @returns {string}\r\n * A string of comma-separated column assignments.\r\n *\r\n * @example\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['id', 'city', 'street']);\r\n *\r\n * cs.assignColumns({from: 'EXCLUDED', skip: 'id'})\r\n * //=> \"city\"=EXCLUDED.\"city\",\"street\"=EXCLUDED.\"street\"\r\n *\r\n * @example\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['?id', 'city', 'street']);\r\n *\r\n * cs.assignColumns({from: 'source', to: 'target', skip: c => c.cnd})\r\n * //=> target.\"city\"=source.\"city\",target.\"street\"=source.\"street\"\r\n *\r\n */\nColumnSet.prototype.assignColumns = function (options) {\n  options = assert(options, ['from', 'to', 'skip']);\n  const skip = typeof options.skip === 'string' && [options.skip] || (Array.isArray(options.skip) || typeof options.skip === 'function') && options.skip;\n  const from = typeof options.from === 'string' && options.from && npm.formatting.as.alias(options.from) + '.' || '';\n  const to = typeof options.to === 'string' && options.to && npm.formatting.as.alias(options.to) + '.' || '';\n  const iterator = typeof skip === 'function' ? c => !skip.call(c, c) : c => skip.indexOf(c.name) === -1;\n  const cols = skip ? this.columns.filter(iterator) : this.columns;\n  return cols.map(c => to + c.escapedName + '=' + from + c.escapedName).join();\n};\n\n/**\r\n * @method helpers.ColumnSet#extend\r\n * @description\r\n * Creates a new {@link helpers.ColumnSet ColumnSet}, by joining the two sets of columns.\r\n *\r\n * If the two sets contain a column with the same `name` (case-sensitive), an error is thrown.\r\n *\r\n * @param {helpers.Column|helpers.ColumnSet|array} columns\r\n * Columns to be appended, of the same type as parameter `columns` during {@link helpers.ColumnSet ColumnSet} construction, except:\r\n * - it can also be of type {@link helpers.ColumnSet ColumnSet}\r\n * - it cannot be a simple object (properties enumeration is not supported here)\r\n *\r\n * @returns {helpers.ColumnSet}\r\n * New {@link helpers.ColumnSet ColumnSet} object with the extended/concatenated list of columns.\r\n *\r\n * @see\r\n * {@link helpers.Column Column},\r\n * {@link helpers.ColumnSet#merge merge}\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')();\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['one', 'two'], {table: 'my-table'});\r\n * console.log(cs);\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"my-table\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"one\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"two\"\r\n * //        }\r\n * //    ]\r\n * // }\r\n * const csExtended = cs.extend(['three']);\r\n * console.log(csExtended);\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"my-table\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"one\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"two\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"three\"\r\n * //        }\r\n * //    ]\r\n * // }\r\n */\nColumnSet.prototype.extend = function (columns) {\n  let cs = columns;\n  if (!(cs instanceof ColumnSet)) {\n    cs = new ColumnSet(columns);\n  }\n  // Any duplicate column will throw Error = 'Duplicate column name \"name\".',\n  return new ColumnSet(this.columns.concat(cs.columns), {\n    table: this.table\n  });\n};\n\n/**\r\n * @method helpers.ColumnSet#merge\r\n * @description\r\n * Creates a new {@link helpers.ColumnSet ColumnSet}, by joining the two sets of columns.\r\n *\r\n * Items in `columns` with the same `name` (case-sensitive) override the original columns.\r\n *\r\n * @param {helpers.Column|helpers.ColumnSet|array} columns\r\n * Columns to be appended, of the same type as parameter `columns` during {@link helpers.ColumnSet ColumnSet} construction, except:\r\n * - it can also be of type {@link helpers.ColumnSet ColumnSet}\r\n * - it cannot be a simple object (properties enumeration is not supported here)\r\n *\r\n * @see\r\n * {@link helpers.Column Column},\r\n * {@link helpers.ColumnSet#extend extend}\r\n *\r\n * @returns {helpers.ColumnSet}\r\n * New {@link helpers.ColumnSet ColumnSet} object with the merged list of columns.\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')();\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['?one', 'two:json'], {table: 'my-table'});\r\n * console.log(cs);\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"my-table\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"one\"\r\n * //            cnd: true\r\n * //        }\r\n * //        Column {\r\n * //            name: \"two\"\r\n * //            mod: \":json\"\r\n * //        }\r\n * //    ]\r\n * // }\r\n * const csMerged = cs.merge(['two', 'three^']);\r\n * console.log(csMerged);\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"my-table\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"one\"\r\n * //            cnd: true\r\n * //        }\r\n * //        Column {\r\n * //            name: \"two\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"three\"\r\n * //            mod: \"^\"\r\n * //        }\r\n * //    ]\r\n * // }\r\n *\r\n */\nColumnSet.prototype.merge = function (columns) {\n  let cs = columns;\n  if (!(cs instanceof ColumnSet)) {\n    cs = new ColumnSet(columns);\n  }\n  const colNames = {},\n    cols = [];\n  this.columns.forEach((c, idx) => {\n    cols.push(c);\n    colNames[c.name] = idx;\n  });\n  cs.columns.forEach(c => {\n    if (c.name in colNames) {\n      cols[colNames[c.name]] = c;\n    } else {\n      cols.push(c);\n    }\n  });\n  return new ColumnSet(cols, {\n    table: this.table\n  });\n};\n\n/**\r\n * @method helpers.ColumnSet#prepare\r\n * @description\r\n * Prepares a source object to be formatted, by cloning it and applying the rules as set by the\r\n * columns configuration.\r\n *\r\n * This method is primarily for internal use, that's why it does not validate the input parameters.\r\n *\r\n * @param {object} source\r\n * The source object to be prepared, if required.\r\n *\r\n * It must be a non-`null` object, which the method does not validate, as it is\r\n * intended primarily for internal use by the library.\r\n *\r\n * @returns {object}\r\n * When the object needs to be prepared, the method returns a clone of the source object,\r\n * with all properties and values set according to the columns configuration.\r\n *\r\n * When the object does not need to be prepared, the original object is returned.\r\n */\nColumnSet.prototype.prepare = function (source) {\n  if (this._inner.isSimple) {\n    return source; // a simple ColumnSet requires no object preparation;\n  }\n\n  const target = {};\n  this.columns.forEach(c => {\n    const a = colDesc(c, source);\n    if (c.init) {\n      target[a.name] = c.init.call(source, a);\n    } else {\n      if (a.exists || 'def' in c) {\n        target[a.name] = a.value;\n      }\n    }\n  });\n  return target;\n};\nfunction colDesc(column, source) {\n  const a = {\n    source,\n    name: column.prop || column.name\n  };\n  a.exists = a.name in source;\n  if (a.exists) {\n    a.value = source[a.name];\n  } else {\n    a.value = 'def' in column ? column.def : undefined;\n  }\n  return a;\n}\n\n/**\r\n * @method helpers.ColumnSet#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\nColumnSet.prototype.toString = function (level) {\n  level = level > 0 ? parseInt(level) : 0;\n  const gap0 = npm.utils.messageGap(level),\n    gap1 = npm.utils.messageGap(level + 1),\n    lines = ['ColumnSet {'];\n  if (this.table) {\n    lines.push(gap1 + 'table: ' + this.table);\n  }\n  if (this.columns.length) {\n    lines.push(gap1 + 'columns: [');\n    this.columns.forEach(c => {\n      lines.push(c.toString(2));\n    });\n    lines.push(gap1 + ']');\n  } else {\n    lines.push(gap1 + 'columns: []');\n  }\n  lines.push(gap0 + '}');\n  return lines.join(npm.os.EOL);\n};\nnpm.utils.addInspection(ColumnSet, function () {\n  return this.toString();\n});\nmodule.exports = {\n  ColumnSet\n};","map":{"version":3,"names":["InnerState","require","assert","TableName","Column","npm","os","utils","formatting","ColumnSet","constructor","columns","opt","TypeError","isNull","table","Array","isArray","colNames","map","c","col","name","Error","inherit","Object","prototype","hasOwnProperty","call","push","freeze","extendState","names","undefined","variables","updates","isSimple","i","length","prop","init","_inner","_i","escapedName","join","variable","castText","assign","options","hasPrefix","prefix","dynamic","hasSource","source","list","filter","cnd","skip","a","colDesc","as","alias","assignColumns","from","to","iterator","indexOf","cols","extend","cs","concat","merge","forEach","idx","prepare","target","exists","value","column","def","toString","level","parseInt","gap0","messageGap","gap1","lines","EOL","addInspection","module","exports"],"sources":["/Users/luna/Library/Mobile Documents/com~apple~CloudDocs/GitHub/paucamcal.github.io/AESP/node_modules/pg-promise/lib/helpers/column-set.js"],"sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {InnerState} = require('../inner-state');\r\nconst {assert} = require('../assert');\r\nconst {TableName} = require('./table-name');\r\nconst {Column} = require('./column');\r\n\r\nconst npm = {\r\n    os: require('os'),\r\n    utils: require('../utils'),\r\n    formatting: require('../formatting')\r\n};\r\n\r\n/**\r\n * @class helpers.ColumnSet\r\n * @description\r\n * Performance-optimized, read-only structure with query-formatting columns.\r\n *\r\n * In order to avail from performance optimization provided by this class, it should be created\r\n * only once, statically, and then reused.\r\n *\r\n * @param {object|helpers.Column|array} columns\r\n * Columns information object, depending on the type:\r\n *\r\n * - When it is a simple object, its properties are enumerated to represent both column names and property names\r\n *   within the source objects. See also option `inherit` that's applicable in this case.\r\n *\r\n * - When it is a single {@link helpers.Column Column} object, property {@link helpers.ColumnSet#columns columns} is initialized with\r\n *   just a single column. It is not a unique situation when only a single column is required for an update operation.\r\n *\r\n * - When it is an array, each element is assumed to represent details for a column. If the element is already of type {@link helpers.Column Column},\r\n *   it is used directly; otherwise the element is passed into {@link helpers.Column Column} constructor for initialization.\r\n *   On any duplicate column name (case-sensitive) it will throw {@link external:Error Error} = `Duplicate column name \"name\".`\r\n *\r\n * - When it is none of the above, it will throw {@link external:TypeError TypeError} = `Invalid parameter 'columns' specified.`\r\n *\r\n * @param {object} [options]\r\n *\r\n * @param {helpers.TableName|string|{table,schema}} [options.table]\r\n * Table details.\r\n *\r\n * When it is a non-null value, and not a {@link helpers.TableName TableName} object, a new {@link helpers.TableName TableName} is constructed from the value.\r\n *\r\n * It can be used as the default for methods {@link helpers.insert insert} and {@link helpers.update update} when their parameter\r\n * `table` is omitted, and for logging purposes.\r\n *\r\n * @param {boolean} [options.inherit = false]\r\n * Use inherited properties in addition to the object's own properties.\r\n *\r\n * By default, only the object's own properties are enumerated for column names.\r\n *\r\n * @returns {helpers.ColumnSet}\r\n *\r\n * @see\r\n *\r\n * {@link helpers.ColumnSet#columns columns},\r\n * {@link helpers.ColumnSet#names names},\r\n * {@link helpers.ColumnSet#table table},\r\n * {@link helpers.ColumnSet#variables variables} |\r\n * {@link helpers.ColumnSet#assign assign},\r\n * {@link helpers.ColumnSet#assignColumns assignColumns},\r\n * {@link helpers.ColumnSet#extend extend},\r\n * {@link helpers.ColumnSet#merge merge},\r\n * {@link helpers.ColumnSet#prepare prepare}\r\n *\r\n * @example\r\n *\r\n * // A complex insert/update object scenario for table 'purchases' in schema 'fiscal'.\r\n * // For a good performance, you should declare such objects once and then reuse them.\r\n * //\r\n * // Column Requirements:\r\n * //\r\n * // 1. Property 'id' is only to be used for a WHERE condition in updates\r\n * // 2. Property 'list' needs to be formatted as a csv\r\n * // 3. Property 'code' is to be used as raw text, and to be defaulted to 0 when the\r\n * //    property is missing in the source object\r\n * // 4. Property 'log' is a JSON object with 'log-entry' for the column name\r\n * // 5. Property 'data' requires SQL type casting '::int[]'\r\n * // 6. Property 'amount' needs to be set to 100, if it is 0\r\n * // 7. Property 'total' must be skipped during updates, if 'amount' was 0, plus its\r\n * //    column name is 'total-val'\r\n *\r\n * const cs = new pgp.helpers.ColumnSet([\r\n *     '?id', // ColumnConfig equivalent: {name: 'id', cnd: true}\r\n *     'list:csv', // ColumnConfig equivalent: {name: 'list', mod: ':csv'}\r\n *     {\r\n *         name: 'code',\r\n *         mod: '^', // format as raw text\r\n *         def: 0 // default to 0 when the property doesn't exist\r\n *     },\r\n *     {\r\n *         name: 'log-entry',\r\n *         prop: 'log',\r\n *         mod: ':json' // format as JSON\r\n *     },\r\n *     {\r\n *         name: 'data',\r\n *         cast: 'int[]' // use SQL type casting '::int[]'\r\n *     },\r\n *     {\r\n *         name: 'amount',\r\n *         init(col) {\r\n *             // set to 100, if the value is 0:\r\n *             return col.value === 0 ? 100 : col.value;\r\n *         }\r\n *     },\r\n *     {\r\n *         name: 'total-val',\r\n *         prop: 'total',\r\n *         skip(col) {\r\n *             // skip from updates, if 'amount' is 0:\r\n *             return col.source.amount === 0;\r\n *         }\r\n *     }\r\n * ], {table: {table: 'purchases', schema: 'fiscal'}});\r\n *\r\n * // Alternatively, you could take the table declaration out:\r\n * // const table = new pgp.helpers.TableName('purchases', 'fiscal');\r\n *\r\n * console.log(cs); // console output for the object:\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"fiscal\".\"purchases\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"id\"\r\n * //            cnd: true\r\n * //        }\r\n * //        Column {\r\n * //            name: \"list\"\r\n * //            mod: \":csv\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"code\"\r\n * //            mod: \"^\"\r\n * //            def: 0\r\n * //        }\r\n * //        Column {\r\n * //            name: \"log-entry\"\r\n * //            prop: \"log\"\r\n * //            mod: \":json\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"data\"\r\n * //            cast: \"int[]\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"amount\"\r\n * //            init: [Function]\r\n * //        }\r\n * //        Column {\r\n * //            name: \"total-val\"\r\n * //            prop: \"total\"\r\n * //            skip: [Function]\r\n * //        }\r\n * //    ]\r\n * // }\r\n */\r\nclass ColumnSet extends InnerState {\r\n\r\n    constructor(columns, opt) {\r\n        super();\r\n\r\n        if (!columns || typeof columns !== 'object') {\r\n            throw new TypeError('Invalid parameter \\'columns\\' specified.');\r\n        }\r\n\r\n        opt = assert(opt, ['table', 'inherit']);\r\n\r\n        if (!npm.utils.isNull(opt.table)) {\r\n            this.table = (opt.table instanceof TableName) ? opt.table : new TableName(opt.table);\r\n        }\r\n\r\n        /**\r\n         * @name helpers.ColumnSet#table\r\n         * @type {helpers.TableName}\r\n         * @readonly\r\n         * @description\r\n         * Destination table. It can be specified for two purposes:\r\n         *\r\n         * - **primary:** to be used as the default table when it is omitted during a call into methods {@link helpers.insert insert} and {@link helpers.update update}\r\n         * - **secondary:** to be automatically written into the console (for logging purposes).\r\n         */\r\n\r\n\r\n        /**\r\n         * @name helpers.ColumnSet#columns\r\n         * @type helpers.Column[]\r\n         * @readonly\r\n         * @description\r\n         * Array of {@link helpers.Column Column} objects.\r\n         */\r\n        if (Array.isArray(columns)) {\r\n            const colNames = {};\r\n            this.columns = columns.map(c => {\r\n                const col = (c instanceof Column) ? c : new Column(c);\r\n                if (col.name in colNames) {\r\n                    throw new Error(`Duplicate column name \"${col.name}\".`);\r\n                }\r\n                colNames[col.name] = true;\r\n                return col;\r\n            });\r\n        } else {\r\n            if (columns instanceof Column) {\r\n                this.columns = [columns];\r\n            } else {\r\n                this.columns = [];\r\n                for (const name in columns) {\r\n                    if (opt.inherit || Object.prototype.hasOwnProperty.call(columns, name)) {\r\n                        this.columns.push(new Column(name));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        Object.freeze(this.columns);\r\n        Object.freeze(this);\r\n\r\n        this.extendState({\r\n            names: undefined,\r\n            variables: undefined,\r\n            updates: undefined,\r\n            isSimple: true\r\n        });\r\n\r\n        for (let i = 0; i < this.columns.length; i++) {\r\n            const c = this.columns[i];\r\n            // ColumnSet is simple when the source objects require no preparation,\r\n            // and should be used directly:\r\n            if (c.prop || c.init || 'def' in c) {\r\n                this._inner.isSimple = false;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @name helpers.ColumnSet#names\r\n     * @type string\r\n     * @readonly\r\n     * @description\r\n     * Returns a string - comma-separated list of all column names, properly escaped.\r\n     *\r\n     * @example\r\n     * const cs = new ColumnSet(['id^', {name: 'cells', cast: 'int[]'}, 'doc:json']);\r\n     * console.log(cs.names);\r\n     * //=> \"id\",\"cells\",\"doc\"\r\n     */\r\n    get names() {\r\n        const _i = this._inner;\r\n        if (!_i.names) {\r\n            _i.names = this.columns.map(c => c.escapedName).join();\r\n        }\r\n        return _i.names;\r\n    }\r\n\r\n    /**\r\n     * @name helpers.ColumnSet#variables\r\n     * @type string\r\n     * @readonly\r\n     * @description\r\n     * Returns a string - formatting template for all column values.\r\n     *\r\n     * @see {@link helpers.ColumnSet#assign assign}\r\n     *\r\n     * @example\r\n     * const cs = new ColumnSet(['id^', {name: 'cells', cast: 'int[]'}, 'doc:json']);\r\n     * console.log(cs.variables);\r\n     * //=> ${id^},${cells}::int[],${doc:json}\r\n     */\r\n    get variables() {\r\n        const _i = this._inner;\r\n        if (!_i.variables) {\r\n            _i.variables = this.columns.map(c => c.variable + c.castText).join();\r\n        }\r\n        return _i.variables;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @method helpers.ColumnSet#assign\r\n * @description\r\n * Returns a formatting template of SET assignments, either generic or for a single object.\r\n *\r\n * The method is optimized to cache the output string when there are no columns that can be skipped dynamically.\r\n *\r\n * This method is primarily for internal use, that's why it does not validate the input.\r\n *\r\n * @param {object} [options]\r\n * Assignment/formatting options.\r\n *\r\n * @param {object} [options.source]\r\n * Source - a single object that contains values for columns.\r\n *\r\n * The object is only necessary to correctly apply the logic of skipping columns dynamically, based on the source data\r\n * and the rules defined in the {@link helpers.ColumnSet ColumnSet}. If, however, you do not care about that, then you do not need to specify any object.\r\n *\r\n * Note that even if you do not specify the object, the columns marked as conditional (`cnd: true`) will always be skipped.\r\n *\r\n * @param {string} [options.prefix]\r\n * In cases where needed, an alias prefix to be added before each column.\r\n *\r\n * @returns {string}\r\n * Comma-separated list of variable-to-column assignments.\r\n *\r\n * @see {@link helpers.ColumnSet#variables variables}\r\n *\r\n * @example\r\n *\r\n * const cs = new pgp.helpers.ColumnSet([\r\n *     '?first', // = {name: 'first', cnd: true}\r\n *     'second:json',\r\n *     {name: 'third', mod: ':raw', cast: 'text'}\r\n * ]);\r\n *\r\n * cs.assign();\r\n * //=> \"second\"=${second:json},\"third\"=${third:raw}::text\r\n *\r\n * cs.assign({prefix: 'a b c'});\r\n * //=> \"a b c\".\"second\"=${second:json},\"a b c\".\"third\"=${third:raw}::text\r\n */\r\nColumnSet.prototype.assign = function (options) {\r\n    const _i = this._inner;\r\n    const hasPrefix = options && options.prefix && typeof options.prefix === 'string';\r\n    if (_i.updates && !hasPrefix) {\r\n        return _i.updates;\r\n    }\r\n    let dynamic = hasPrefix;\r\n    const hasSource = options && options.source && typeof options.source === 'object';\r\n    let list = this.columns.filter(c => {\r\n        if (c.cnd) {\r\n            return false;\r\n        }\r\n        if (c.skip) {\r\n            dynamic = true;\r\n            if (hasSource) {\r\n                const a = colDesc(c, options.source);\r\n                if (c.skip.call(options.source, a)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    });\r\n\r\n    const prefix = hasPrefix ? npm.formatting.as.alias(options.prefix) + '.' : '';\r\n    list = list.map(c => prefix + c.escapedName + '=' + c.variable + c.castText).join();\r\n\r\n    if (!dynamic) {\r\n        _i.updates = list;\r\n    }\r\n    return list;\r\n};\r\n\r\n/**\r\n * @method helpers.ColumnSet#assignColumns\r\n * @description\r\n * Generates assignments for all columns in the set, with support for aliases and column-skipping logic.\r\n * Aliases are set by using method {@link formatting.alias as.alias}.\r\n *\r\n * @param {{}} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {string} [options.from]\r\n * Alias for the source columns.\r\n *\r\n * @param {string} [options.to]\r\n * Alias for the destination columns.\r\n *\r\n * @param {string | Array<string> | function} [options.skip]\r\n * Name(s) of the column(s) to be skipped (case-sensitive). It can be either a single string or an array of strings.\r\n *\r\n * It can also be a function - iterator, to be called for every column, passing in {@link helpers.Column Column} as\r\n * `this` context, and plus as a single parameter. The function would return a truthy value for every column that needs to be skipped.\r\n *\r\n * @returns {string}\r\n * A string of comma-separated column assignments.\r\n *\r\n * @example\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['id', 'city', 'street']);\r\n *\r\n * cs.assignColumns({from: 'EXCLUDED', skip: 'id'})\r\n * //=> \"city\"=EXCLUDED.\"city\",\"street\"=EXCLUDED.\"street\"\r\n *\r\n * @example\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['?id', 'city', 'street']);\r\n *\r\n * cs.assignColumns({from: 'source', to: 'target', skip: c => c.cnd})\r\n * //=> target.\"city\"=source.\"city\",target.\"street\"=source.\"street\"\r\n *\r\n */\r\nColumnSet.prototype.assignColumns = function (options) {\r\n    options = assert(options, ['from', 'to', 'skip']);\r\n    const skip = (typeof options.skip === 'string' && [options.skip]) || ((Array.isArray(options.skip) || typeof options.skip === 'function') && options.skip);\r\n    const from = (typeof options.from === 'string' && options.from && (npm.formatting.as.alias(options.from) + '.')) || '';\r\n    const to = (typeof options.to === 'string' && options.to && (npm.formatting.as.alias(options.to) + '.')) || '';\r\n    const iterator = typeof skip === 'function' ? c => !skip.call(c, c) : c => skip.indexOf(c.name) === -1;\r\n    const cols = skip ? this.columns.filter(iterator) : this.columns;\r\n    return cols.map(c => to + c.escapedName + '=' + from + c.escapedName).join();\r\n};\r\n\r\n/**\r\n * @method helpers.ColumnSet#extend\r\n * @description\r\n * Creates a new {@link helpers.ColumnSet ColumnSet}, by joining the two sets of columns.\r\n *\r\n * If the two sets contain a column with the same `name` (case-sensitive), an error is thrown.\r\n *\r\n * @param {helpers.Column|helpers.ColumnSet|array} columns\r\n * Columns to be appended, of the same type as parameter `columns` during {@link helpers.ColumnSet ColumnSet} construction, except:\r\n * - it can also be of type {@link helpers.ColumnSet ColumnSet}\r\n * - it cannot be a simple object (properties enumeration is not supported here)\r\n *\r\n * @returns {helpers.ColumnSet}\r\n * New {@link helpers.ColumnSet ColumnSet} object with the extended/concatenated list of columns.\r\n *\r\n * @see\r\n * {@link helpers.Column Column},\r\n * {@link helpers.ColumnSet#merge merge}\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')();\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['one', 'two'], {table: 'my-table'});\r\n * console.log(cs);\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"my-table\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"one\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"two\"\r\n * //        }\r\n * //    ]\r\n * // }\r\n * const csExtended = cs.extend(['three']);\r\n * console.log(csExtended);\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"my-table\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"one\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"two\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"three\"\r\n * //        }\r\n * //    ]\r\n * // }\r\n */\r\nColumnSet.prototype.extend = function (columns) {\r\n    let cs = columns;\r\n    if (!(cs instanceof ColumnSet)) {\r\n        cs = new ColumnSet(columns);\r\n    }\r\n    // Any duplicate column will throw Error = 'Duplicate column name \"name\".',\r\n    return new ColumnSet(this.columns.concat(cs.columns), {table: this.table});\r\n};\r\n\r\n/**\r\n * @method helpers.ColumnSet#merge\r\n * @description\r\n * Creates a new {@link helpers.ColumnSet ColumnSet}, by joining the two sets of columns.\r\n *\r\n * Items in `columns` with the same `name` (case-sensitive) override the original columns.\r\n *\r\n * @param {helpers.Column|helpers.ColumnSet|array} columns\r\n * Columns to be appended, of the same type as parameter `columns` during {@link helpers.ColumnSet ColumnSet} construction, except:\r\n * - it can also be of type {@link helpers.ColumnSet ColumnSet}\r\n * - it cannot be a simple object (properties enumeration is not supported here)\r\n *\r\n * @see\r\n * {@link helpers.Column Column},\r\n * {@link helpers.ColumnSet#extend extend}\r\n *\r\n * @returns {helpers.ColumnSet}\r\n * New {@link helpers.ColumnSet ColumnSet} object with the merged list of columns.\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')();\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['?one', 'two:json'], {table: 'my-table'});\r\n * console.log(cs);\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"my-table\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"one\"\r\n * //            cnd: true\r\n * //        }\r\n * //        Column {\r\n * //            name: \"two\"\r\n * //            mod: \":json\"\r\n * //        }\r\n * //    ]\r\n * // }\r\n * const csMerged = cs.merge(['two', 'three^']);\r\n * console.log(csMerged);\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"my-table\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"one\"\r\n * //            cnd: true\r\n * //        }\r\n * //        Column {\r\n * //            name: \"two\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"three\"\r\n * //            mod: \"^\"\r\n * //        }\r\n * //    ]\r\n * // }\r\n *\r\n */\r\nColumnSet.prototype.merge = function (columns) {\r\n    let cs = columns;\r\n    if (!(cs instanceof ColumnSet)) {\r\n        cs = new ColumnSet(columns);\r\n    }\r\n    const colNames = {}, cols = [];\r\n    this.columns.forEach((c, idx) => {\r\n        cols.push(c);\r\n        colNames[c.name] = idx;\r\n    });\r\n    cs.columns.forEach(c => {\r\n        if (c.name in colNames) {\r\n            cols[colNames[c.name]] = c;\r\n        } else {\r\n            cols.push(c);\r\n        }\r\n    });\r\n    return new ColumnSet(cols, {table: this.table});\r\n};\r\n\r\n/**\r\n * @method helpers.ColumnSet#prepare\r\n * @description\r\n * Prepares a source object to be formatted, by cloning it and applying the rules as set by the\r\n * columns configuration.\r\n *\r\n * This method is primarily for internal use, that's why it does not validate the input parameters.\r\n *\r\n * @param {object} source\r\n * The source object to be prepared, if required.\r\n *\r\n * It must be a non-`null` object, which the method does not validate, as it is\r\n * intended primarily for internal use by the library.\r\n *\r\n * @returns {object}\r\n * When the object needs to be prepared, the method returns a clone of the source object,\r\n * with all properties and values set according to the columns configuration.\r\n *\r\n * When the object does not need to be prepared, the original object is returned.\r\n */\r\nColumnSet.prototype.prepare = function (source) {\r\n    if (this._inner.isSimple) {\r\n        return source; // a simple ColumnSet requires no object preparation;\r\n    }\r\n    const target = {};\r\n    this.columns.forEach(c => {\r\n        const a = colDesc(c, source);\r\n        if (c.init) {\r\n            target[a.name] = c.init.call(source, a);\r\n        } else {\r\n            if (a.exists || 'def' in c) {\r\n                target[a.name] = a.value;\r\n            }\r\n        }\r\n    });\r\n    return target;\r\n};\r\n\r\nfunction colDesc(column, source) {\r\n    const a = {\r\n        source,\r\n        name: column.prop || column.name\r\n    };\r\n    a.exists = a.name in source;\r\n    if (a.exists) {\r\n        a.value = source[a.name];\r\n    } else {\r\n        a.value = 'def' in column ? column.def : undefined;\r\n    }\r\n    return a;\r\n}\r\n\r\n/**\r\n * @method helpers.ColumnSet#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\r\nColumnSet.prototype.toString = function (level) {\r\n    level = level > 0 ? parseInt(level) : 0;\r\n    const gap0 = npm.utils.messageGap(level),\r\n        gap1 = npm.utils.messageGap(level + 1),\r\n        lines = [\r\n            'ColumnSet {'\r\n        ];\r\n    if (this.table) {\r\n        lines.push(gap1 + 'table: ' + this.table);\r\n    }\r\n    if (this.columns.length) {\r\n        lines.push(gap1 + 'columns: [');\r\n        this.columns.forEach(c => {\r\n            lines.push(c.toString(2));\r\n        });\r\n        lines.push(gap1 + ']');\r\n    } else {\r\n        lines.push(gap1 + 'columns: []');\r\n    }\r\n    lines.push(gap0 + '}');\r\n    return lines.join(npm.os.EOL);\r\n};\r\n\r\nnpm.utils.addInspection(ColumnSet, function () {\r\n    return this.toString();\r\n});\r\n\r\nmodule.exports = {ColumnSet};\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM;EAACA;AAAU,CAAC,GAAGC,OAAO,CAAC,gBAAgB,CAAC;AAC9C,MAAM;EAACC;AAAM,CAAC,GAAGD,OAAO,CAAC,WAAW,CAAC;AACrC,MAAM;EAACE;AAAS,CAAC,GAAGF,OAAO,CAAC,cAAc,CAAC;AAC3C,MAAM;EAACG;AAAM,CAAC,GAAGH,OAAO,CAAC,UAAU,CAAC;AAEpC,MAAMI,GAAG,GAAG;EACRC,EAAE,EAAEL,OAAO,CAAC,IAAI,CAAC;EACjBM,KAAK,EAAEN,OAAO,CAAC,UAAU,CAAC;EAC1BO,UAAU,EAAEP,OAAO,CAAC,eAAe;AACvC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMQ,SAAS,SAAST,UAAU,CAAC;EAE/BU,WAAWA,CAACC,OAAO,EAAEC,GAAG,EAAE;IACtB,K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,CAACR,CAAC,EAAEA,CAAC,CAAC,GAAGA,CAAC,IAAIqC,IAAI,CAACS,OAAO,CAAC9C,CAAC,CAACE,IAAI,CAAC,KAAK,CAAC,CAAC;EACtG,MAAM6C,IAAI,GAAGV,IAAI,GAAG,IAAI,CAAC9C,OAAO,CAAC4C,MAAM,CAACU,QAAQ,CAAC,GAAG,IAAI,CAACtD,OAAO;EAChE,OAAOwD,IAAI,CAAChD,GAAG,CAACC,CAAC,IAAI4C,EAAE,GAAG5C,CAAC,CAACuB,WAAW,GAAG,GAAG,GAAGoB,IAAI,GAAG3C,CAAC,CAACuB,WAAW,CAAC,CAACC,IAAI,CAAC,CAAC;AAChF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAnC,SAAS,CAACiB,SAAS,CAAC0C,MAAM,GAAG,UAAUzD,OAAO,EAAE;EAC5C,IAAI0D,EAAE,GAAG1D,OAAO;EAChB,IAAI,EAAE0D,EAAE,YAAY5D,SAAS,CAAC,EAAE;IAC5B4D,EAAE,GAAG,IAAI5D,SAAS,CAACE,OAAO,CAAC;EAC/B;EACA;EACA,OAAO,IAAIF,SAAS,CAAC,IAAI,CAACE,OAAO,CAAC2D,MAAM,CAACD,EAAE,CAAC1D,OAAO,CAAC,EAAE;IAACI,KAAK,EAAE,IAAI,CAACA;EAAK,CAAC,CAAC;AAC9E,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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"},"metadata":{},"sourceType":"script","externalDependencies":[]}