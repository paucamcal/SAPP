{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\n\nconst {\n  Events\n} = require('./events');\nconst {\n  QueryFile\n} = require('./query-file');\nconst {\n  ServerFormatting,\n  PreparedStatement,\n  ParameterizedQuery\n} = require('./types');\nconst {\n  SpecialQuery\n} = require('./special-query');\nconst {\n  queryResult\n} = require('./query-result');\nconst npm = {\n  util: require('util'),\n  utils: require('./utils'),\n  formatting: require('./formatting'),\n  errors: require('./errors'),\n  stream: require('./stream'),\n  text: require('./text')\n};\nconst QueryResultError = npm.errors.QueryResultError,\n  InternalError = npm.utils.InternalError,\n  qrec = npm.errors.queryResultErrorCode;\nconst badMask = queryResult.one | queryResult.many; // unsupported combination bit-mask;\n\n//////////////////////////////\n// Generic query method;\nfunction $query(ctx, query, values, qrm, config) {\n  const special = qrm instanceof SpecialQuery && qrm;\n  const $p = config.promise;\n  if (special && special.isStream) {\n    return npm.stream.call(this, ctx, query, values, config);\n  }\n  const opt = ctx.options,\n    capSQL = opt.capSQL;\n  let error,\n    entityType,\n    pgFormatting = opt.pgFormatting,\n    params = pgFormatting ? values : undefined;\n  if (typeof query === 'function') {\n    try {\n      query = npm.formatting.resolveFunc(query, values);\n    } catch (e) {\n      error = e;\n      params = values;\n      query = npm.util.inspect(query);\n    }\n  }\n  if (!error && !query) {\n    error = new TypeError(npm.text.invalidQuery);\n  }\n  if (!error && typeof query === 'object') {\n    if (query instanceof QueryFile) {\n      query.prepare();\n      if (query.error) {\n        error = query.error;\n        query = query.file;\n      } else {\n        query = query[QueryFile.$query];\n      }\n    } else {\n      if ('entity' in query) {\n        entityType = query.type;\n        query = query.entity; // query is a function name;\n      } else {\n        if (query instanceof ServerFormatting) {\n          pgFormatting = true;\n        } else {\n          if ('name' in query) {\n            query = new PreparedStatement(query);\n            pgFormatting = true;\n          } else {\n            if ('text' in query) {\n              query = new ParameterizedQuery(query);\n              pgFormatting = true;\n            }\n          }\n        }\n        if (query instanceof ServerFormatting && !npm.utils.isNull(values)) {\n          query.values = values;\n        }\n      }\n    }\n  }\n  if (!error) {\n    if (!pgFormatting && !npm.utils.isText(query)) {\n      const errTxt = entityType ? entityType === 'func' ? npm.text.invalidFunction : npm.text.invalidProc : npm.text.invalidQuery;\n      error = new TypeError(errTxt);\n    }\n    if (query instanceof ServerFormatting) {\n      const qp = query.parse();\n      if (qp instanceof Error) {\n        error = qp;\n      } else {\n        query = qp;\n      }\n    }\n  }\n  if (!error && !special) {\n    if (npm.utils.isNull(qrm)) {\n      qrm = queryResult.any; // default query result;\n    } else {\n      if (qrm !== parseInt(qrm) || (qrm & badMask) === badMask || qrm < 1 || qrm > 6) {\n        error = new TypeError(npm.text.invalidMask);\n      }\n    }\n  }\n  if (!error && (!pgFormatting || entityType)) {\n    try {\n      // use 'pg-promise' implementation of values formatting;\n      if (entityType) {\n        params = undefined;\n        query = npm.formatting.formatEntity(query, values, {\n          capSQL,\n          type: entityType\n        });\n      } else {\n        query = npm.formatting.formatQuery(query, values);\n      }\n    } catch (e) {\n      if (entityType) {\n        let prefix = entityType === 'func' ? 'select * from' : 'call';\n        if (capSQL) {\n          prefix = prefix.toUpperCase();\n        }\n        query = prefix + ' ' + query + '(...)';\n      } else {\n        params = values;\n      }\n      error = e instanceof Error ? e : new npm.utils.InternalError(e);\n    }\n  }\n  return $p((resolve, reject) => {\n    if (notifyReject()) {\n      return;\n    }\n    error = Events.query(opt, getContext());\n    if (notifyReject()) {\n      return;\n    }\n    try {\n      const start = Date.now();\n      ctx.db.client.query(query, params, (err, result) => {\n        let data,\n          multiResult,\n          lastResult = result;\n        if (err) {\n          // istanbul ignore if (auto-testing connectivity issues is too problematic)\n          if (npm.utils.isConnectivityError(err)) {\n            ctx.db.client.$connectionError = err;\n          }\n          err.query = err.query || query;\n          err.params = err.params || params;\n          error = err;\n        } else {\n          multiResult = Array.isArray(result);\n          if (multiResult) {\n            lastResult = result[result.length - 1];\n            for (let i = 0; i < result.length; i++) {\n              const r = result[i];\n              makeIterable(r);\n              error = Events.receive(opt, r.rows, r, getContext());\n              if (error) {\n                break;\n              }\n            }\n          } else {\n            makeIterable(result);\n            result.duration = Date.now() - start;\n            error = Events.receive(opt, result.rows, result, getContext());\n          }\n        }\n        if (!error) {\n          data = lastResult;\n          if (special) {\n            if (special.isMultiResult) {\n              data = multiResult ? result : [result]; // method .multiResult() is called\n            }\n            // else, method .result() is called\n          } else {\n            data = data.rows;\n            const len = data.length;\n            if (len) {\n              if (len > 1 && qrm & queryResult.one) {\n                // one row was expected, but returned multiple;\n                error = new QueryResultError(qrec.multiple, lastResult, query, params);\n              } else {\n                if (!(qrm & (queryResult.one | queryResult.many))) {\n                  // no data should have been returned;\n                  error = new QueryResultError(qrec.notEmpty, lastResult, query, params);\n                } else {\n                  if (!(qrm & queryResult.many)) {\n                    data = data[0];\n                  }\n                }\n              }\n            } else {\n              // no data returned;\n              if (qrm & queryResult.none) {\n                if (qrm & queryResult.one) {\n                  data = null;\n                } else {\n                  data = qrm & queryResult.many ? data : null;\n                }\n              } else {\n                error = new QueryResultError(qrec.noData, lastResult, query, params);\n              }\n            }\n          }\n        }\n        if (!notifyReject()) {\n          resolve(data);\n        }\n      });\n    } catch (e) {\n      // this can only happen as a result of an internal failure within node-postgres,\n      // like during a sudden loss of communications, which is impossible to reproduce\n      // automatically, so removing it from the test coverage:\n      // istanbul ignore next\n      error = e;\n    }\n    function getContext() {\n      let client;\n      if (ctx.db) {\n        client = ctx.db.client;\n      } else {\n        error = new Error(npm.text.looseQuery);\n      }\n      return {\n        client,\n        query,\n        params,\n        dc: ctx.dc,\n        ctx: ctx.ctx\n      };\n    }\n    notifyReject();\n    function notifyReject() {\n      const context = getContext();\n      if (error) {\n        if (error instanceof InternalError) {\n          error = error.error;\n        }\n        Events.error(opt, error, context);\n        reject(error);\n        return true;\n      }\n    }\n  });\n}\n\n// Extends Result to provide iterable for the rows;\n//\n// To be removed once the following PR is merged amd released:\n// https://github.com/brianc/node-postgres/pull/2861\nfunction makeIterable(r) {\n  r[Symbol.iterator] = function () {\n    return this.rows.values();\n  };\n}\nmodule.exports = config => {\n  return function (ctx, query, values, qrm) {\n    return $query.call(this, ctx, query, values, qrm, config);\n  };\n};","map":{"version":3,"names":["Events","require","QueryFile","ServerFormatting","PreparedStatement","ParameterizedQuery","SpecialQuery","queryResult","npm","util","utils","formatting","errors","stream","text","QueryResultError","InternalError","qrec","queryResultErrorCode","badMask","one","many","$query","ctx","query","values","qrm","config","special","$p","promise","isStream","call","opt","options","capSQL","error","entityType","pgFormatting","params","undefined","resolveFunc","e","inspect","TypeError","invalidQuery","prepare","file","type","entity","isNull","isText","errTxt","invalidFunction","invalidProc","qp","parse","Error","any","parseInt","invalidMask","formatEntity","formatQuery","prefix","toUpperCase","resolve","reject","notifyReject","getContext","start","Date","now","db","client","err","result","data","multiResult","lastResult","isConnectivityError","$connectionError","Array","isArray","length","i","r","makeIterable","receive","rows","duration","isMultiResult","len","multiple","notEmpty","none","noData","looseQuery","dc","context","Symbol","iterator","module","exports"],"sources":["/Users/luna/Library/Mobile Documents/com~apple~CloudDocs/GitHub/paucamcal.github.io/AESP/node_modules/pg-promise/lib/query.js"],"sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {Events} = require('./events');\r\nconst {QueryFile} = require('./query-file');\r\nconst {ServerFormatting, PreparedStatement, ParameterizedQuery} = require('./types');\r\nconst {SpecialQuery} = require('./special-query');\r\nconst {queryResult} = require('./query-result');\r\n\r\nconst npm = {\r\n    util: require('util'),\r\n    utils: require('./utils'),\r\n    formatting: require('./formatting'),\r\n    errors: require('./errors'),\r\n    stream: require('./stream'),\r\n    text: require('./text')\r\n};\r\n\r\nconst QueryResultError = npm.errors.QueryResultError,\r\n    InternalError = npm.utils.InternalError,\r\n    qrec = npm.errors.queryResultErrorCode;\r\n\r\nconst badMask = queryResult.one | queryResult.many; // unsupported combination bit-mask;\r\n\r\n//////////////////////////////\r\n// Generic query method;\r\nfunction $query(ctx, query, values, qrm, config) {\r\n\r\n    const special = qrm instanceof SpecialQuery && qrm;\r\n    const $p = config.promise;\r\n\r\n    if (special && special.isStream) {\r\n        return npm.stream.call(this, ctx, query, values, config);\r\n    }\r\n\r\n    const opt = ctx.options,\r\n        capSQL = opt.capSQL;\r\n\r\n    let error, entityType,\r\n        pgFormatting = opt.pgFormatting,\r\n        params = pgFormatting ? values : undefined;\r\n\r\n    if (typeof query === 'function') {\r\n        try {\r\n            query = npm.formatting.resolveFunc(query, values);\r\n        } catch (e) {\r\n            error = e;\r\n            params = values;\r\n            query = npm.util.inspect(query);\r\n        }\r\n    }\r\n\r\n    if (!error && !query) {\r\n        error = new TypeError(npm.text.invalidQuery);\r\n    }\r\n\r\n    if (!error && typeof query === 'object') {\r\n        if (query instanceof QueryFile) {\r\n            query.prepare();\r\n            if (query.error) {\r\n                error = query.error;\r\n                query = query.file;\r\n            } else {\r\n                query = query[QueryFile.$query];\r\n            }\r\n        } else {\r\n            if ('entity' in query) {\r\n                entityType = query.type;\r\n                query = query.entity; // query is a function name;\r\n            } else {\r\n                if (query instanceof ServerFormatting) {\r\n                    pgFormatting = true;\r\n                } else {\r\n                    if ('name' in query) {\r\n                        query = new PreparedStatement(query);\r\n                        pgFormatting = true;\r\n                    } else {\r\n                        if ('text' in query) {\r\n                            query = new ParameterizedQuery(query);\r\n                            pgFormatting = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (query instanceof ServerFormatting && !npm.utils.isNull(values)) {\r\n                    query.values = values;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!error) {\r\n        if (!pgFormatting && !npm.utils.isText(query)) {\r\n            const errTxt = entityType ? (entityType === 'func' ? npm.text.invalidFunction : npm.text.invalidProc) : npm.text.invalidQuery;\r\n            error = new TypeError(errTxt);\r\n        }\r\n        if (query instanceof ServerFormatting) {\r\n            const qp = query.parse();\r\n            if (qp instanceof Error) {\r\n                error = qp;\r\n            } else {\r\n                query = qp;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!error && !special) {\r\n        if (npm.utils.isNull(qrm)) {\r\n            qrm = queryResult.any; // default query result;\r\n        } else {\r\n            if (qrm !== parseInt(qrm) || (qrm & badMask) === badMask || qrm < 1 || qrm > 6) {\r\n                error = new TypeError(npm.text.invalidMask);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!error && (!pgFormatting || entityType)) {\r\n        try {\r\n            // use 'pg-promise' implementation of values formatting;\r\n            if (entityType) {\r\n                params = undefined;\r\n                query = npm.formatting.formatEntity(query, values, {capSQL, type: entityType});\r\n            } else {\r\n                query = npm.formatting.formatQuery(query, values);\r\n            }\r\n        } catch (e) {\r\n            if (entityType) {\r\n                let prefix = entityType === 'func' ? 'select * from' : 'call';\r\n                if (capSQL) {\r\n                    prefix = prefix.toUpperCase();\r\n                }\r\n                query = prefix + ' ' + query + '(...)';\r\n            } else {\r\n                params = values;\r\n            }\r\n            error = e instanceof Error ? e : new npm.utils.InternalError(e);\r\n        }\r\n    }\r\n\r\n    return $p((resolve, reject) => {\r\n\r\n        if (notifyReject()) {\r\n            return;\r\n        }\r\n        error = Events.query(opt, getContext());\r\n        if (notifyReject()) {\r\n            return;\r\n        }\r\n        try {\r\n            const start = Date.now();\r\n            ctx.db.client.query(query, params, (err, result) => {\r\n                let data, multiResult, lastResult = result;\r\n                if (err) {\r\n                    // istanbul ignore if (auto-testing connectivity issues is too problematic)\r\n                    if (npm.utils.isConnectivityError(err)) {\r\n                        ctx.db.client.$connectionError = err;\r\n                    }\r\n                    err.query = err.query || query;\r\n                    err.params = err.params || params;\r\n                    error = err;\r\n                } else {\r\n                    multiResult = Array.isArray(result);\r\n                    if (multiResult) {\r\n                        lastResult = result[result.length - 1];\r\n                        for (let i = 0; i < result.length; i++) {\r\n                            const r = result[i];\r\n                            makeIterable(r);\r\n                            error = Events.receive(opt, r.rows, r, getContext());\r\n                            if (error) {\r\n                                break;\r\n                            }\r\n                        }\r\n                    } else {\r\n                        makeIterable(result);\r\n                        result.duration = Date.now() - start;\r\n                        error = Events.receive(opt, result.rows, result, getContext());\r\n                    }\r\n                }\r\n                if (!error) {\r\n                    data = lastResult;\r\n                    if (special) {\r\n                        if (special.isMultiResult) {\r\n                            data = multiResult ? result : [result]; // method .multiResult() is called\r\n                        }\r\n                        // else, method .result() is called\r\n                    } else {\r\n                        data = data.rows;\r\n                        const len = data.length;\r\n                        if (len) {\r\n                            if (len > 1 && qrm & queryResult.one) {\r\n                                // one row was expected, but returned multiple;\r\n                                error = new QueryResultError(qrec.multiple, lastResult, query, params);\r\n                            } else {\r\n                                if (!(qrm & (queryResult.one | queryResult.many))) {\r\n                                    // no data should have been returned;\r\n                                    error = new QueryResultError(qrec.notEmpty, lastResult, query, params);\r\n                                } else {\r\n                                    if (!(qrm & queryResult.many)) {\r\n                                        data = data[0];\r\n                                    }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            // no data returned;\r\n                            if (qrm & queryResult.none) {\r\n                                if (qrm & queryResult.one) {\r\n                                    data = null;\r\n                                } else {\r\n                                    data = qrm & queryResult.many ? data : null;\r\n                                }\r\n                            } else {\r\n                                error = new QueryResultError(qrec.noData, lastResult, query, params);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!notifyReject()) {\r\n                    resolve(data);\r\n                }\r\n            });\r\n        } catch (e) {\r\n            // this can only happen as a result of an internal failure within node-postgres,\r\n            // like during a sudden loss of communications, which is impossible to reproduce\r\n            // automatically, so removing it from the test coverage:\r\n            // istanbul ignore next\r\n            error = e;\r\n        }\r\n\r\n        function getContext() {\r\n            let client;\r\n            if (ctx.db) {\r\n                client = ctx.db.client;\r\n            } else {\r\n                error = new Error(npm.text.looseQuery);\r\n            }\r\n            return {\r\n                client, query, params,\r\n                dc: ctx.dc,\r\n                ctx: ctx.ctx\r\n            };\r\n        }\r\n\r\n        notifyReject();\r\n\r\n        function notifyReject() {\r\n            const context = getContext();\r\n            if (error) {\r\n                if (error instanceof InternalError) {\r\n                    error = error.error;\r\n                }\r\n                Events.error(opt, error, context);\r\n                reject(error);\r\n                return true;\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n// Extends Result to provide iterable for the rows;\r\n//\r\n// To be removed once the following PR is merged amd released:\r\n// https://github.com/brianc/node-postgres/pull/2861\r\nfunction makeIterable(r) {\r\n    r[Symbol.iterator] = function () {\r\n        return this.rows.values();\r\n    };\r\n}\r\n\r\nmodule.exports = config => {\r\n    return function (ctx, query, values, qrm) {\r\n        return $query.call(this, ctx, query, values, qrm, config);\r\n    };\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}