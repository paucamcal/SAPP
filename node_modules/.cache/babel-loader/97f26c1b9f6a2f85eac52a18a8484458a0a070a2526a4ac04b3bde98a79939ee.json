{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\n\nconst {\n  assert\n} = require('../assert');\nconst npm = {\n  fs: require('fs'),\n  path: require('path'),\n  utils: require('./'),\n  package: require('../../package.json')\n};\n\n/**\r\n * @method utils.camelize\r\n * @description\r\n * Camelizes a text string.\r\n *\r\n * Case-changing characters include:\r\n * - _hyphen_\r\n * - _underscore_\r\n * - _period_\r\n * - _space_\r\n *\r\n * @param {string} text\r\n * Input text string.\r\n *\r\n * @returns {string}\r\n * Camelized text string.\r\n *\r\n * @see\r\n * {@link utils.camelizeVar camelizeVar}\r\n *\r\n */\nfunction camelize(text) {\n  text = text.replace(/[-_\\s.]+(.)?/g, (_, c) => c ? c.toUpperCase() : '');\n  return text.substr(0, 1).toLowerCase() + text.substr(1);\n}\n\n/**\r\n * @method utils.camelizeVar\r\n * @description\r\n * Camelizes a text string, while making it compliant with JavaScript variable names:\r\n * - contains symbols `a-z`, `A-Z`, `0-9`, `_` and `$`\r\n * - cannot have leading digits\r\n *\r\n * First, it removes all symbols that do not meet the above criteria, except for _hyphen_, _period_ and _space_,\r\n * and then it forwards into {@link utils.camelize camelize}.\r\n *\r\n * @param {string} text\r\n * Input text string.\r\n *\r\n * If it doesn't contain any symbols to make up a valid variable name, the result will be an empty string.\r\n *\r\n * @returns {string}\r\n * Camelized text string that can be used as an open property name.\r\n *\r\n * @see\r\n * {@link utils.camelize camelize}\r\n *\r\n */\nfunction camelizeVar(text) {\n  text = text.replace(/[^a-zA-Z0-9$_\\-\\s.]/g, '').replace(/^[0-9_\\-\\s.]+/, '');\n  return camelize(text);\n}\nfunction _enumSql(dir, options, cb, namePath) {\n  const tree = {};\n  npm.fs.readdirSync(dir).forEach(file => {\n    let stat;\n    const fullPath = npm.path.join(dir, file);\n    try {\n      stat = npm.fs.statSync(fullPath);\n    } catch (e) {\n      // while it is very easy to test manually, it is very difficult to test for\n      // access-denied errors automatically; therefore excluding from the coverage:\n      // istanbul ignore next\n      if (options.ignoreErrors) {\n        return; // on to the next file/folder;\n      }\n      // istanbul ignore next\n      throw e;\n    }\n    if (stat.isDirectory()) {\n      if (options.recursive) {\n        const dirName = camelizeVar(file);\n        const np = namePath ? namePath + '.' + dirName : dirName;\n        const t = _enumSql(fullPath, options, cb, np);\n        if (Object.keys(t).length) {\n          if (!dirName.length || dirName in tree) {\n            if (!options.ignoreErrors) {\n              throw new Error('Empty or duplicate camelized folder name: ' + fullPath);\n            }\n          }\n          tree[dirName] = t;\n        }\n      }\n    } else {\n      if (npm.path.extname(file).toLowerCase() === '.sql') {\n        const name = camelizeVar(file.replace(/\\.[^/.]+$/, ''));\n        if (!name.length || name in tree) {\n          if (!options.ignoreErrors) {\n            throw new Error('Empty or duplicate camelized file name: ' + fullPath);\n          }\n        }\n        tree[name] = fullPath;\n        if (cb) {\n          const result = cb(fullPath, name, namePath ? namePath + '.' + name : name);\n          if (result !== undefined) {\n            tree[name] = result;\n          }\n        }\n      }\n    }\n  });\n  return tree;\n}\n\n/**\r\n * @method utils.enumSql\r\n * @description\r\n * Synchronously enumerates all SQL files (within a given directory) into a camelized SQL tree.\r\n *\r\n * All property names within the tree are camelized via {@link utils.camelizeVar camelizeVar},\r\n * so they can be used in the code directly, as open property names.\r\n *\r\n * @param {string} dir\r\n * Directory path where SQL files are located, either absolute or relative to the current directory.\r\n *\r\n * SQL files are identified by using `.sql` extension (case-insensitive).\r\n *\r\n * @param {{}} [options]\r\n * Search options.\r\n *\r\n * @param {boolean} [options.recursive=false]\r\n * Include sub-directories into the search.\r\n *\r\n * Sub-directories without SQL files will be skipped from the result.\r\n *\r\n * @param {boolean} [options.ignoreErrors=false]\r\n * Ignore the following types of errors:\r\n * - access errors, when there is no read access to a file or folder\r\n * - empty or duplicate camelized property names\r\n *\r\n * This flag does not affect errors related to invalid input parameters, or if you pass in a\r\n * non-existing directory.\r\n *\r\n * @param {function} [cb]\r\n * A callback function that takes three arguments:\r\n * - `file` - SQL file path, relative or absolute, according to how you specified the search directory\r\n * - `name` - name of the property that represents the SQL file\r\n * - `path` - property resolution path (full property name)\r\n *\r\n * If the function returns anything other than `undefined`, it overrides the corresponding property value in the tree.\r\n *\r\n * @returns {object}\r\n * Camelized SQL tree object, with each value being an SQL file path (unless changed via the callback).\r\n *\r\n * @example\r\n *\r\n * // simple SQL tree generation for further processing:\r\n * const tree = pgp.utils.enumSql('../sql', {recursive: true});\r\n *\r\n * @example\r\n *\r\n * // generating an SQL tree for dynamic use of names:\r\n * const sql = pgp.utils.enumSql(__dirname, {recursive: true}, file => {\r\n *     return new pgp.QueryFile(file, {minify: true});\r\n * });\r\n *\r\n * @example\r\n *\r\n * const {join: joinPath} = require('path');\r\n *\r\n * // replacing each relative path in the tree with a full one:\r\n * const tree = pgp.utils.enumSql('../sql', {recursive: true}, file => {\r\n *     return joinPath(__dirname, file);\r\n * });\r\n *\r\n */\nfunction enumSql(dir, options, cb) {\n  if (!npm.utils.isText(dir)) {\n    throw new TypeError('Parameter \\'dir\\' must be a non-empty text string.');\n  }\n  options = assert(options, ['recursive', 'ignoreErrors']);\n  cb = typeof cb === 'function' ? cb : null;\n  return _enumSql(dir, options, cb, '');\n}\n\n/**\r\n * @method utils.taskArgs\r\n * @description\r\n * Normalizes/prepares arguments for tasks and transactions.\r\n *\r\n * Its main purpose is to simplify adding custom methods {@link Database#task task}, {@link Database#taskIf taskIf},\r\n * {@link Database#tx tx} and {@link Database#txIf txIf} within event {@link event:extend extend}, as the those methods use fairly\r\n * complex logic for parsing inputs.\r\n *\r\n * @param args {Object}\r\n * Array-like object of `arguments` that was passed into the method. It is expected that the `arguments`\r\n * are always made of two parameters - `(options, cb)`, same as all the default task/transaction methods.\r\n *\r\n * And if your custom method needs additional parameters, they should be passed in as extra properties within `options`.\r\n *\r\n * @returns {Array}\r\n * Array of arguments that can be passed into a task or transaction.\r\n *\r\n * It is extended with properties `options` and `cb` to access the corresponding array elements `[0]` and `[1]` by name.\r\n *\r\n * @example\r\n *\r\n * // Registering a custom transaction method that assigns a default Transaction Mode:\r\n *\r\n * const initOptions = {\r\n *     extend: obj => {\r\n *         obj.myTx = function(options, cb) {\r\n *             const args = pgp.utils.taskArgs(arguments); // prepare arguments\r\n *\r\n *             if (!('mode' in args.options)) {\r\n *                 // if no 'mode' was specified, set default for transaction mode:\r\n *                 args.options.mode = myTxModeObject; // of type pgp.txMode.TransactionMode\r\n *             }\r\n *\r\n *             return obj.tx.apply(this, args);\r\n *             // or explicitly, if needed:\r\n *             // return obj.tx.call(this, args.options, args.cb);\r\n *         }\r\n *     }\r\n * };\r\n *\r\n */\nfunction taskArgs(args) {\n  if (!args || typeof args.length !== 'number') {\n    throw new TypeError('Parameter \\'args\\' must be an array-like object of arguments.');\n  }\n  let options = args[0],\n    cb;\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n    if (cb.name) {\n      options.tag = cb.name;\n    }\n  } else {\n    if (typeof args[1] === 'function') {\n      cb = args[1];\n    }\n    if (typeof options === 'string' || typeof options === 'number') {\n      options = {\n        tag: options\n      };\n    } else {\n      options = typeof options === 'object' && options || {};\n      if (!('tag' in options) && cb && cb.name) {\n        options.tag = cb.name;\n      }\n    }\n  }\n  const res = [options, cb];\n  Object.defineProperty(res, 'options', {\n    get: function () {\n      return this[0];\n    },\n    set: function (newValue) {\n      this[0] = newValue;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(res, 'cb', {\n    get: function () {\n      return this[1];\n    },\n    set: function (newValue) {\n      this[1] = newValue;\n    },\n    enumerable: true\n  });\n  return res;\n}\n\n/**\r\n * @namespace utils\r\n *\r\n * @description\r\n * Namespace for general-purpose static functions, available as `pgp.utils`, before and after initializing the library.\r\n *\r\n * @property {function} camelize\r\n * {@link utils.camelize camelize} - camelizes a text string\r\n *\r\n * @property {function} camelizeVar\r\n * {@link utils.camelizeVar camelizeVar} - camelizes a text string as a variable\r\n *\r\n * @property {function} enumSql\r\n * {@link utils.enumSql enumSql} - enumerates SQL files in a directory\r\n *\r\n * @property {function} taskArgs\r\n * {@link utils.taskArgs taskArgs} - prepares arguments for tasks and transactions\r\n */\nmodule.exports = {\n  camelize,\n  camelizeVar,\n  enumSql,\n  taskArgs\n};","map":{"version":3,"names":["assert","require","npm","fs","path","utils","package","camelize","text","replace","_","c","toUpperCase","substr","toLowerCase","camelizeVar","_enumSql","dir","options","cb","namePath","tree","readdirSync","forEach","file","stat","fullPath","join","statSync","e","ignoreErrors","isDirectory","recursive","dirName","np","t","Object","keys","length","Error","extname","name","result","undefined","enumSql","isText","TypeError","taskArgs","args","tag","res","defineProperty","get","set","newValue","enumerable","module","exports"],"sources":["/Users/luna/Library/Mobile Documents/com~apple~CloudDocs/GitHub/paucamcal.github.io/AESP/node_modules/pg-promise/lib/utils/public.js"],"sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {assert} = require('../assert');\r\n\r\nconst npm = {\r\n    fs: require('fs'),\r\n    path: require('path'),\r\n    utils: require('./'),\r\n    package: require('../../package.json')\r\n};\r\n\r\n/**\r\n * @method utils.camelize\r\n * @description\r\n * Camelizes a text string.\r\n *\r\n * Case-changing characters include:\r\n * - _hyphen_\r\n * - _underscore_\r\n * - _period_\r\n * - _space_\r\n *\r\n * @param {string} text\r\n * Input text string.\r\n *\r\n * @returns {string}\r\n * Camelized text string.\r\n *\r\n * @see\r\n * {@link utils.camelizeVar camelizeVar}\r\n *\r\n */\r\nfunction camelize(text) {\r\n    text = text.replace(/[-_\\s.]+(.)?/g, (_, c) => c ? c.toUpperCase() : '');\r\n    return text.substr(0, 1).toLowerCase() + text.substr(1);\r\n}\r\n\r\n/**\r\n * @method utils.camelizeVar\r\n * @description\r\n * Camelizes a text string, while making it compliant with JavaScript variable names:\r\n * - contains symbols `a-z`, `A-Z`, `0-9`, `_` and `$`\r\n * - cannot have leading digits\r\n *\r\n * First, it removes all symbols that do not meet the above criteria, except for _hyphen_, _period_ and _space_,\r\n * and then it forwards into {@link utils.camelize camelize}.\r\n *\r\n * @param {string} text\r\n * Input text string.\r\n *\r\n * If it doesn't contain any symbols to make up a valid variable name, the result will be an empty string.\r\n *\r\n * @returns {string}\r\n * Camelized text string that can be used as an open property name.\r\n *\r\n * @see\r\n * {@link utils.camelize camelize}\r\n *\r\n */\r\nfunction camelizeVar(text) {\r\n    text = text.replace(/[^a-zA-Z0-9$_\\-\\s.]/g, '').replace(/^[0-9_\\-\\s.]+/, '');\r\n    return camelize(text);\r\n}\r\n\r\nfunction _enumSql(dir, options, cb, namePath) {\r\n    const tree = {};\r\n    npm.fs.readdirSync(dir).forEach(file => {\r\n        let stat;\r\n        const fullPath = npm.path.join(dir, file);\r\n        try {\r\n            stat = npm.fs.statSync(fullPath);\r\n        } catch (e) {\r\n            // while it is very easy to test manually, it is very difficult to test for\r\n            // access-denied errors automatically; therefore excluding from the coverage:\r\n            // istanbul ignore next\r\n            if (options.ignoreErrors) {\r\n                return; // on to the next file/folder;\r\n            }\r\n            // istanbul ignore next\r\n            throw e;\r\n        }\r\n        if (stat.isDirectory()) {\r\n            if (options.recursive) {\r\n                const dirName = camelizeVar(file);\r\n                const np = namePath ? (namePath + '.' + dirName) : dirName;\r\n                const t = _enumSql(fullPath, options, cb, np);\r\n                if (Object.keys(t).length) {\r\n                    if (!dirName.length || dirName in tree) {\r\n                        if (!options.ignoreErrors) {\r\n                            throw new Error('Empty or duplicate camelized folder name: ' + fullPath);\r\n                        }\r\n                    }\r\n                    tree[dirName] = t;\r\n                }\r\n            }\r\n        } else {\r\n            if (npm.path.extname(file).toLowerCase() === '.sql') {\r\n                const name = camelizeVar(file.replace(/\\.[^/.]+$/, ''));\r\n                if (!name.length || name in tree) {\r\n                    if (!options.ignoreErrors) {\r\n                        throw new Error('Empty or duplicate camelized file name: ' + fullPath);\r\n                    }\r\n                }\r\n                tree[name] = fullPath;\r\n                if (cb) {\r\n                    const result = cb(fullPath, name, namePath ? (namePath + '.' + name) : name);\r\n                    if (result !== undefined) {\r\n                        tree[name] = result;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    });\r\n    return tree;\r\n}\r\n\r\n/**\r\n * @method utils.enumSql\r\n * @description\r\n * Synchronously enumerates all SQL files (within a given directory) into a camelized SQL tree.\r\n *\r\n * All property names within the tree are camelized via {@link utils.camelizeVar camelizeVar},\r\n * so they can be used in the code directly, as open property names.\r\n *\r\n * @param {string} dir\r\n * Directory path where SQL files are located, either absolute or relative to the current directory.\r\n *\r\n * SQL files are identified by using `.sql` extension (case-insensitive).\r\n *\r\n * @param {{}} [options]\r\n * Search options.\r\n *\r\n * @param {boolean} [options.recursive=false]\r\n * Include sub-directories into the search.\r\n *\r\n * Sub-directories without SQL files will be skipped from the result.\r\n *\r\n * @param {boolean} [options.ignoreErrors=false]\r\n * Ignore the following types of errors:\r\n * - access errors, when there is no read access to a file or folder\r\n * - empty or duplicate camelized property names\r\n *\r\n * This flag does not affect errors related to invalid input parameters, or if you pass in a\r\n * non-existing directory.\r\n *\r\n * @param {function} [cb]\r\n * A callback function that takes three arguments:\r\n * - `file` - SQL file path, relative or absolute, according to how you specified the search directory\r\n * - `name` - name of the property that represents the SQL file\r\n * - `path` - property resolution path (full property name)\r\n *\r\n * If the function returns anything other than `undefined`, it overrides the corresponding property value in the tree.\r\n *\r\n * @returns {object}\r\n * Camelized SQL tree object, with each value being an SQL file path (unless changed via the callback).\r\n *\r\n * @example\r\n *\r\n * // simple SQL tree generation for further processing:\r\n * const tree = pgp.utils.enumSql('../sql', {recursive: true});\r\n *\r\n * @example\r\n *\r\n * // generating an SQL tree for dynamic use of names:\r\n * const sql = pgp.utils.enumSql(__dirname, {recursive: true}, file => {\r\n *     return new pgp.QueryFile(file, {minify: true});\r\n * });\r\n *\r\n * @example\r\n *\r\n * const {join: joinPath} = require('path');\r\n *\r\n * // replacing each relative path in the tree with a full one:\r\n * const tree = pgp.utils.enumSql('../sql', {recursive: true}, file => {\r\n *     return joinPath(__dirname, file);\r\n * });\r\n *\r\n */\r\nfunction enumSql(dir, options, cb) {\r\n    if (!npm.utils.isText(dir)) {\r\n        throw new TypeError('Parameter \\'dir\\' must be a non-empty text string.');\r\n    }\r\n    options = assert(options, ['recursive', 'ignoreErrors']);\r\n    cb = (typeof cb === 'function') ? cb : null;\r\n    return _enumSql(dir, options, cb, '');\r\n}\r\n\r\n/**\r\n * @method utils.taskArgs\r\n * @description\r\n * Normalizes/prepares arguments for tasks and transactions.\r\n *\r\n * Its main purpose is to simplify adding custom methods {@link Database#task task}, {@link Database#taskIf taskIf},\r\n * {@link Database#tx tx} and {@link Database#txIf txIf} within event {@link event:extend extend}, as the those methods use fairly\r\n * complex logic for parsing inputs.\r\n *\r\n * @param args {Object}\r\n * Array-like object of `arguments` that was passed into the method. It is expected that the `arguments`\r\n * are always made of two parameters - `(options, cb)`, same as all the default task/transaction methods.\r\n *\r\n * And if your custom method needs additional parameters, they should be passed in as extra properties within `options`.\r\n *\r\n * @returns {Array}\r\n * Array of arguments that can be passed into a task or transaction.\r\n *\r\n * It is extended with properties `options` and `cb` to access the corresponding array elements `[0]` and `[1]` by name.\r\n *\r\n * @example\r\n *\r\n * // Registering a custom transaction method that assigns a default Transaction Mode:\r\n *\r\n * const initOptions = {\r\n *     extend: obj => {\r\n *         obj.myTx = function(options, cb) {\r\n *             const args = pgp.utils.taskArgs(arguments); // prepare arguments\r\n *\r\n *             if (!('mode' in args.options)) {\r\n *                 // if no 'mode' was specified, set default for transaction mode:\r\n *                 args.options.mode = myTxModeObject; // of type pgp.txMode.TransactionMode\r\n *             }\r\n *\r\n *             return obj.tx.apply(this, args);\r\n *             // or explicitly, if needed:\r\n *             // return obj.tx.call(this, args.options, args.cb);\r\n *         }\r\n *     }\r\n * };\r\n *\r\n */\r\nfunction taskArgs(args) {\r\n\r\n    if (!args || typeof args.length !== 'number') {\r\n        throw new TypeError('Parameter \\'args\\' must be an array-like object of arguments.');\r\n    }\r\n\r\n    let options = args[0], cb;\r\n    if (typeof options === 'function') {\r\n        cb = options;\r\n        options = {};\r\n        if (cb.name) {\r\n            options.tag = cb.name;\r\n        }\r\n    } else {\r\n        if (typeof args[1] === 'function') {\r\n            cb = args[1];\r\n        }\r\n        if (typeof options === 'string' || typeof options === 'number') {\r\n            options = {tag: options};\r\n        } else {\r\n            options = (typeof options === 'object' && options) || {};\r\n            if (!('tag' in options) && cb && cb.name) {\r\n                options.tag = cb.name;\r\n            }\r\n        }\r\n    }\r\n\r\n    const res = [options, cb];\r\n\r\n    Object.defineProperty(res, 'options', {\r\n        get: function () {\r\n            return this[0];\r\n        },\r\n        set: function (newValue) {\r\n            this[0] = newValue;\r\n        },\r\n        enumerable: true\r\n    });\r\n\r\n    Object.defineProperty(res, 'cb', {\r\n        get: function () {\r\n            return this[1];\r\n        },\r\n        set: function (newValue) {\r\n            this[1] = newValue;\r\n        },\r\n        enumerable: true\r\n    });\r\n\r\n    return res;\r\n}\r\n\r\n/**\r\n * @namespace utils\r\n *\r\n * @description\r\n * Namespace for general-purpose static functions, available as `pgp.utils`, before and after initializing the library.\r\n *\r\n * @property {function} camelize\r\n * {@link utils.camelize camelize} - camelizes a text string\r\n *\r\n * @property {function} camelizeVar\r\n * {@link utils.camelizeVar camelizeVar} - camelizes a text string as a variable\r\n *\r\n * @property {function} enumSql\r\n * {@link utils.enumSql enumSql} - enumerates SQL files in a directory\r\n *\r\n * @property {function} taskArgs\r\n * {@link utils.taskArgs taskArgs} - prepares arguments for tasks and transactions\r\n */\r\nmodule.exports = {\r\n    camelize,\r\n    camelizeVar,\r\n    enumSql,\r\n    taskArgs\r\n};\r\n"],"mappings":"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AEe,IAAI,EAAErB,QAAQ,GAAIA,QAAQ,GAAG,GAAG,GAAGqB,IAAI,GAAIA,IAAI,CAAC;UAC5E,IAAIC,MAAM,KAAKC,SAAS,EAAE;YACtBtB,IAAI,CAACoB,IAAI,CAAC,GAAGC,MAAM;UACvB;QACJ;MACJ;IACJ;EACJ,CAAC,CAAC;EACF,OAAOrB,IAAI;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASuB,OAAOA,CAAC3B,GAAG,EAAEC,OAAO,EAAEC,EAAE,EAAE;EAC/B,IAAI,CAACjB,GAAG,CAACG,KAAK,CAACwC,MAAM,CAAC5B,GAAG,CAAC,EAAE;IACxB,MAAM,IAAI6B,SAAS,CAAC,oDAAoD,CAAC;EAC7E;EACA5B,OAAO,GAAGlB,MAAM,CAACkB,OAAO,EAAE,CAAC,WAAW,EAAE,cAAc,CAAC,CAAC;EACxDC,EAAE,GAAI,OAAOA,EAAE,KAAK,UAAU,GAAIA,EAAE,GAAG,IAAI;EAC3C,OAAOH,QAAQ,CAACC,GAAG,EAAEC,OAAO,EAAEC,EAAE,EAAE,EAAE,CAAC;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS4B,QAAQA,CAACC,IAAI,EAAE;EAEpB,IAAI,CAACA,IAAI,IAAI,OAAOA,IAAI,CAACV,MAAM,KAAK,QAAQ,EAAE;IAC1C,MAAM,IAAIQ,SAAS,CAAC,+DAA+D,CAAC;EACxF;EAEA,IAAI5B,OAAO,GAAG8B,IAAI,CAAC,CAAC,CAAC;IAAE7B,EAAE;EACzB,IAAI,OAAOD,OAAO,KAAK,UAAU,EAAE;IAC/BC,EAAE,GAAGD,OAAO;IACZA,OAAO,GAAG,CAAC,CAAC;IACZ,IAAIC,EAAE,CAACsB,IAAI,EAAE;MACTvB,OAAO,CAAC+B,GAAG,GAAG9B,EAAE,CAACsB,IAAI;IACzB;EACJ,CAAC,MAAM;IACH,IAAI,OAAOO,IAAI,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;MAC/B7B,EAAE,GAAG6B,IAAI,CAAC,CAAC,CAAC;IAChB;IACA,IAAI,OAAO9B,OAAO,KAAK,QAAQ,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;MAC5DA,OAAO,GAAG;QAAC+B,GAAG,EAAE/B;MAAO,CAAC;IAC5B,CAAC,MAAM;MACHA,OAAO,GAAI,OAAOA,OAAO,KAAK,QAAQ,IAAIA,OAAO,IAAK,CAAC,CAAC;MACxD,IAAI,EAAE,KAAK,IAAIA,OAAO,CAAC,IAAIC,EAAE,IAAIA,EAAE,CAACsB,IAAI,EAAE;QACtCvB,OAAO,CAAC+B,GAAG,GAAG9B,EAAE,CAACsB,IAAI;MACzB;IACJ;EACJ;EAEA,MAAMS,GAAG,GAAG,CAAChC,OAAO,EAAEC,EAAE,CAAC;EAEzBiB,MAAM,CAACe,cAAc,CAACD,GAAG,EAAE,SAAS,EAAE;IAClCE,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,OAAO,IAAI,CAAC,CAAC,CAAC;IAClB,CAAC;IACDC,GAAG,EAAE,SAAAA,CAAUC,QAAQ,EAAE;MACrB,IAAI,CAAC,CAAC,CAAC,GAAGA,QAAQ;IACtB,CAAC;IACDC,UAAU,EAAE;EAChB,CAAC,CAAC;EAEFnB,MAAM,CAACe,cAAc,CAACD,GAAG,EAAE,IAAI,EAAE;IAC7BE,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,OAAO,IAAI,CAAC,CAAC,CAAC;IAClB,CAAC;IACDC,GAAG,EAAE,SAAAA,CAAUC,QAAQ,EAAE;MACrB,IAAI,CAAC,CAAC,CAAC,GAAGA,QAAQ;IACtB,CAAC;IACDC,UAAU,EAAE;EAChB,CAAC,CAAC;EAEF,OAAOL,GAAG;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAM,MAAM,CAACC,OAAO,GAAG;EACblD,QAAQ;EACRQ,WAAW;EACX6B,OAAO;EACPG;AACJ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}